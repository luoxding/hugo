<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: lib/Dialect/LLVMIR/IR/LLVMInlining.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">18.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_1a25ec519b6c1121408b67cc33ce3f15.html">Dialect</a></li><li class="navelem"><a class="el" href="dir_f72a41bb578a410851fd64995e591ebe.html">LLVMIR</a></li><li class="navelem"><a class="el" href="dir_1152a5ee5c1c5147885c58e5a7ed67e7.html">IR</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">LLVMInlining.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="LLVMInlining_8h_source.html">LLVMInlining.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="LLVMDialect_8h_source.html">mlir/Dialect/LLVMIR/LLVMDialect.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Matchers_8h_source.html">mlir/IR/Matchers.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="DataLayoutInterfaces_8h_source.html">mlir/Interfaces/DataLayoutInterfaces.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="InliningUtils_8h_source.html">mlir/Transforms/InliningUtils.h</a>&quot;</code><br />
<code>#include &quot;llvm/ADT/ScopeExit.h&quot;</code><br />
<code>#include &quot;llvm/Support/Debug.h&quot;</code><br />
</div>
<p><a href="LLVMInlining_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LLVMInlining_8cpp.html#ad78e062f62e0d6e453941fb4ca843e4d">DEBUG_TYPE</a>&#160;&#160;&#160;&quot;llvm-inliner&quot;</td></tr>
<tr class="separator:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0d9f07cb870d6fca954bcd17a8e28c67"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LLVMInlining_8cpp.html#a0d9f07cb870d6fca954bcd17a8e28c67">hasLifetimeMarkers</a> (LLVM::AllocaOp allocaOp)</td></tr>
<tr class="memdesc:a0d9f07cb870d6fca954bcd17a8e28c67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the given alloca is an input to a lifetime intrinsic, optionally passing through one or more casts on the way.  <a href="LLVMInlining_8cpp.html#a0d9f07cb870d6fca954bcd17a8e28c67">More...</a><br /></td></tr>
<tr class="separator:a0d9f07cb870d6fca954bcd17a8e28c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff1e0bb11c4fb9a8905b2bacb6b79688"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LLVMInlining_8cpp.html#aff1e0bb11c4fb9a8905b2bacb6b79688">handleInlinedAllocas</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *call, <a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="classmlir_1_1Region.html#ace0e74dc2b54e7d7cd5406e9008306f9">Region::iterator</a> &gt; inlinedBlocks)</td></tr>
<tr class="memdesc:aff1e0bb11c4fb9a8905b2bacb6b79688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles alloca operations in the inlined blocks:  <a href="LLVMInlining_8cpp.html#aff1e0bb11c4fb9a8905b2bacb6b79688">More...</a><br /></td></tr>
<tr class="separator:aff1e0bb11c4fb9a8905b2bacb6b79688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba3e17e98fc89227b2bc04949f9cfb1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LLVMInlining_8cpp.html#acba3e17e98fc89227b2bc04949f9cfb1">deepCloneAliasScopes</a> (<a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="classmlir_1_1Region.html#ace0e74dc2b54e7d7cd5406e9008306f9">Region::iterator</a> &gt; inlinedBlocks)</td></tr>
<tr class="memdesc:acba3e17e98fc89227b2bc04949f9cfb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps all alias scopes in the inlined operations to deep clones of the scopes and domain.  <a href="LLVMInlining_8cpp.html#acba3e17e98fc89227b2bc04949f9cfb1">More...</a><br /></td></tr>
<tr class="separator:acba3e17e98fc89227b2bc04949f9cfb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f94b4fd0a0ebd5831734fec3667225"><td class="memItemLeft" align="right" valign="top">static ArrayAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LLVMInlining_8cpp.html#a38f94b4fd0a0ebd5831734fec3667225">concatArrayAttr</a> (ArrayAttr lhs, ArrayAttr rhs)</td></tr>
<tr class="memdesc:a38f94b4fd0a0ebd5831734fec3667225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new ArrayAttr by concatenating <code>lhs</code> with <code>rhs</code>.  <a href="LLVMInlining_8cpp.html#a38f94b4fd0a0ebd5831734fec3667225">More...</a><br /></td></tr>
<tr class="separator:a38f94b4fd0a0ebd5831734fec3667225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab62fcc9447725dbd40ee90b7b66acbf9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LLVMInlining_8cpp.html#ab62fcc9447725dbd40ee90b7b66acbf9">getUnderlyingObject</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> pointerValue)</td></tr>
<tr class="memdesc:ab62fcc9447725dbd40ee90b7b66acbf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to return the underlying pointer value that <code>pointerValue</code> is based on.  <a href="LLVMInlining_8cpp.html#ab62fcc9447725dbd40ee90b7b66acbf9">More...</a><br /></td></tr>
<tr class="separator:ab62fcc9447725dbd40ee90b7b66acbf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836210b9567523c2b82a79e90bcf43fd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LLVMInlining_8cpp.html#a836210b9567523c2b82a79e90bcf43fd">getUnderlyingObjectSet</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> pointerValue)</td></tr>
<tr class="memdesc:a836210b9567523c2b82a79e90bcf43fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to return the set of all underlying pointer values that <code>pointerValue</code> is based on.  <a href="LLVMInlining_8cpp.html#a836210b9567523c2b82a79e90bcf43fd">More...</a><br /></td></tr>
<tr class="separator:a836210b9567523c2b82a79e90bcf43fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a551e1cab4d934d4b4923f17ce1f15b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LLVMInlining_8cpp.html#a3a551e1cab4d934d4b4923f17ce1f15b">createNewAliasScopesFromNoAliasParameter</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *call, <a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="classmlir_1_1Region.html#ace0e74dc2b54e7d7cd5406e9008306f9">Region::iterator</a> &gt; inlinedBlocks)</td></tr>
<tr class="memdesc:a3a551e1cab4d934d4b4923f17ce1f15b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new AliasScopeAttr for every noalias parameter and attaches it to the appropriate inlined memory operations in an attempt to preserve the original semantics of the parameter attribute.  <a href="LLVMInlining_8cpp.html#a3a551e1cab4d934d4b4923f17ce1f15b">More...</a><br /></td></tr>
<tr class="separator:a3a551e1cab4d934d4b4923f17ce1f15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d038c9aacbc89a3f6655fcf6de6230"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LLVMInlining_8cpp.html#a27d038c9aacbc89a3f6655fcf6de6230">appendCallOpAliasScopes</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *call, <a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="classmlir_1_1Region.html#ace0e74dc2b54e7d7cd5406e9008306f9">Region::iterator</a> &gt; inlinedBlocks)</td></tr>
<tr class="memdesc:a27d038c9aacbc89a3f6655fcf6de6230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends any alias scopes of the call operation to any inlined memory operation.  <a href="LLVMInlining_8cpp.html#a27d038c9aacbc89a3f6655fcf6de6230">More...</a><br /></td></tr>
<tr class="separator:a27d038c9aacbc89a3f6655fcf6de6230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a773fa72ae1f6a45dd93cf207e16533cb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LLVMInlining_8cpp.html#a773fa72ae1f6a45dd93cf207e16533cb">handleAliasScopes</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *call, <a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="classmlir_1_1Region.html#ace0e74dc2b54e7d7cd5406e9008306f9">Region::iterator</a> &gt; inlinedBlocks)</td></tr>
<tr class="memdesc:a773fa72ae1f6a45dd93cf207e16533cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles all interactions with alias scopes during inlining.  <a href="LLVMInlining_8cpp.html#a773fa72ae1f6a45dd93cf207e16533cb">More...</a><br /></td></tr>
<tr class="separator:a773fa72ae1f6a45dd93cf207e16533cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f6ea1ee5201914c6d4d3e4c5d14cdec"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LLVMInlining_8cpp.html#a4f6ea1ee5201914c6d4d3e4c5d14cdec">handleAccessGroups</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *call, <a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="classmlir_1_1Region.html#ace0e74dc2b54e7d7cd5406e9008306f9">Region::iterator</a> &gt; inlinedBlocks)</td></tr>
<tr class="memdesc:a4f6ea1ee5201914c6d4d3e4c5d14cdec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends any access groups of the call operation to any inlined memory operation.  <a href="LLVMInlining_8cpp.html#a4f6ea1ee5201914c6d4d3e4c5d14cdec">More...</a><br /></td></tr>
<tr class="separator:a4f6ea1ee5201914c6d4d3e4c5d14cdec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f49eadb6ca15f24813d6902d151395e"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LLVMInlining_8cpp.html#a8f49eadb6ca15f24813d6902d151395e">tryToEnforceAllocaAlignment</a> (LLVM::AllocaOp alloca, uint64_t requestedAlignment, <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> const &amp;dataLayout)</td></tr>
<tr class="memdesc:a8f49eadb6ca15f24813d6902d151395e"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>requestedAlignment</code> is higher than the alignment specified on <code>alloca</code>, realigns <code>alloca</code> if this does not exceed the natural stack alignment.  <a href="LLVMInlining_8cpp.html#a8f49eadb6ca15f24813d6902d151395e">More...</a><br /></td></tr>
<tr class="separator:a8f49eadb6ca15f24813d6902d151395e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaffb480be7672f67c36736e62f8e3210"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LLVMInlining_8cpp.html#aaffb480be7672f67c36736e62f8e3210">tryToEnforceAlignment</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value, uint64_t requestedAlignment, <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> const &amp;dataLayout)</td></tr>
<tr class="memdesc:aaffb480be7672f67c36736e62f8e3210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to find and return the alignment of the pointer <code>value</code> by looking for an alignment attribute on the defining allocation op or function argument.  <a href="LLVMInlining_8cpp.html#aaffb480be7672f67c36736e62f8e3210">More...</a><br /></td></tr>
<tr class="separator:aaffb480be7672f67c36736e62f8e3210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc746a881ef7cc35ee79a563b79d15f9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LLVMInlining_8cpp.html#adc746a881ef7cc35ee79a563b79d15f9">handleByValArgumentInit</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> argument, <a class="el" href="classmlir_1_1Type.html">Type</a> elementType, uint64_t elementTypeSize, uint64_t targetAlignment)</td></tr>
<tr class="memdesc:adc746a881ef7cc35ee79a563b79d15f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Introduces a new alloca and copies the memory pointed to by <code>argument</code> to the address of the new alloca, then returns the value of the new alloca.  <a href="LLVMInlining_8cpp.html#adc746a881ef7cc35ee79a563b79d15f9">More...</a><br /></td></tr>
<tr class="separator:adc746a881ef7cc35ee79a563b79d15f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f9d04286f30c15124be2265cfa239c8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="LLVMInlining_8cpp.html#a6f9d04286f30c15124be2265cfa239c8">handleByValArgument</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *callable, <a class="el" href="classmlir_1_1Value.html">Value</a> argument, <a class="el" href="classmlir_1_1Type.html">Type</a> elementType, uint64_t requestedAlignment)</td></tr>
<tr class="memdesc:a6f9d04286f30c15124be2265cfa239c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles a function argument marked with the byval attribute by introducing a memcpy or realigning the defining operation, if required either due to the pointee being writeable in the callee, and/or due to an alignment mismatch.  <a href="LLVMInlining_8cpp.html#a6f9d04286f30c15124be2265cfa239c8">More...</a><br /></td></tr>
<tr class="separator:a6f9d04286f30c15124be2265cfa239c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ad78e062f62e0d6e453941fb4ca843e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78e062f62e0d6e453941fb4ca843e4d">&#9670;&nbsp;</a></span>DEBUG_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_TYPE&#160;&#160;&#160;&quot;llvm-inliner&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LLVMInlining_8cpp_source.html#l00022">22</a> of file <a class="el" href="LLVMInlining_8cpp_source.html">LLVMInlining.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a27d038c9aacbc89a3f6655fcf6de6230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27d038c9aacbc89a3f6655fcf6de6230">&#9670;&nbsp;</a></span>appendCallOpAliasScopes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void appendCallOpAliasScopes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>call</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="classmlir_1_1Region.html#ace0e74dc2b54e7d7cd5406e9008306f9">Region::iterator</a> &gt;&#160;</td>
          <td class="paramname"><em>inlinedBlocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends any alias scopes of the call operation to any inlined memory operation. </p>

<p class="definition">Definition at line <a class="el" href="LLVMInlining_8cpp_source.html#l00439">439</a> of file <a class="el" href="LLVMInlining_8cpp_source.html">LLVMInlining.cpp</a>.</p>

<p class="reference">References <a class="el" href="LLVMInlining_8cpp_source.html#l00192">concatArrayAttr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LLVMInlining_8cpp_source.html#l00468">handleAliasScopes()</a>.</p>

</div>
</div>
<a id="a38f94b4fd0a0ebd5831734fec3667225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38f94b4fd0a0ebd5831734fec3667225">&#9670;&nbsp;</a></span>concatArrayAttr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ArrayAttr concatArrayAttr </td>
          <td>(</td>
          <td class="paramtype">ArrayAttr&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayAttr&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new ArrayAttr by concatenating <code>lhs</code> with <code>rhs</code>. </p>
<p>Returns null if both parameters are null. If only one attribute is null, return the other. </p>

<p class="definition">Definition at line <a class="el" href="LLVMInlining_8cpp_source.html#l00192">192</a> of file <a class="el" href="LLVMInlining_8cpp_source.html">LLVMInlining.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00510">mlir::get()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LLVMInlining_8cpp_source.html#l00439">appendCallOpAliasScopes()</a>, <a class="el" href="LLVMInlining_8cpp_source.html#l00291">createNewAliasScopesFromNoAliasParameter()</a>, and <a class="el" href="LLVMInlining_8cpp_source.html#l00477">handleAccessGroups()</a>.</p>

</div>
</div>
<a id="a3a551e1cab4d934d4b4923f17ce1f15b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a551e1cab4d934d4b4923f17ce1f15b">&#9670;&nbsp;</a></span>createNewAliasScopesFromNoAliasParameter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void createNewAliasScopesFromNoAliasParameter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>call</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="classmlir_1_1Region.html#ace0e74dc2b54e7d7cd5406e9008306f9">Region::iterator</a> &gt;&#160;</td>
          <td class="paramname"><em>inlinedBlocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new AliasScopeAttr for every noalias parameter and attaches it to the appropriate inlined memory operations in an attempt to preserve the original semantics of the parameter attribute. </p>

<p class="definition">Definition at line <a class="el" href="LLVMInlining_8cpp_source.html#l00291">291</a> of file <a class="el" href="LLVMInlining_8cpp_source.html">LLVMInlining.cpp</a>.</p>

<p class="reference">References <a class="el" href="LLVMInlining_8cpp_source.html#l00192">concatArrayAttr()</a>, <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l00071">copy()</a>, <a class="el" href="Builders_8cpp_source.html#l00446">mlir::OpBuilder::create()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00510">mlir::get()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00216">mlir::Operation::getContext()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00223">mlir::Operation::getLoc()</a>, <a class="el" href="LLVMInlining_8cpp_source.html#l00229">getUnderlyingObjectSet()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00852">mlir::Operation::getUsers()</a>, <a class="el" href="Matchers_8h_source.html#l00310">mlir::m_Constant()</a>, and <a class="el" href="Matchers_8h_source.html#l00401">mlir::matchPattern()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LLVMInlining_8cpp_source.html#l00468">handleAliasScopes()</a>.</p>

</div>
</div>
<a id="acba3e17e98fc89227b2bc04949f9cfb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acba3e17e98fc89227b2bc04949f9cfb1">&#9670;&nbsp;</a></span>deepCloneAliasScopes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void deepCloneAliasScopes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="classmlir_1_1Region.html#ace0e74dc2b54e7d7cd5406e9008306f9">Region::iterator</a> &gt;&#160;</td>
          <td class="paramname"><em>inlinedBlocks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps all alias scopes in the inlined operations to deep clones of the scopes and domain. </p>
<p>This is required for code such as <code>foo(a, b); foo(a2, b2);</code> to not incorrectly return <code>noalias</code> for e.g. operations on <code>a</code> and <code>a2</code>. </p>

<p class="definition">Definition at line <a class="el" href="LLVMInlining_8cpp_source.html#l00133">133</a> of file <a class="el" href="LLVMInlining_8cpp_source.html">LLVMInlining.cpp</a>.</p>

<p class="reference">References <a class="el" href="AttrTypeSubElements_8h_source.html#l00068">mlir::AttrTypeWalker::addWalk()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00510">mlir::get()</a>, and <a class="el" href="AttrTypeSubElements_8h_source.html#l00041">mlir::AttrTypeWalker::walk()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LLVMInlining_8cpp_source.html#l00468">handleAliasScopes()</a>.</p>

</div>
</div>
<a id="ab62fcc9447725dbd40ee90b7b66acbf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab62fcc9447725dbd40ee90b7b66acbf9">&#9670;&nbsp;</a></span>getUnderlyingObject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1Value.html">Value</a> getUnderlyingObject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>pointerValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to return the underlying pointer value that <code>pointerValue</code> is based on. </p>
<p>This traverses down the chain of operations to the last operation producing the base pointer and returns it. If it encounters an operation it cannot further traverse through, returns the operation's result. </p>

<p class="definition">Definition at line <a class="el" href="LLVMInlining_8cpp_source.html#l00208">208</a> of file <a class="el" href="LLVMInlining_8cpp_source.html">LLVMInlining.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LLVMInlining_8cpp_source.html#l00229">getUnderlyingObjectSet()</a>.</p>

</div>
</div>
<a id="a836210b9567523c2b82a79e90bcf43fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a836210b9567523c2b82a79e90bcf43fd">&#9670;&nbsp;</a></span>getUnderlyingObjectSet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; getUnderlyingObjectSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>pointerValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to return the set of all underlying pointer values that <code>pointerValue</code> is based on. </p>
<p>This function traverses through select operations and block arguments unlike getUnderlyingObject. </p>

<p class="definition">Definition at line <a class="el" href="LLVMInlining_8cpp_source.html#l00229">229</a> of file <a class="el" href="LLVMInlining_8cpp_source.html">LLVMInlining.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="LLVMInlining_8cpp_source.html#l00208">getUnderlyingObject()</a>, <a class="el" href="Block_8h_source.html#l00226">mlir::Block::pred_begin()</a>, and <a class="el" href="Block_8h_source.html#l00229">mlir::Block::pred_end()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LLVMInlining_8cpp_source.html#l00291">createNewAliasScopesFromNoAliasParameter()</a>.</p>

</div>
</div>
<a id="a4f6ea1ee5201914c6d4d3e4c5d14cdec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f6ea1ee5201914c6d4d3e4c5d14cdec">&#9670;&nbsp;</a></span>handleAccessGroups()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void handleAccessGroups </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>call</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="classmlir_1_1Region.html#ace0e74dc2b54e7d7cd5406e9008306f9">Region::iterator</a> &gt;&#160;</td>
          <td class="paramname"><em>inlinedBlocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends any access groups of the call operation to any inlined memory operation. </p>

<p class="definition">Definition at line <a class="el" href="LLVMInlining_8cpp_source.html#l00477">477</a> of file <a class="el" href="LLVMInlining_8cpp_source.html">LLVMInlining.cpp</a>.</p>

<p class="reference">References <a class="el" href="LLVMInlining_8cpp_source.html#l00192">concatArrayAttr()</a>.</p>

</div>
</div>
<a id="a773fa72ae1f6a45dd93cf207e16533cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a773fa72ae1f6a45dd93cf207e16533cb">&#9670;&nbsp;</a></span>handleAliasScopes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void handleAliasScopes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>call</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="classmlir_1_1Region.html#ace0e74dc2b54e7d7cd5406e9008306f9">Region::iterator</a> &gt;&#160;</td>
          <td class="paramname"><em>inlinedBlocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles all interactions with alias scopes during inlining. </p>

<p class="definition">Definition at line <a class="el" href="LLVMInlining_8cpp_source.html#l00468">468</a> of file <a class="el" href="LLVMInlining_8cpp_source.html">LLVMInlining.cpp</a>.</p>

<p class="reference">References <a class="el" href="LLVMInlining_8cpp_source.html#l00439">appendCallOpAliasScopes()</a>, <a class="el" href="LLVMInlining_8cpp_source.html#l00291">createNewAliasScopesFromNoAliasParameter()</a>, and <a class="el" href="LLVMInlining_8cpp_source.html#l00133">deepCloneAliasScopes()</a>.</p>

</div>
</div>
<a id="a6f9d04286f30c15124be2265cfa239c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f9d04286f30c15124be2265cfa239c8">&#9670;&nbsp;</a></span>handleByValArgument()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1Value.html">Value</a> handleByValArgument </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>callable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>argument</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>elementType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>requestedAlignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles a function argument marked with the byval attribute by introducing a memcpy or realigning the defining operation, if required either due to the pointee being writeable in the callee, and/or due to an alignment mismatch. </p>
<p><code>requestedAlignment</code> specifies the alignment set in the "align" argument attribute (or 1 if no align attribute was set). </p>

<p class="definition">Definition at line <a class="el" href="LLVMInlining_8cpp_source.html#l00588">588</a> of file <a class="el" href="LLVMInlining_8cpp_source.html">LLVMInlining.cpp</a>.</p>

<p class="reference">References <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00401">mlir::DataLayout::closest()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00473">mlir::DataLayout::getTypeABIAlignment()</a>, <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00449">mlir::DataLayout::getTypeSize()</a>, <a class="el" href="LLVMInlining_8cpp_source.html#l00558">handleByValArgumentInit()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00201">max()</a>, and <a class="el" href="LLVMInlining_8cpp_source.html#l00528">tryToEnforceAlignment()</a>.</p>

</div>
</div>
<a id="adc746a881ef7cc35ee79a563b79d15f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc746a881ef7cc35ee79a563b79d15f9">&#9670;&nbsp;</a></span>handleByValArgumentInit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1Value.html">Value</a> handleByValArgumentInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>argument</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>elementType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>elementTypeSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>targetAlignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Introduces a new alloca and copies the memory pointed to by <code>argument</code> to the address of the new alloca, then returns the value of the new alloca. </p>

<p class="definition">Definition at line <a class="el" href="LLVMInlining_8cpp_source.html#l00558">558</a> of file <a class="el" href="LLVMInlining_8cpp_source.html">LLVMInlining.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8h_source.html#l00055">mlir::Region::begin()</a>, <a class="el" href="Builders_8cpp_source.html#l00446">mlir::OpBuilder::create()</a>, <a class="el" href="Builders_8cpp_source.html#l00128">mlir::Builder::getI64IntegerAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00085">mlir::Builder::getI64Type()</a>, <a class="el" href="Value_8cpp_source.html#l00041">mlir::Value::getParentRegion()</a>, <a class="el" href="Value_8h_source.html#l00125">mlir::Value::getType()</a>, and <a class="el" href="Builders_8h_source.html#l00416">mlir::OpBuilder::setInsertionPointToStart()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LLVMInlining_8cpp_source.html#l00588">handleByValArgument()</a>.</p>

</div>
</div>
<a id="aff1e0bb11c4fb9a8905b2bacb6b79688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff1e0bb11c4fb9a8905b2bacb6b79688">&#9670;&nbsp;</a></span>handleInlinedAllocas()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void handleInlinedAllocas </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>call</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="classmlir_1_1Region.html#ace0e74dc2b54e7d7cd5406e9008306f9">Region::iterator</a> &gt;&#160;</td>
          <td class="paramname"><em>inlinedBlocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles alloca operations in the inlined blocks: </p>
<ul>
<li>Moves all alloca operations with a constant size in the former entry block of the callee into the entry block of the caller, so they become part of the function prologue/epilogue during code generation.</li>
<li>Inserts lifetime intrinsics that limit the scope of inlined static allocas to the inlined blocks.</li>
<li>Inserts StackSave and StackRestore operations if dynamic allocas were inlined. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="LLVMInlining_8cpp_source.html#l00051">51</a> of file <a class="el" href="LLVMInlining_8cpp_source.html">LLVMInlining.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8h_source.html#l00136">mlir::Block::begin()</a>, <a class="el" href="IR_2Region_8h_source.html#l00055">mlir::Region::begin()</a>, <a class="el" href="Builders_8cpp_source.html#l00446">mlir::OpBuilder::create()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00510">mlir::get()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00216">mlir::Operation::getContext()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00223">mlir::Operation::getLoc()</a>, <a class="el" href="Block_8h_source.html#l00186">mlir::Block::getOps()</a>, <a class="el" href="Block_8cpp_source.html#l00026">mlir::Block::getParent()</a>, <a class="el" href="LLVMInlining_8cpp_source.html#l00029">hasLifetimeMarkers()</a>, <a class="el" href="Matchers_8h_source.html#l00310">mlir::m_Constant()</a>, <a class="el" href="Matchers_8h_source.html#l00401">mlir::matchPattern()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00568">mlir::Operation::moveAfter()</a>, and <a class="el" href="Builders_8h_source.html#l00383">mlir::OpBuilder::setInsertionPoint()</a>.</p>

</div>
</div>
<a id="a0d9f07cb870d6fca954bcd17a8e28c67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d9f07cb870d6fca954bcd17a8e28c67">&#9670;&nbsp;</a></span>hasLifetimeMarkers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool hasLifetimeMarkers </td>
          <td>(</td>
          <td class="paramtype">LLVM::AllocaOp&#160;</td>
          <td class="paramname"><em>allocaOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether the given alloca is an input to a lifetime intrinsic, optionally passing through one or more casts on the way. </p>
<p>This is not transitive through block arguments. </p>

<p class="definition">Definition at line <a class="el" href="LLVMInlining_8cpp_source.html#l00029">29</a> of file <a class="el" href="LLVMInlining_8cpp_source.html">LLVMInlining.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LLVMInlining_8cpp_source.html#l00051">handleInlinedAllocas()</a>.</p>

</div>
</div>
<a id="aaffb480be7672f67c36736e62f8e3210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaffb480be7672f67c36736e62f8e3210">&#9670;&nbsp;</a></span>tryToEnforceAlignment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t tryToEnforceAlignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>requestedAlignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> const &amp;&#160;</td>
          <td class="paramname"><em>dataLayout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to find and return the alignment of the pointer <code>value</code> by looking for an alignment attribute on the defining allocation op or function argument. </p>
<p>If the found alignment is lower than <code>requestedAlignment</code>, tries to realign the pointer, then returns the resulting post-alignment, regardless of whether it was realigned or not. If no existing alignment attribute is found, returns 1 (i.e., assume that no alignment is guaranteed). </p>

<p class="definition">Definition at line <a class="el" href="LLVMInlining_8cpp_source.html#l00528">528</a> of file <a class="el" href="LLVMInlining_8cpp_source.html">LLVMInlining.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="Value_8cpp_source.html#l00048">mlir::Value::getParentBlock()</a>, <a class="el" href="Block_8cpp_source.html#l00030">mlir::Block::getParentOp()</a>, and <a class="el" href="LLVMInlining_8cpp_source.html#l00499">tryToEnforceAllocaAlignment()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LLVMInlining_8cpp_source.html#l00588">handleByValArgument()</a>.</p>

</div>
</div>
<a id="a8f49eadb6ca15f24813d6902d151395e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f49eadb6ca15f24813d6902d151395e">&#9670;&nbsp;</a></span>tryToEnforceAllocaAlignment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t tryToEnforceAllocaAlignment </td>
          <td>(</td>
          <td class="paramtype">LLVM::AllocaOp&#160;</td>
          <td class="paramname"><em>alloca</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>requestedAlignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> const &amp;&#160;</td>
          <td class="paramname"><em>dataLayout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If <code>requestedAlignment</code> is higher than the alignment specified on <code>alloca</code>, realigns <code>alloca</code> if this does not exceed the natural stack alignment. </p>
<p>Returns the post-alignment of <code>alloca</code>, whether it was realigned or not. </p>

<p class="definition">Definition at line <a class="el" href="LLVMInlining_8cpp_source.html#l00499">499</a> of file <a class="el" href="LLVMInlining_8cpp_source.html">LLVMInlining.cpp</a>.</p>

<p class="reference">References <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00513">mlir::DataLayout::getStackAlignment()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LLVMInlining_8cpp_source.html#l00528">tryToEnforceAlignment()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Dec 9 2023 02:40:34 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
