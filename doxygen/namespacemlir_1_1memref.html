<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::memref Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">18.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1memref.html">memref</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mlir::memref Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1memref_1_1LinearizedMemRefInfo.html">LinearizedMemRefInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a <code>memref</code> with <code>offset</code>, <code>sizes</code> and <code>strides</code>, returns the offset and size to use for the linearized <code>memref</code>.  <a href="structmlir_1_1memref_1_1LinearizedMemRefInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa6d03c4cab7fc5604ab8b5d105b31d4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#aa6d03c4cab7fc5604ab8b5d105b31d4b">foldMemRefCast</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1Value.html">Value</a> inner=nullptr)</td></tr>
<tr class="memdesc:aa6d03c4cab7fc5604ab8b5d105b31d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a common utility used for patterns of the form "someop(memref.cast) -&gt; someop".  <a href="namespacemlir_1_1memref.html#aa6d03c4cab7fc5604ab8b5d105b31d4b">More...</a><br /></td></tr>
<tr class="separator:aa6d03c4cab7fc5604ab8b5d105b31d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a593c42d0eefa6f2456d3ed618384de85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a593c42d0eefa6f2456d3ed618384de85">getTensorTypeFromMemRefType</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type)</td></tr>
<tr class="memdesc:a593c42d0eefa6f2456d3ed618384de85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an unranked/ranked tensor type for the given unranked/ranked memref type.  <a href="namespacemlir_1_1memref.html#a593c42d0eefa6f2456d3ed618384de85">More...</a><br /></td></tr>
<tr class="separator:a593c42d0eefa6f2456d3ed618384de85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb87b9964b1655bdedbdd1b7656225d"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a7bb87b9964b1655bdedbdd1b7656225d">findDealloc</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> allocValue)</td></tr>
<tr class="memdesc:a7bb87b9964b1655bdedbdd1b7656225d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a single dealloc operation for the given allocated value.  <a href="namespacemlir_1_1memref.html#a7bb87b9964b1655bdedbdd1b7656225d">More...</a><br /></td></tr>
<tr class="separator:a7bb87b9964b1655bdedbdd1b7656225d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a881164870086f3048d50a9ff9cd702"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a5a881164870086f3048d50a9ff9cd702">getMixedSize</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> value, int64_t dim)</td></tr>
<tr class="memdesc:a5a881164870086f3048d50a9ff9cd702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the dimension of the given memref value.  <a href="namespacemlir_1_1memref.html#a5a881164870086f3048d50a9ff9cd702">More...</a><br /></td></tr>
<tr class="separator:a5a881164870086f3048d50a9ff9cd702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c13e32e47a301b4ccac4b27404de51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#ab0c13e32e47a301b4ccac4b27404de51">getMixedSizes</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="memdesc:ab0c13e32e47a301b4ccac4b27404de51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the dimensions of the given memref value.  <a href="namespacemlir_1_1memref.html#ab0c13e32e47a301b4ccac4b27404de51">More...</a><br /></td></tr>
<tr class="separator:ab0c13e32e47a301b4ccac4b27404de51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e796656fc119467035c6e1d1568a59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#ae1e796656fc119467035c6e1d1568a59">createCanonicalRankReducingSubViewOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> memref, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; targetShape)</td></tr>
<tr class="memdesc:ae1e796656fc119467035c6e1d1568a59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a rank-reducing SubViewOp @[0 .  <a href="namespacemlir_1_1memref.html#ae1e796656fc119467035c6e1d1568a59">More...</a><br /></td></tr>
<tr class="separator:ae1e796656fc119467035c6e1d1568a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08647ff099a98052f95e4caff149a2f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a08647ff099a98052f95e4caff149a2f9">registerMemorySlotExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:a08647ff099a98052f95e4caff149a2f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b49994f10e98cb119abfb38f23c0c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#ac2b49994f10e98cb119abfb38f23c0c3">registerValueBoundsOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:ac2b49994f10e98cb119abfb38f23c0c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1adc6a8d5aefc17867d0815b586c3b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#ae1adc6a8d5aefc17867d0815b586c3b9">registerTransformDialectExtension</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:ae1adc6a8d5aefc17867d0815b586c3b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1883b3342d764a07311e3f8a79d8dd1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a1883b3342d764a07311e3f8a79d8dd1e">registerAllocationOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:a1883b3342d764a07311e3f8a79d8dd1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c5916519d8d818c95097ef22e882ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#af6c5916519d8d818c95097ef22e882ee">populateComposeSubViewPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="separator:af6c5916519d8d818c95097ef22e882ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e1c2ec5fd808a4c161c3e3757dcb2ac"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a9e1c2ec5fd808a4c161c3e3757dcb2ac">createExpandOpsPass</a> ()</td></tr>
<tr class="memdesc:a9e1c2ec5fd808a4c161c3e3757dcb2ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of the ExpandOps pass that legalizes memref dialect ops to be convertible to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <a href="namespacemlir_1_1memref.html#a9e1c2ec5fd808a4c161c3e3757dcb2ac">More...</a><br /></td></tr>
<tr class="separator:a9e1c2ec5fd808a4c161c3e3757dcb2ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02615680489f37f7981015da17f6ae01"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a02615680489f37f7981015da17f6ae01">createFoldMemRefAliasOpsPass</a> ()</td></tr>
<tr class="memdesc:a02615680489f37f7981015da17f6ae01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an operation pass to fold memref aliasing ops into consumer load/store ops into <code>patterns</code>.  <a href="namespacemlir_1_1memref.html#a02615680489f37f7981015da17f6ae01">More...</a><br /></td></tr>
<tr class="separator:a02615680489f37f7981015da17f6ae01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f45f2e0d1a2210dfe96f673be3b0e7"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a83f45f2e0d1a2210dfe96f673be3b0e7">createNormalizeMemRefsPass</a> ()</td></tr>
<tr class="memdesc:a83f45f2e0d1a2210dfe96f673be3b0e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an interprocedural pass to normalize memrefs to have a trivial (identity) layout map.  <a href="namespacemlir_1_1memref.html#a83f45f2e0d1a2210dfe96f673be3b0e7">More...</a><br /></td></tr>
<tr class="separator:a83f45f2e0d1a2210dfe96f673be3b0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731ed7504adb7700dcb4c013edd90444"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a731ed7504adb7700dcb4c013edd90444">createResolveRankedShapeTypeResultDimsPass</a> ()</td></tr>
<tr class="memdesc:a731ed7504adb7700dcb4c013edd90444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an operation pass to resolve <code>memref.dim</code> operations with values that are defined by operations that implement the <code>ReifyRankedShapedTypeOpInterface</code>, in terms of shapes of its input operands.  <a href="namespacemlir_1_1memref.html#a731ed7504adb7700dcb4c013edd90444">More...</a><br /></td></tr>
<tr class="separator:a731ed7504adb7700dcb4c013edd90444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125072690f2eaadee614b98605a1a852"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a125072690f2eaadee614b98605a1a852">createResolveShapedTypeResultDimsPass</a> ()</td></tr>
<tr class="memdesc:a125072690f2eaadee614b98605a1a852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an operation pass to resolve <code>memref.dim</code> operations with values that are defined by operations that implement the <code>InferShapedTypeOpInterface</code> or the <code>ReifyRankedShapedTypeOpInterface</code>, in terms of shapes of its input operands.  <a href="namespacemlir_1_1memref.html#a125072690f2eaadee614b98605a1a852">More...</a><br /></td></tr>
<tr class="separator:a125072690f2eaadee614b98605a1a852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c684ef24bae57bc6ac31147475bd5df"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a3c684ef24bae57bc6ac31147475bd5df">createExpandStridedMetadataPass</a> ()</td></tr>
<tr class="memdesc:a3c684ef24bae57bc6ac31147475bd5df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an operation pass to expand some memref operation into easier to reason about operations.  <a href="namespacemlir_1_1memref.html#a3c684ef24bae57bc6ac31147475bd5df">More...</a><br /></td></tr>
<tr class="separator:a3c684ef24bae57bc6ac31147475bd5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bbda8863ab084d1a44a077d4c108f8e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a4bbda8863ab084d1a44a077d4c108f8e">createExpandReallocPass</a> (bool emitDeallocs=true)</td></tr>
<tr class="memdesc:a4bbda8863ab084d1a44a077d4c108f8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an operation pass to expand <code>memref.realloc</code> operations into their components.  <a href="namespacemlir_1_1memref.html#a4bbda8863ab084d1a44a077d4c108f8e">More...</a><br /></td></tr>
<tr class="separator:a4bbda8863ab084d1a44a077d4c108f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7fa7b00c1ccb23e5f4a528377dd4ee9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#ad7fa7b00c1ccb23e5f4a528377dd4ee9">registerRuntimeVerifiableOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:ad7fa7b00c1ccb23e5f4a528377dd4ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa72dbb57f66b3381ca288a092d376802"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#aa72dbb57f66b3381ca288a092d376802">populateExpandOpsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:aa72dbb57f66b3381ca288a092d376802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects a set of patterns to rewrite ops within the memref dialect.  <a href="namespacemlir_1_1memref.html#aa72dbb57f66b3381ca288a092d376802">More...</a><br /></td></tr>
<tr class="separator:aa72dbb57f66b3381ca288a092d376802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b92ea4d1067ac456aa6899baa8512a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a0b92ea4d1067ac456aa6899baa8512a9">populateFoldMemRefAliasOpPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a0b92ea4d1067ac456aa6899baa8512a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns for folding memref aliasing ops into consumer load/store ops into <code>patterns</code>.  <a href="namespacemlir_1_1memref.html#a0b92ea4d1067ac456aa6899baa8512a9">More...</a><br /></td></tr>
<tr class="separator:a0b92ea4d1067ac456aa6899baa8512a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313c2f5f760c17a276fac9bb108951c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a313c2f5f760c17a276fac9bb108951c9">populateResolveRankedShapedTypeResultDimsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a313c2f5f760c17a276fac9bb108951c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns that resolve <code>memref.dim</code> operations with values that are defined by operations that implement the <code>ReifyRankedShapedTypeOpInterface</code>, in terms of shapes of its input operands.  <a href="namespacemlir_1_1memref.html#a313c2f5f760c17a276fac9bb108951c9">More...</a><br /></td></tr>
<tr class="separator:a313c2f5f760c17a276fac9bb108951c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf97a8143d457b645153d6f40e6aed84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#aaf97a8143d457b645153d6f40e6aed84">populateResolveShapedTypeResultDimsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:aaf97a8143d457b645153d6f40e6aed84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns that resolve <code>memref.dim</code> operations with values that are defined by operations that implement the <code>InferShapedTypeOpInterface</code>, in terms of shapes of its input operands.  <a href="namespacemlir_1_1memref.html#aaf97a8143d457b645153d6f40e6aed84">More...</a><br /></td></tr>
<tr class="separator:aaf97a8143d457b645153d6f40e6aed84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a91532e484d6485dc36756f1b1bace"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#ae0a91532e484d6485dc36756f1b1bace">populateExpandStridedMetadataPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:ae0a91532e484d6485dc36756f1b1bace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns for expanding memref operations that modify the metadata (sizes, offset, strides) of a memref into easier to analyze constructs.  <a href="namespacemlir_1_1memref.html#ae0a91532e484d6485dc36756f1b1bace">More...</a><br /></td></tr>
<tr class="separator:ae0a91532e484d6485dc36756f1b1bace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a933e3cb75cf93999afc61710776fea07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a933e3cb75cf93999afc61710776fea07">populateResolveExtractStridedMetadataPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a933e3cb75cf93999afc61710776fea07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns for resolving <code>memref.extract_strided_metadata</code> into <code>memref.extract_strided_metadata</code> of its source.  <a href="namespacemlir_1_1memref.html#a933e3cb75cf93999afc61710776fea07">More...</a><br /></td></tr>
<tr class="separator:a933e3cb75cf93999afc61710776fea07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b5486ce1776bc5afddb8ec9cc97f2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#ad3b5486ce1776bc5afddb8ec9cc97f2a">populateExpandReallocPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, bool emitDeallocs=true)</td></tr>
<tr class="memdesc:ad3b5486ce1776bc5afddb8ec9cc97f2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns for expanding <code>memref.realloc</code> operations.  <a href="namespacemlir_1_1memref.html#ad3b5486ce1776bc5afddb8ec9cc97f2a">More...</a><br /></td></tr>
<tr class="separator:ad3b5486ce1776bc5afddb8ec9cc97f2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51da475db04d0e27ef4a0a8f10c0c518"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a51da475db04d0e27ef4a0a8f10c0c518">populateMemRefWideIntEmulationPatterns</a> (<a class="el" href="classmlir_1_1arith_1_1WideIntEmulationConverter.html">arith::WideIntEmulationConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a51da475db04d0e27ef4a0a8f10c0c518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns for emulating wide integer memref operations with ops over narrower integer types.  <a href="namespacemlir_1_1memref.html#a51da475db04d0e27ef4a0a8f10c0c518">More...</a><br /></td></tr>
<tr class="separator:a51da475db04d0e27ef4a0a8f10c0c518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0e1bd45d93d6da7bf22b61465492b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a6c0e1bd45d93d6da7bf22b61465492b9">populateMemRefWideIntEmulationConversions</a> (<a class="el" href="classmlir_1_1arith_1_1WideIntEmulationConverter.html">arith::WideIntEmulationConverter</a> &amp;typeConverter)</td></tr>
<tr class="memdesc:a6c0e1bd45d93d6da7bf22b61465492b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends type conversions for emulating wide integer memref operations with ops over narrowe integer types.  <a href="namespacemlir_1_1memref.html#a6c0e1bd45d93d6da7bf22b61465492b9">More...</a><br /></td></tr>
<tr class="separator:a6c0e1bd45d93d6da7bf22b61465492b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf715704c6996833ff9d152a4aafe42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a1bf715704c6996833ff9d152a4aafe42">populateMemRefNarrowTypeEmulationPatterns</a> (<a class="el" href="classmlir_1_1arith_1_1NarrowTypeEmulationConverter.html">arith::NarrowTypeEmulationConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a1bf715704c6996833ff9d152a4aafe42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns for emulating memref operations over narrow types with ops over wider types.  <a href="namespacemlir_1_1memref.html#a1bf715704c6996833ff9d152a4aafe42">More...</a><br /></td></tr>
<tr class="separator:a1bf715704c6996833ff9d152a4aafe42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5416c0ea0d3dcf0c0ce09270c16bb4c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a5416c0ea0d3dcf0c0ce09270c16bb4c7">populateMemRefNarrowTypeEmulationConversions</a> (<a class="el" href="classmlir_1_1arith_1_1NarrowTypeEmulationConverter.html">arith::NarrowTypeEmulationConverter</a> &amp;typeConverter)</td></tr>
<tr class="memdesc:a5416c0ea0d3dcf0c0ce09270c16bb4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends type conversions for emulating memref operations over narrow types with ops over wider types.  <a href="namespacemlir_1_1memref.html#a5416c0ea0d3dcf0c0ce09270c16bb4c7">More...</a><br /></td></tr>
<tr class="separator:a5416c0ea0d3dcf0c0ce09270c16bb4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a637539fbb3044706f07e949413eac30d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; memref::AllocOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a637539fbb3044706f07e949413eac30d">multiBuffer</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, memref::AllocOp allocOp, unsigned multiplier, bool skipOverrideAnalysis=false)</td></tr>
<tr class="memdesc:a637539fbb3044706f07e949413eac30d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation to do multi-buffering/array expansion to remove dependencies on the temporary allocation between consecutive loop iterations.  <a href="namespacemlir_1_1memref.html#a637539fbb3044706f07e949413eac30d">More...</a><br /></td></tr>
<tr class="separator:a637539fbb3044706f07e949413eac30d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ffe31231e4fd88511f0d2446b4218d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; memref::AllocOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#ae4ffe31231e4fd88511f0d2446b4218d">multiBuffer</a> (memref::AllocOp allocOp, unsigned multiplier, bool skipOverrideAnalysis=false)</td></tr>
<tr class="memdesc:ae4ffe31231e4fd88511f0d2446b4218d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call into <code>multiBuffer</code> with locally constructed <a class="el" href="classmlir_1_1IRRewriter.html" title="This class coordinates rewriting a piece of IR outside of a pattern rewrite, providing a way to keep ...">IRRewriter</a>.  <a href="namespacemlir_1_1memref.html#ae4ffe31231e4fd88511f0d2446b4218d">More...</a><br /></td></tr>
<tr class="separator:ae4ffe31231e4fd88511f0d2446b4218d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05667d80ad6b23301f24c722a4dbb28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#ad05667d80ad6b23301f24c722a4dbb28">populateExtractAddressComputationsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:ad05667d80ad6b23301f24c722a4dbb28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends patterns for extracting address computations from the instructions with memory accesses such that these memory accesses use only a base pointer.  <a href="namespacemlir_1_1memref.html#ad05667d80ad6b23301f24c722a4dbb28">More...</a><br /></td></tr>
<tr class="separator:ad05667d80ad6b23301f24c722a4dbb28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf86c211b0ab9ea0b1ea4943a4e6d6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a1bf86c211b0ab9ea0b1ea4943a4e6d6e">buildIndependentOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, AllocaOp allocaOp, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> independencies)</td></tr>
<tr class="memdesc:a1bf86c211b0ab9ea0b1ea4943a4e6d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a new memref::AllocaOp whose dynamic sizes are independent of all given independencies.  <a href="namespacemlir_1_1memref.html#a1bf86c211b0ab9ea0b1ea4943a4e6d6e">More...</a><br /></td></tr>
<tr class="separator:a1bf86c211b0ab9ea0b1ea4943a4e6d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390d7b6bfa73372eec5b1d2cd2bf937b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a390d7b6bfa73372eec5b1d2cd2bf937b">replaceWithIndependentOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, memref::AllocaOp allocaOp, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> independencies)</td></tr>
<tr class="memdesc:a390d7b6bfa73372eec5b1d2cd2bf937b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a new memref::AllocaOp whose dynamic sizes are independent of all given independencies.  <a href="namespacemlir_1_1memref.html#a390d7b6bfa73372eec5b1d2cd2bf937b">More...</a><br /></td></tr>
<tr class="separator:a390d7b6bfa73372eec5b1d2cd2bf937b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3bb58d33cedbbc97322a912c2c67971"><td class="memItemLeft" align="right" valign="top">memref::AllocaOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#ad3bb58d33cedbbc97322a912c2c67971">allocToAlloca</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, memref::AllocOp alloc, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(memref::AllocOp, memref::DeallocOp)&gt; filter=nullptr)</td></tr>
<tr class="memdesc:ad3bb58d33cedbbc97322a912c2c67971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the given <code>alloc</code> with the corresponding <code>alloca</code> and returns it if the following conditions are met:  <a href="namespacemlir_1_1memref.html#ad3bb58d33cedbbc97322a912c2c67971">More...</a><br /></td></tr>
<tr class="separator:ad3bb58d33cedbbc97322a912c2c67971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd556718fd72c7099dc94f99d30ccd1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a6dd556718fd72c7099dc94f99d30ccd1">isStaticShapeAndContiguousRowMajor</a> (MemRefType type)</td></tr>
<tr class="memdesc:a6dd556718fd72c7099dc94f99d30ccd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true, if the memref type has static shapes and represents a contiguous chunk of memory.  <a href="namespacemlir_1_1memref.html#a6dd556718fd72c7099dc94f99d30ccd1">More...</a><br /></td></tr>
<tr class="separator:a6dd556718fd72c7099dc94f99d30ccd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e822c5ce40c4b3815acd8657d6c8c3"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structmlir_1_1memref_1_1LinearizedMemRefInfo.html">LinearizedMemRefInfo</a>, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a68e822c5ce40c4b3815acd8657d6c8c3">getLinearizedMemRefOffsetAndSize</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, int srcBits, int dstBits, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> offset, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; sizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; strides, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; indices={})</td></tr>
<tr class="separator:a68e822c5ce40c4b3815acd8657d6c8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec5fa6d6d4ab684b9a5ff4ef7e668b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1memref_1_1LinearizedMemRefInfo.html">LinearizedMemRefInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a0ec5fa6d6d4ab684b9a5ff4ef7e668b6">getLinearizedMemRefOffsetAndSize</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, int srcBits, int dstBits, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> offset, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; sizes)</td></tr>
<tr class="memdesc:a0ec5fa6d6d4ab684b9a5ff4ef7e668b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a <code>memref</code> with <code>offset</code> and <code>sizes</code>, returns the offset and size to use for the linearized <code>memref</code>, assuming that the strides are computed from a row-major ordering of the sizes;.  <a href="namespacemlir_1_1memref.html#a0ec5fa6d6d4ab684b9a5ff4ef7e668b6">More...</a><br /></td></tr>
<tr class="separator:a0ec5fa6d6d4ab684b9a5ff4ef7e668b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4147c59f3a9e3d7d845d27760a8b565b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a4147c59f3a9e3d7d845d27760a8b565b">eraseDeadAllocAndStores</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *parentOp)</td></tr>
<tr class="separator:a4147c59f3a9e3d7d845d27760a8b565b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c2b990b3c696031cd589f1859416013"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1memref.html#a1c2b990b3c696031cd589f1859416013">resultIsNotRead</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, std::vector&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;uses)</td></tr>
<tr class="memdesc:a1c2b990b3c696031cd589f1859416013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all the uses of op are not read/load.  <a href="namespacemlir_1_1memref.html#a1c2b990b3c696031cd589f1859416013">More...</a><br /></td></tr>
<tr class="separator:a1c2b990b3c696031cd589f1859416013"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ad3bb58d33cedbbc97322a912c2c67971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3bb58d33cedbbc97322a912c2c67971">&#9670;&nbsp;</a></span>allocToAlloca()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">memref::AllocaOp mlir::memref::allocToAlloca </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memref::AllocOp&#160;</td>
          <td class="paramname"><em>alloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; bool(memref::AllocOp, memref::DeallocOp)&gt;&#160;</td>
          <td class="paramname"><em>filter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the given <code>alloc</code> with the corresponding <code>alloca</code> and returns it if the following conditions are met: </p>
<ul>
<li>the corresponding dealloc is available in the same block as the alloc;</li>
<li>the filter, if provided, succeeds on the alloc/dealloc pair. Otherwise returns nullptr and leaves the IR unchanged. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="MemRef_2Transforms_2IndependenceTransforms_8cpp_source.html#l00182">182</a> of file <a class="el" href="MemRef_2Transforms_2IndependenceTransforms_8cpp_source.html">IndependenceTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8cpp_source.html#l00306">mlir::RewriterBase::eraseOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l00539">mlir::RewriterBase::replaceOpWithNewOp()</a>, and <a class="el" href="Builders_8h_source.html#l00383">mlir::OpBuilder::setInsertionPoint()</a>.</p>

</div>
</div>
<a id="a1bf86c211b0ab9ea0b1ea4943a4e6d6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bf86c211b0ab9ea0b1ea4943a4e6d6e">&#9670;&nbsp;</a></span>buildIndependentOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; mlir::memref::buildIndependentOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AllocaOp&#160;</td>
          <td class="paramname"><em>allocaOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>independencies</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a new memref::AllocaOp whose dynamic sizes are independent of all given independencies. </p>
<p>If the op is already independent of all independencies, the same AllocaOp result is returned.</p>
<p>Failure indicates the no suitable upper bound for the dynamic sizes could be found. </p>

<p class="reference">Referenced by <a class="el" href="MemRef_2Transforms_2IndependenceTransforms_8cpp_source.html#l00170">replaceWithIndependentOp()</a>.</p>

</div>
</div>
<a id="ae1e796656fc119467035c6e1d1568a59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1e796656fc119467035c6e1d1568a59">&#9670;&nbsp;</a></span>createCanonicalRankReducingSubViewOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::memref::createCanonicalRankReducingSubViewOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>memref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>targetShape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a rank-reducing SubViewOp @[0 . </p>
<p>. 0] with strides [1 .. 1] and appropriate sizes (i.e. <code>memref.getSizes()</code>) to reduce the rank of <code>memref</code> to that of <code>targetShape</code>. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l02911">2911</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00505">mlir::OpBuilder::createOrFold()</a>, <a class="el" href="Builders_8cpp_source.html#l00124">mlir::Builder::getIndexAttr()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00077">getMixedSizes()</a>, and <a class="el" href="Value_8h_source.html#l00125">mlir::Value::getType()</a>.</p>

</div>
</div>
<a id="a9e1c2ec5fd808a4c161c3e3757dcb2ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e1c2ec5fd808a4c161c3e3757dcb2ac">&#9670;&nbsp;</a></span>createExpandOpsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::memref::createExpandOpsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of the ExpandOps pass that legalizes memref dialect ops to be convertible to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>
<p>For example, <code>memref.reshape</code> gets converted to <code>memref_reinterpret_cast</code>. </p>

<p class="definition">Definition at line <a class="el" href="MemRef_2Transforms_2ExpandOps_8cpp_source.html#l00151">151</a> of file <a class="el" href="MemRef_2Transforms_2ExpandOps_8cpp_source.html">ExpandOps.cpp</a>.</p>

</div>
</div>
<a id="a4bbda8863ab084d1a44a077d4c108f8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bbda8863ab084d1a44a077d4c108f8e">&#9670;&nbsp;</a></span>createExpandReallocPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::memref::createExpandReallocPass </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>emitDeallocs</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an operation pass to expand <code>memref.realloc</code> operations into their components. </p>

<p class="definition">Definition at line <a class="el" href="ExpandRealloc_8cpp_source.html#l00173">173</a> of file <a class="el" href="ExpandRealloc_8cpp_source.html">ExpandRealloc.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="BufferizationPipelines_8cpp_source.html#l00021">mlir::bufferization::buildBufferDeallocationPipeline()</a>, and <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00032">mlir::sparse_tensor::buildSparsifier()</a>.</p>

</div>
</div>
<a id="a3c684ef24bae57bc6ac31147475bd5df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c684ef24bae57bc6ac31147475bd5df">&#9670;&nbsp;</a></span>createExpandStridedMetadataPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::memref::createExpandStridedMetadataPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an operation pass to expand some memref operation into easier to reason about operations. </p>

<p class="definition">Definition at line <a class="el" href="ExpandStridedMetadata_8cpp_source.html#l01038">1038</a> of file <a class="el" href="ExpandStridedMetadata_8cpp_source.html">ExpandStridedMetadata.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00032">mlir::sparse_tensor::buildSparsifier()</a>.</p>

</div>
</div>
<a id="a02615680489f37f7981015da17f6ae01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02615680489f37f7981015da17f6ae01">&#9670;&nbsp;</a></span>createFoldMemRefAliasOpsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::memref::createFoldMemRefAliasOpsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an operation pass to fold memref aliasing ops into consumer load/store ops into <code>patterns</code>. </p>

<p class="definition">Definition at line <a class="el" href="FoldMemRefAliasOps_8cpp_source.html#l00748">748</a> of file <a class="el" href="FoldMemRefAliasOps_8cpp_source.html">FoldMemRefAliasOps.cpp</a>.</p>

</div>
</div>
<a id="a83f45f2e0d1a2210dfe96f673be3b0e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83f45f2e0d1a2210dfe96f673be3b0e7">&#9670;&nbsp;</a></span>createNormalizeMemRefsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; mlir::memref::createNormalizeMemRefsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an interprocedural pass to normalize memrefs to have a trivial (identity) layout map. </p>

<p class="definition">Definition at line <a class="el" href="NormalizeMemRefs_8cpp_source.html#l00057">57</a> of file <a class="el" href="NormalizeMemRefs_8cpp_source.html">NormalizeMemRefs.cpp</a>.</p>

</div>
</div>
<a id="a731ed7504adb7700dcb4c013edd90444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a731ed7504adb7700dcb4c013edd90444">&#9670;&nbsp;</a></span>createResolveRankedShapeTypeResultDimsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::memref::createResolveRankedShapeTypeResultDimsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an operation pass to resolve <code>memref.dim</code> operations with values that are defined by operations that implement the <code>ReifyRankedShapedTypeOpInterface</code>, in terms of shapes of its input operands. </p>

<p class="definition">Definition at line <a class="el" href="ResolveShapedTypeResultDims_8cpp_source.html#l00161">161</a> of file <a class="el" href="ResolveShapedTypeResultDims_8cpp_source.html">ResolveShapedTypeResultDims.cpp</a>.</p>

</div>
</div>
<a id="a125072690f2eaadee614b98605a1a852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a125072690f2eaadee614b98605a1a852">&#9670;&nbsp;</a></span>createResolveShapedTypeResultDimsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::memref::createResolveShapedTypeResultDimsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an operation pass to resolve <code>memref.dim</code> operations with values that are defined by operations that implement the <code>InferShapedTypeOpInterface</code> or the <code>ReifyRankedShapedTypeOpInterface</code>, in terms of shapes of its input operands. </p>

<p class="definition">Definition at line <a class="el" href="ResolveShapedTypeResultDims_8cpp_source.html#l00157">157</a> of file <a class="el" href="ResolveShapedTypeResultDims_8cpp_source.html">ResolveShapedTypeResultDims.cpp</a>.</p>

</div>
</div>
<a id="a4147c59f3a9e3d7d845d27760a8b565b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4147c59f3a9e3d7d845d27760a8b565b">&#9670;&nbsp;</a></span>eraseDeadAllocAndStores()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::eraseDeadAllocAndStores </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>parentOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRefUtils_8cpp_source.html#l00145">145</a> of file <a class="el" href="MemRefUtils_8cpp_source.html">MemRefUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00776">mlir::Operation::walk()</a>.</p>

</div>
</div>
<a id="a7bb87b9964b1655bdedbdd1b7656225d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bb87b9964b1655bdedbdd1b7656225d">&#9670;&nbsp;</a></span>findDealloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; mlir::memref::findDealloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>allocValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a single dealloc operation for the given allocated value. </p>
<p>Finds the unique dealloc operation (if one exists) for <code>allocValue</code>.</p>
<p>If there are &gt; 1 deallocates for <code>allocValue</code>, returns std::nullopt, else returns the single deallocate if it exists or nullptr. </p>

<p class="definition">Definition at line <a class="el" href="MemRefDialect_8cpp_source.html#l00047">47</a> of file <a class="el" href="MemRefDialect_8cpp_source.html">MemRefDialect.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00224">mlir::Value::getUsers()</a>.</p>

</div>
</div>
<a id="aa6d03c4cab7fc5604ab8b5d105b31d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6d03c4cab7fc5604ab8b5d105b31d4b">&#9670;&nbsp;</a></span>foldMemRefCast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::memref::foldMemRefCast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>inner</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a common utility used for patterns of the form "someop(memref.cast) -&gt; someop". </p>
<p>This is a common class used for patterns of the form "someop(memrefcast) -&gt; someop".</p>
<p>It folds the source of any memref.cast into the root operation directly. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l00044">44</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l01680">mlir::affine::AffineDmaStartOp::fold()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01770">mlir::affine::AffineDmaWaitOp::fold()</a>.</p>

</div>
</div>
<a id="a0ec5fa6d6d4ab684b9a5ff4ef7e668b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ec5fa6d6d4ab684b9a5ff4ef7e668b6">&#9670;&nbsp;</a></span>getLinearizedMemRefOffsetAndSize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1memref_1_1LinearizedMemRefInfo.html">LinearizedMemRefInfo</a> mlir::memref::getLinearizedMemRefOffsetAndSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dstBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a <code>memref</code> with <code>offset</code> and <code>sizes</code>, returns the offset and size to use for the linearized <code>memref</code>, assuming that the strides are computed from a row-major ordering of the sizes;. </p>
<ul>
<li>If the linearization is done for emulating load/stores of element type with bitwidth <code>srcBits</code> using element type with bitwidth <code>dstBits</code>, the linearized offset and size are scaled down by <code>dstBits</code>/<code>srcBits</code>. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="MemRefUtils_8cpp_source.html#l00102">102</a> of file <a class="el" href="MemRefUtils_8cpp_source.html">MemRefUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00348">mlir::bindSymbols()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, <a class="el" href="Builders_8cpp_source.html#l00124">mlir::Builder::getIndexAttr()</a>, <a class="el" href="MemRefUtils_8cpp_source.html#l00050">getLinearizedMemRefOffsetAndSize()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01172">mlir::affine::makeComposedFoldedAffineApply()</a>.</p>

</div>
</div>
<a id="a68e822c5ce40c4b3815acd8657d6c8c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68e822c5ce40c4b3815acd8657d6c8c3">&#9670;&nbsp;</a></span>getLinearizedMemRefOffsetAndSize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="structmlir_1_1memref_1_1LinearizedMemRefInfo.html">LinearizedMemRefInfo</a>, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::memref::getLinearizedMemRefOffsetAndSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dstBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>strides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>indices</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRefUtils_8cpp_source.html#l00050">50</a> of file <a class="el" href="MemRefUtils_8cpp_source.html">MemRefUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00348">mlir::bindSymbols()</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00353">mlir::bindSymbolsList()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00867">mlir::AffineExpr::floorDiv()</a>, <a class="el" href="Builders_8cpp_source.html#l00361">mlir::Builder::getAffineConstantExpr()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, <a class="el" href="Builders_8cpp_source.html#l00124">mlir::Builder::getIndexAttr()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01172">mlir::affine::makeComposedFoldedAffineApply()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefUtils_8cpp_source.html#l00102">getLinearizedMemRefOffsetAndSize()</a>, and <a class="el" href="MemRef_2Transforms_2EmulateNarrowType_8cpp_source.html#l00150">getLinearizedSrcIndices()</a>.</p>

</div>
</div>
<a id="a5a881164870086f3048d50a9ff9cd702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a881164870086f3048d50a9ff9cd702">&#9670;&nbsp;</a></span>getMixedSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> mlir::memref::getMixedSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the dimension of the given memref value. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l00067">67</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00505">mlir::OpBuilder::createOrFold()</a>, <a class="el" href="Builders_8cpp_source.html#l00124">mlir::Builder::getIndexAttr()</a>, and <a class="el" href="Value_8h_source.html#l00125">mlir::Value::getType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00043">createInBoundsCond()</a>, and <a class="el" href="MemRefOps_8cpp_source.html#l00077">getMixedSizes()</a>.</p>

</div>
</div>
<a id="ab0c13e32e47a301b4ccac4b27404de51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0c13e32e47a301b4ccac4b27404de51">&#9670;&nbsp;</a></span>getMixedSizes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::memref::getMixedSizes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the dimensions of the given memref value. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l00077">77</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="MemRefOps_8cpp_source.html#l00067">getMixedSize()</a>, and <a class="el" href="Value_8h_source.html#l00125">mlir::Value::getType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="NVGPUTransformOps_8cpp_source.html#l00946">HopperBuilder::buildGlobalMemRefDescriptor()</a>, <a class="el" href="NVGPUTransformOps_8cpp_source.html#l00974">HopperBuilder::buildTmaAsyncLoad()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l02911">createCanonicalRankReducingSubViewOp()</a>, and <a class="el" href="VectorTransferOpTransforms_8cpp_source.html#l00293">rankReducingSubviewDroppingUnitDims()</a>.</p>

</div>
</div>
<a id="a593c42d0eefa6f2456d3ed618384de85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a593c42d0eefa6f2456d3ed618384de85">&#9670;&nbsp;</a></span>getTensorTypeFromMemRefType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> mlir::memref::getTensorTypeFromMemRefType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an unranked/ranked tensor type for the given unranked/ranked memref type. </p>

<p class="definition">Definition at line <a class="el" href="MemRefOps_8cpp_source.html#l00059">59</a> of file <a class="el" href="MemRefOps_8cpp_source.html">MemRefOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00510">mlir::get()</a>, and <a class="el" href="IR_2Types_8cpp_source.html#l00035">mlir::Type::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefOps_8cpp_source.html#l01517">parseGlobalMemrefOpTypeAndInitialValue()</a>.</p>

</div>
</div>
<a id="a6dd556718fd72c7099dc94f99d30ccd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dd556718fd72c7099dc94f99d30ccd1">&#9670;&nbsp;</a></span>isStaticShapeAndContiguousRowMajor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::memref::isStaticShapeAndContiguousRowMajor </td>
          <td>(</td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true, if the memref type has static shapes and represents a contiguous chunk of memory. </p>

<p class="definition">Definition at line <a class="el" href="MemRefUtils_8cpp_source.html#l00022">22</a> of file <a class="el" href="MemRefUtils_8cpp_source.html">MemRefUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, and <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00807">mlir::getStridesAndOffset()</a>.</p>

</div>
</div>
<a id="ae4ffe31231e4fd88511f0d2446b4218d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4ffe31231e4fd88511f0d2446b4218d">&#9670;&nbsp;</a></span>multiBuffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; memref::AllocOp &gt; mlir::memref::multiBuffer </td>
          <td>(</td>
          <td class="paramtype">memref::AllocOp&#160;</td>
          <td class="paramname"><em>allocOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>multiplier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skipOverrideAnalysis</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call into <code>multiBuffer</code> with locally constructed <a class="el" href="classmlir_1_1IRRewriter.html" title="This class coordinates rewriting a piece of IR outside of a pattern rewrite, providing a way to keep ...">IRRewriter</a>. </p>

<p class="definition">Definition at line <a class="el" href="MultiBuffer_8cpp_source.html#l00246">246</a> of file <a class="el" href="MultiBuffer_8cpp_source.html">MultiBuffer.cpp</a>.</p>

<p class="reference">References <a class="el" href="MultiBuffer_8cpp_source.html#l00099">multiBuffer()</a>.</p>

</div>
</div>
<a id="a637539fbb3044706f07e949413eac30d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a637539fbb3044706f07e949413eac30d">&#9670;&nbsp;</a></span>multiBuffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; memref::AllocOp &gt; mlir::memref::multiBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memref::AllocOp&#160;</td>
          <td class="paramname"><em>allocOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>multiplier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skipOverrideAnalysis</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transformation to do multi-buffering/array expansion to remove dependencies on the temporary allocation between consecutive loop iterations. </p>
<p>It returns the new allocation if the original allocation was multi-buffered and returns <a class="el" href="namespacemlir.html#a07367c8c4a3d4a47a32bc2b9b7d8a3f4" title="Utility function to generate a LogicalResult.">failure()</a> otherwise. When <code>skipOverrideAnalysis</code>, the pass will apply the transformation without checking thwt the buffer is overrided at the beginning of each iteration. This implies that user knows that there is no data carried across loop iterations. Example: </p><div class="fragment"><div class="line">%0 = memref.alloc() : memref&lt;4x128xf32&gt;</div>
<div class="line">scf.for %iv = %c1 to %c1024 step %c3 {</div>
<div class="line">  memref.copy %1, %0 : memref&lt;4x128xf32&gt; to memref&lt;4x128xf32&gt;</div>
<div class="line">  <span class="stringliteral">&quot;some_use&quot;</span>(%0) : (memref&lt;4x128xf32&gt;) -&gt; ()</div>
<div class="line">}</div>
</div><!-- fragment --><p> into: </p><div class="fragment"><div class="line">%0 = memref.alloc() : memref&lt;5x4x128xf32&gt;</div>
<div class="line">scf.for %iv = %c1 to %c1024 step %c3 {</div>
<div class="line">  %s = arith.subi %iv, %c1 : index</div>
<div class="line">  %d = arith.divsi %s, %c3 : index</div>
<div class="line">  %i = arith.remsi %d, %c5 : index</div>
<div class="line">  %sv = memref.subview %0[%i, 0, 0] [1, 4, 128] [1, 1, 1] :</div>
<div class="line">    memref&lt;5x4x128xf32&gt; to memref&lt;4x128xf32, strided&lt;[128, 1], offset: ?&gt;&gt;</div>
<div class="line">  memref.copy %1, %sv : memref&lt;4x128xf32&gt; to memref&lt;4x128xf32, strided&lt;...&gt;&gt;</div>
<div class="line">  <span class="stringliteral">&quot;some_use&quot;</span>(%sv) : (memref&lt;4x128xf32, strided&lt;...&gt;) -&gt; ()</div>
<div class="line">}</div>
</div><!-- fragment --> <p>Make sure there is no loop-carried dependency on the allocation.</p>

<p class="definition">Definition at line <a class="el" href="MultiBuffer_8cpp_source.html#l00099">99</a> of file <a class="el" href="MultiBuffer_8cpp_source.html">MultiBuffer.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00334">mlir::bindDims()</a>, <a class="el" href="Builders_8cpp_source.html#l00446">mlir::OpBuilder::create()</a>, <a class="el" href="MultiBuffer_8cpp_source.html#l00030">DBGS</a>, <a class="el" href="Dominance_8h_source.html#l00141">mlir::DominanceInfo::dominates()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00306">mlir::RewriterBase::eraseOp()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="MathExtras_8h_source.html#l00033">mlir::floorDiv()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, <a class="el" href="Builders_8cpp_source.html#l00124">mlir::Builder::getIndexAttr()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00852">mlir::Operation::getUsers()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00040">mlir::getValueOrCreateConstantIndexOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01124">mlir::affine::makeComposedAffineApply()</a>, <a class="el" href="MultiBuffer_8cpp_source.html#l00034">overrideBuffer()</a>, <a class="el" href="MultiBuffer_8cpp_source.html#l00045">replaceUsesAndPropagateType()</a>, <a class="el" href="Builders_8h_source.html#l00383">mlir::OpBuilder::setInsertionPoint()</a>, <a class="el" href="Builders_8h_source.html#l00416">mlir::OpBuilder::setInsertionPointToStart()</a>, and <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00212">mlir::MemRefType::Builder::setShape()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MultiBuffer_8cpp_source.html#l00246">multiBuffer()</a>.</p>

</div>
</div>
<a id="af6c5916519d8d818c95097ef22e882ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6c5916519d8d818c95097ef22e882ee">&#9670;&nbsp;</a></span>populateComposeSubViewPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::populateComposeSubViewPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ComposeSubView_8cpp_source.html#l00131">131</a> of file <a class="el" href="ComposeSubView_8cpp_source.html">ComposeSubView.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01709">mlir::RewritePatternSet::add()</a>.</p>

</div>
</div>
<a id="aa72dbb57f66b3381ca288a092d376802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa72dbb57f66b3381ca288a092d376802">&#9670;&nbsp;</a></span>populateExpandOpsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::populateExpandOpsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collects a set of patterns to rewrite ops within the memref dialect. </p>

<p class="definition">Definition at line <a class="el" href="MemRef_2Transforms_2ExpandOps_8cpp_source.html#l00146">146</a> of file <a class="el" href="MemRef_2Transforms_2ExpandOps_8cpp_source.html">ExpandOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01709">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01685">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="ad3b5486ce1776bc5afddb8ec9cc97f2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b5486ce1776bc5afddb8ec9cc97f2a">&#9670;&nbsp;</a></span>populateExpandReallocPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::populateExpandReallocPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>emitDeallocs</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns for expanding <code>memref.realloc</code> operations. </p>

<p class="definition">Definition at line <a class="el" href="ExpandRealloc_8cpp_source.html#l00168">168</a> of file <a class="el" href="ExpandRealloc_8cpp_source.html">ExpandRealloc.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01709">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01685">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="ae0a91532e484d6485dc36756f1b1bace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0a91532e484d6485dc36756f1b1bace">&#9670;&nbsp;</a></span>populateExpandStridedMetadataPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::populateExpandStridedMetadataPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns for expanding memref operations that modify the metadata (sizes, offset, strides) of a memref into easier to analyze constructs. </p>

<p class="definition">Definition at line <a class="el" href="ExpandStridedMetadata_8cpp_source.html#l00988">988</a> of file <a class="el" href="ExpandStridedMetadata_8cpp_source.html">ExpandStridedMetadata.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01709">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01685">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="ad05667d80ad6b23301f24c722a4dbb28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad05667d80ad6b23301f24c722a4dbb28">&#9670;&nbsp;</a></span>populateExtractAddressComputationsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::populateExtractAddressComputationsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns for extracting address computations from the instructions with memory accesses such that these memory accesses use only a base pointer. </p>
<p>For instance, </p><div class="fragment"><div class="line">memref.load %base[%off0, ...]</div>
</div><!-- fragment --><p>Will be rewritten in: </p><div class="fragment"><div class="line">%new_base = memref.subview %base[%off0,...][1,...][1,...]</div>
<div class="line">memref.load %new_base[%c0,...]</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ExtractAddressComputations_8cpp_source.html#l00287">287</a> of file <a class="el" href="ExtractAddressComputations_8cpp_source.html">ExtractAddressComputations.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01709">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01685">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a0b92ea4d1067ac456aa6899baa8512a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b92ea4d1067ac456aa6899baa8512a9">&#9670;&nbsp;</a></span>populateFoldMemRefAliasOpPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::populateFoldMemRefAliasOpPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns for folding memref aliasing ops into consumer load/store ops into <code>patterns</code>. </p>

<p class="definition">Definition at line <a class="el" href="FoldMemRefAliasOps_8cpp_source.html#l00703">703</a> of file <a class="el" href="FoldMemRefAliasOps_8cpp_source.html">FoldMemRefAliasOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01709">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01685">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a5416c0ea0d3dcf0c0ce09270c16bb4c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5416c0ea0d3dcf0c0ce09270c16bb4c7">&#9670;&nbsp;</a></span>populateMemRefNarrowTypeEmulationConversions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::populateMemRefNarrowTypeEmulationConversions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1arith_1_1NarrowTypeEmulationConverter.html">arith::NarrowTypeEmulationConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends type conversions for emulating memref operations over narrow types with ops over wider types. </p>

<p class="definition">Definition at line <a class="el" href="MemRef_2Transforms_2EmulateNarrowType_8cpp_source.html#l00470">470</a> of file <a class="el" href="MemRef_2Transforms_2EmulateNarrowType_8cpp_source.html">EmulateNarrowType.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00164">mlir::TypeConverter::addConversion()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00510">mlir::get()</a>, <a class="el" href="MemRef_2Transforms_2EmulateNarrowType_8cpp_source.html#l00452">getLinearizedShape()</a>, <a class="el" href="NarrowTypeEmulationConverter_8h_source.html#l00024">mlir::arith::NarrowTypeEmulationConverter::getLoadStoreBitwidth()</a>, and <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00807">mlir::getStridesAndOffset()</a>.</p>

</div>
</div>
<a id="a1bf715704c6996833ff9d152a4aafe42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bf715704c6996833ff9d152a4aafe42">&#9670;&nbsp;</a></span>populateMemRefNarrowTypeEmulationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::populateMemRefNarrowTypeEmulationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1arith_1_1NarrowTypeEmulationConverter.html">arith::NarrowTypeEmulationConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns for emulating memref operations over narrow types with ops over wider types. </p>

<p class="definition">Definition at line <a class="el" href="MemRef_2Transforms_2EmulateNarrowType_8cpp_source.html#l00439">439</a> of file <a class="el" href="MemRef_2Transforms_2EmulateNarrowType_8cpp_source.html">EmulateNarrowType.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01709">mlir::RewritePatternSet::add()</a>, <a class="el" href="PatternMatch_8h_source.html#l01685">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="ExpandStridedMetadata_8cpp_source.html#l01005">populateResolveExtractStridedMetadataPatterns()</a>.</p>

</div>
</div>
<a id="a6c0e1bd45d93d6da7bf22b61465492b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c0e1bd45d93d6da7bf22b61465492b9">&#9670;&nbsp;</a></span>populateMemRefWideIntEmulationConversions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::populateMemRefWideIntEmulationConversions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1arith_1_1WideIntEmulationConverter.html">arith::WideIntEmulationConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends type conversions for emulating wide integer memref operations with ops over narrowe integer types. </p>

<p class="definition">Definition at line <a class="el" href="MemRef_2Transforms_2EmulateWideInt_8cpp_source.html#l00148">148</a> of file <a class="el" href="MemRef_2Transforms_2EmulateWideInt_8cpp_source.html">EmulateWideInt.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00164">mlir::TypeConverter::addConversion()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02921">mlir::TypeConverter::convertType()</a>, and <a class="el" href="WideIntEmulationConverter_8h_source.html#l00027">mlir::arith::WideIntEmulationConverter::getMaxTargetIntBitWidth()</a>.</p>

</div>
</div>
<a id="a51da475db04d0e27ef4a0a8f10c0c518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51da475db04d0e27ef4a0a8f10c0c518">&#9670;&nbsp;</a></span>populateMemRefWideIntEmulationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::populateMemRefWideIntEmulationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1arith_1_1WideIntEmulationConverter.html">arith::WideIntEmulationConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns for emulating wide integer memref operations with ops over narrower integer types. </p>

<p class="definition">Definition at line <a class="el" href="MemRef_2Transforms_2EmulateWideInt_8cpp_source.html#l00140">140</a> of file <a class="el" href="MemRef_2Transforms_2EmulateWideInt_8cpp_source.html">EmulateWideInt.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01709">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01685">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a933e3cb75cf93999afc61710776fea07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a933e3cb75cf93999afc61710776fea07">&#9670;&nbsp;</a></span>populateResolveExtractStridedMetadataPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::populateResolveExtractStridedMetadataPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns for resolving <code>memref.extract_strided_metadata</code> into <code>memref.extract_strided_metadata</code> of its source. </p>

<p class="definition">Definition at line <a class="el" href="ExpandStridedMetadata_8cpp_source.html#l01005">1005</a> of file <a class="el" href="ExpandStridedMetadata_8cpp_source.html">ExpandStridedMetadata.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01709">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01685">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRef_2Transforms_2EmulateNarrowType_8cpp_source.html#l00439">populateMemRefNarrowTypeEmulationPatterns()</a>.</p>

</div>
</div>
<a id="a313c2f5f760c17a276fac9bb108951c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a313c2f5f760c17a276fac9bb108951c9">&#9670;&nbsp;</a></span>populateResolveRankedShapedTypeResultDimsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::populateResolveRankedShapedTypeResultDimsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns that resolve <code>memref.dim</code> operations with values that are defined by operations that implement the <code>ReifyRankedShapedTypeOpInterface</code>, in terms of shapes of its input operands. </p>

<p class="definition">Definition at line <a class="el" href="ResolveShapedTypeResultDims_8cpp_source.html#l00127">127</a> of file <a class="el" href="ResolveShapedTypeResultDims_8cpp_source.html">ResolveShapedTypeResultDims.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01709">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01685">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DropUnitDims_8cpp_source.html#l00636">populateFoldUnitExtentDimsViaReshapesPatterns()</a>, and <a class="el" href="DropUnitDims_8cpp_source.html#l00655">populateFoldUnitExtentDimsViaSlicesPatterns()</a>.</p>

</div>
</div>
<a id="aaf97a8143d457b645153d6f40e6aed84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf97a8143d457b645153d6f40e6aed84">&#9670;&nbsp;</a></span>populateResolveShapedTypeResultDimsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::populateResolveShapedTypeResultDimsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends patterns that resolve <code>memref.dim</code> operations with values that are defined by operations that implement the <code>InferShapedTypeOpInterface</code>, in terms of shapes of its input operands. </p>

<p class="definition">Definition at line <a class="el" href="ResolveShapedTypeResultDims_8cpp_source.html#l00134">134</a> of file <a class="el" href="ResolveShapedTypeResultDims_8cpp_source.html">ResolveShapedTypeResultDims.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01709">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l01685">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DropUnitDims_8cpp_source.html#l00636">populateFoldUnitExtentDimsViaReshapesPatterns()</a>, and <a class="el" href="DropUnitDims_8cpp_source.html#l00655">populateFoldUnitExtentDimsViaSlicesPatterns()</a>.</p>

</div>
</div>
<a id="a1883b3342d764a07311e3f8a79d8dd1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1883b3342d764a07311e3f8a79d8dd1e">&#9670;&nbsp;</a></span>registerAllocationOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::registerAllocationOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AllocationOpInterfaceImpl_8cpp_source.html#l00061">61</a> of file <a class="el" href="AllocationOpInterfaceImpl_8cpp_source.html">AllocationOpInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00209">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllDialects_8h_source.html#l00099">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="a08647ff099a98052f95e4caff149a2f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08647ff099a98052f95e4caff149a2f9">&#9670;&nbsp;</a></span>registerMemorySlotExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::registerMemorySlotExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRefMemorySlot_8cpp_source.html#l00342">342</a> of file <a class="el" href="MemRefMemorySlot_8cpp_source.html">MemRefMemorySlot.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00209">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllDialects_8h_source.html#l00099">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="ad7fa7b00c1ccb23e5f4a528377dd4ee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7fa7b00c1ccb23e5f4a528377dd4ee9">&#9670;&nbsp;</a></span>registerRuntimeVerifiableOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::registerRuntimeVerifiableOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RuntimeOpVerification_8cpp_source.html#l00181">181</a> of file <a class="el" href="RuntimeOpVerification_8cpp_source.html">RuntimeOpVerification.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00209">mlir::DialectRegistry::addExtension()</a>, and <a class="el" href="MLIRContext_8h_source.html#l00107">mlir::MLIRContext::loadDialect()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllDialects_8h_source.html#l00099">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="ae1adc6a8d5aefc17867d0815b586c3b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1adc6a8d5aefc17867d0815b586c3b9">&#9670;&nbsp;</a></span>registerTransformDialectExtension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::registerTransformDialectExtension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRefTransformOps_8cpp_source.html#l00332">332</a> of file <a class="el" href="MemRefTransformOps_8cpp_source.html">MemRefTransformOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtensions()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllExtensions_8h_source.html#l00054">mlir::registerAllExtensions()</a>.</p>

</div>
</div>
<a id="ac2b49994f10e98cb119abfb38f23c0c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2b49994f10e98cb119abfb38f23c0c3">&#9670;&nbsp;</a></span>registerValueBoundsOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::memref::registerValueBoundsOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MemRef_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html#l00116">116</a> of file <a class="el" href="MemRef_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html">ValueBoundsOpInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00209">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitAllDialects_8h_source.html#l00099">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="a390d7b6bfa73372eec5b1d2cd2bf937b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a390d7b6bfa73372eec5b1d2cd2bf937b">&#9670;&nbsp;</a></span>replaceWithIndependentOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::memref::replaceWithIndependentOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memref::AllocaOp&#160;</td>
          <td class="paramname"><em>allocaOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>independencies</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a new memref::AllocaOp whose dynamic sizes are independent of all given independencies. </p>
<p>If the op is already independent of all independencies, the same AllocaOp result is returned.</p>
<p>The original AllocaOp is replaced with the new one, wrapped in a SubviewOp. The result type of the replacement is different from the original allocation type: it has the same shape, but a different layout map. This function updates all users that do not have a memref result or memref region block argument, and some frequently used memref dialect ops (such as memref.subview). It does not update other uses such as the init_arg of an scf.for op. Such uses are wrapped in unrealized_conversion_cast.</p>
<p>Failure indicates the no suitable upper bound for the dynamic sizes could be found.</p>
<p>Example (make independent of iv): </p><div class="fragment"><div class="line">scf.for %iv = %c0 to %sz step %c1 {</div>
<div class="line">  %0 = memref.alloca(%iv) : memref&lt;?xf32&gt;</div>
<div class="line">  %1 = memref.subview %0[0][5][1] : ...</div>
<div class="line">  linalg.generic outs(%1 : ...) ...</div>
<div class="line">  %2 = scf.for ... iter_arg(%arg0 = %0) ...</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>The above IR is rewritten to:</p>
<div class="fragment"><div class="line">scf.for %iv = %c0 to %sz step %c1 {</div>
<div class="line">  %0 = memref.alloca(%sz - 1) : memref&lt;?xf32&gt;</div>
<div class="line">  %0_subview = memref.subview %0[0][%iv][1]</div>
<div class="line">      : memref&lt;?xf32&gt; to memref&lt;?xf32, #map&gt;</div>
<div class="line">  %1 = memref.subview %0_subview[0][5][1] : ...</div>
<div class="line">  linalg.generic outs(%1 : ...) ...</div>
<div class="line">  %cast = unrealized_conversion_cast %0_subview</div>
<div class="line">      : memref&lt;?xf32, #map&gt; to memref&lt;?xf32&gt;</div>
<div class="line">  %2 = scf.for ... iter_arg(%arg0 = %cast) ...</div>
<div class="line"> ...</div>
<div class="line">}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="MemRef_2Transforms_2IndependenceTransforms_8cpp_source.html#l00170">170</a> of file <a class="el" href="MemRef_2Transforms_2IndependenceTransforms_8cpp_source.html">IndependenceTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir_1_1memref.html#a1bf86c211b0ab9ea0b1ea4943a4e6d6e">buildIndependentOp()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, and <a class="el" href="MemRef_2Transforms_2IndependenceTransforms_8cpp_source.html#l00100">replaceAndPropagateMemRefType()</a>.</p>

</div>
</div>
<a id="a1c2b990b3c696031cd589f1859416013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c2b990b3c696031cd589f1859416013">&#9670;&nbsp;</a></span>resultIsNotRead()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool mlir::memref::resultIsNotRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>uses</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if all the uses of op are not read/load. </p>
<p>There can be SubviewOp users as long as all its users are also StoreOp/transfer_write. If return true it also fills out the uses, if it returns false uses is unchanged. </p>

<p class="definition">Definition at line <a class="el" href="MemRefUtils_8cpp_source.html#l00128">128</a> of file <a class="el" href="MemRefUtils_8cpp_source.html">MemRefUtils.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Dec 9 2023 02:40:37 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
