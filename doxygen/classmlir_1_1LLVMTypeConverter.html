<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::LLVMTypeConverter Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">18.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classmlir_1_1LLVMTypeConverter-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::LLVMTypeConverter Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Conversion from types to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR dialect.  
 <a href="classmlir_1_1LLVMTypeConverter.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="TypeConverter_8h_source.html">mlir/Conversion/LLVMCommon/TypeConverter.h</a>&quot;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for mlir::LLVMTypeConverter:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classmlir_1_1LLVMTypeConverter__inherit__graph.png" border="0" usemap="#amlir_1_1LLVMTypeConverter_inherit__map" alt="Inheritance graph"/></div>
<map name="amlir_1_1LLVMTypeConverter_inherit__map" id="amlir_1_1LLVMTypeConverter_inherit__map">
<area shape="rect" title="Conversion from types to the LLVM IR dialect." alt="" coords="5,80,189,107"/>
<area shape="rect" href="classmlir_1_1TypeConverter.html" title="Type conversion class." alt="" coords="22,5,173,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abb9279107c83f744985d247e3c87cc09"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#abb9279107c83f744985d247e3c87cc09">LLVMTypeConverter</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, const <a class="el" href="classmlir_1_1DataLayoutAnalysis.html">DataLayoutAnalysis</a> *analysis=nullptr)</td></tr>
<tr class="memdesc:abb9279107c83f744985d247e3c87cc09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classmlir_1_1LLVMTypeConverter.html" title="Conversion from types to the LLVM IR dialect.">LLVMTypeConverter</a> using the default <a class="el" href="classmlir_1_1LowerToLLVMOptions.html" title="Options to control the LLVM lowering.">LowerToLLVMOptions</a>.  <a href="classmlir_1_1LLVMTypeConverter.html#abb9279107c83f744985d247e3c87cc09">More...</a><br /></td></tr>
<tr class="separator:abb9279107c83f744985d247e3c87cc09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0838be3560f61a0c13e8d39ff13f828"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#aa0838be3560f61a0c13e8d39ff13f828">LLVMTypeConverter</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, const <a class="el" href="classmlir_1_1LowerToLLVMOptions.html">LowerToLLVMOptions</a> &amp;options, const <a class="el" href="classmlir_1_1DataLayoutAnalysis.html">DataLayoutAnalysis</a> *analysis=nullptr)</td></tr>
<tr class="memdesc:aa0838be3560f61a0c13e8d39ff13f828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classmlir_1_1LLVMTypeConverter.html" title="Conversion from types to the LLVM IR dialect.">LLVMTypeConverter</a> using custom <a class="el" href="classmlir_1_1LowerToLLVMOptions.html" title="Options to control the LLVM lowering.">LowerToLLVMOptions</a>.  <a href="classmlir_1_1LLVMTypeConverter.html#aa0838be3560f61a0c13e8d39ff13f828">More...</a><br /></td></tr>
<tr class="separator:aa0838be3560f61a0c13e8d39ff13f828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a134316f4850a9e646dc68e8376ad9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#a53a134316f4850a9e646dc68e8376ad9">convertFunctionSignature</a> (FunctionType funcTy, bool isVariadic, bool useBarePtrCallConv, <a class="el" href="classmlir_1_1TypeConverter_1_1SignatureConversion.html">SignatureConversion</a> &amp;result) const</td></tr>
<tr class="memdesc:a53a134316f4850a9e646dc68e8376ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a function type.  <a href="classmlir_1_1LLVMTypeConverter.html#a53a134316f4850a9e646dc68e8376ad9">More...</a><br /></td></tr>
<tr class="separator:a53a134316f4850a9e646dc68e8376ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285f908311d50945ff0d644ad3beaee7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#a285f908311d50945ff0d644ad3beaee7">packFunctionResults</a> (<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> types, bool useBarePointerCallConv=false) const</td></tr>
<tr class="memdesc:a285f908311d50945ff0d644ad3beaee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a non-empty list of types to be returned from a function into an LLVM-compatible type.  <a href="classmlir_1_1LLVMTypeConverter.html#a285f908311d50945ff0d644ad3beaee7">More...</a><br /></td></tr>
<tr class="separator:a285f908311d50945ff0d644ad3beaee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b2654ba7a875df2dd830288792934c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#a10b2654ba7a875df2dd830288792934c">packOperationResults</a> (<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> types) const</td></tr>
<tr class="memdesc:a10b2654ba7a875df2dd830288792934c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a non-empty list of types of values produced by an operation into an LLVM-compatible type.  <a href="classmlir_1_1LLVMTypeConverter.html#a10b2654ba7a875df2dd830288792934c">More...</a><br /></td></tr>
<tr class="separator:a10b2654ba7a875df2dd830288792934c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ebcd548b2fb3f46bad15f6563786bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#aa7ebcd548b2fb3f46bad15f6563786bf">convertCallingConventionType</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type, bool useBarePointerCallConv=false) const</td></tr>
<tr class="memdesc:aa7ebcd548b2fb3f46bad15f6563786bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a type in the context of the default or bare pointer calling convention.  <a href="classmlir_1_1LLVMTypeConverter.html#aa7ebcd548b2fb3f46bad15f6563786bf">More...</a><br /></td></tr>
<tr class="separator:aa7ebcd548b2fb3f46bad15f6563786bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d31697177d4412398c4c9a114cdb2f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#a5d31697177d4412398c4c9a114cdb2f0">promoteBarePtrsToDescriptors</a> (<a class="el" href="classmlir_1_1ConversionPatternRewriter.html">ConversionPatternRewriter</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; stdTypes, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;values) const</td></tr>
<tr class="memdesc:a5d31697177d4412398c4c9a114cdb2f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promote the bare pointers in 'values' that resulted from memrefs to descriptors.  <a href="classmlir_1_1LLVMTypeConverter.html#a5d31697177d4412398c4c9a114cdb2f0">More...</a><br /></td></tr>
<tr class="separator:a5d31697177d4412398c4c9a114cdb2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1bae21dab08d18741a94aea9fa1b5be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#ae1bae21dab08d18741a94aea9fa1b5be">getContext</a> () const</td></tr>
<tr class="memdesc:ae1bae21dab08d18741a94aea9fa1b5be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the MLIR context.  <a href="classmlir_1_1LLVMTypeConverter.html#ae1bae21dab08d18741a94aea9fa1b5be">More...</a><br /></td></tr>
<tr class="separator:ae1bae21dab08d18741a94aea9fa1b5be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fef25eab0df64af252d7d14c4a0caec"><td class="memItemLeft" align="right" valign="top">LLVM::LLVMDialect *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#a1fef25eab0df64af252d7d14c4a0caec">getDialect</a> () const</td></tr>
<tr class="memdesc:a1fef25eab0df64af252d7d14c4a0caec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect.  <a href="classmlir_1_1LLVMTypeConverter.html#a1fef25eab0df64af252d7d14c4a0caec">More...</a><br /></td></tr>
<tr class="separator:a1fef25eab0df64af252d7d14c4a0caec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f142ecd8d10e44d253307880715607"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmlir_1_1LowerToLLVMOptions.html">LowerToLLVMOptions</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#a48f142ecd8d10e44d253307880715607">getOptions</a> () const</td></tr>
<tr class="separator:a48f142ecd8d10e44d253307880715607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77513f669fae3497ae34732244ac6b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#ab77513f669fae3497ae34732244ac6b9">promoteOperands</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> opOperands, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, bool useBarePtrCallConv=false) const</td></tr>
<tr class="memdesc:ab77513f669fae3497ae34732244ac6b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promote the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> representation of all operands including promoting MemRef descriptors to stack and use pointers to struct to avoid the complexity of the platform-specific C/C++ ABI lowering related to struct argument passing.  <a href="classmlir_1_1LLVMTypeConverter.html#ab77513f669fae3497ae34732244ac6b9">More...</a><br /></td></tr>
<tr class="separator:ab77513f669fae3497ae34732244ac6b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0d71d9f3b2bab702e475f6890ed4a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#a9a0d71d9f3b2bab702e475f6890ed4a1">promoteOneMemRefDescriptor</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> operand, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder) const</td></tr>
<tr class="memdesc:a9a0d71d9f3b2bab702e475f6890ed4a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promote the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> struct representation of one MemRef descriptor to stack and use pointer to struct to avoid the complexity of the platform-specific C/C++ ABI lowering related to struct argument passing.  <a href="classmlir_1_1LLVMTypeConverter.html#a9a0d71d9f3b2bab702e475f6890ed4a1">More...</a><br /></td></tr>
<tr class="separator:a9a0d71d9f3b2bab702e475f6890ed4a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae85823fd715ae2b9b86c5857fb6d37cc"><td class="memItemLeft" align="right" valign="top">std::pair&lt; LLVM::LLVMFunctionType, <a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html">LLVM::LLVMStructType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#ae85823fd715ae2b9b86c5857fb6d37cc">convertFunctionTypeCWrapper</a> (FunctionType type) const</td></tr>
<tr class="memdesc:ae85823fd715ae2b9b86c5857fb6d37cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the function type to a C-compatible format, in particular using pointers to memref descriptors for arguments.  <a href="classmlir_1_1LLVMTypeConverter.html#ae85823fd715ae2b9b86c5857fb6d37cc">More...</a><br /></td></tr>
<tr class="separator:ae85823fd715ae2b9b86c5857fb6d37cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd53b4634b1a8d32cebcce2e47fb8eb"><td class="memItemLeft" align="right" valign="top">const llvm::DataLayout &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#adcd53b4634b1a8d32cebcce2e47fb8eb">getDataLayout</a> () const</td></tr>
<tr class="memdesc:adcd53b4634b1a8d32cebcce2e47fb8eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the data layout to use during and after conversion.  <a href="classmlir_1_1LLVMTypeConverter.html#adcd53b4634b1a8d32cebcce2e47fb8eb">More...</a><br /></td></tr>
<tr class="separator:adcd53b4634b1a8d32cebcce2e47fb8eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5617fe390dff357f3e9e39f9ed9e38"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmlir_1_1DataLayoutAnalysis.html">DataLayoutAnalysis</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#a5e5617fe390dff357f3e9e39f9ed9e38">getDataLayoutAnalysis</a> () const</td></tr>
<tr class="memdesc:a5e5617fe390dff357f3e9e39f9ed9e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the data layout analysis to query during conversion.  <a href="classmlir_1_1LLVMTypeConverter.html#a5e5617fe390dff357f3e9e39f9ed9e38">More...</a><br /></td></tr>
<tr class="separator:a5e5617fe390dff357f3e9e39f9ed9e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee2f27593c07c2c8e3bf8195252b1a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#aeee2f27593c07c2c8e3bf8195252b1a8">getIndexType</a> () const</td></tr>
<tr class="memdesc:aeee2f27593c07c2c8e3bf8195252b1a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> representation of the index type.  <a href="classmlir_1_1LLVMTypeConverter.html#aeee2f27593c07c2c8e3bf8195252b1a8">More...</a><br /></td></tr>
<tr class="separator:aeee2f27593c07c2c8e3bf8195252b1a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae91b3adee39d4b558df51642b88890ae"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#ae91b3adee39d4b558df51642b88890ae">getIndexTypeBitwidth</a> () const</td></tr>
<tr class="memdesc:ae91b3adee39d4b558df51642b88890ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the bitwidth of the index type when converted to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <a href="classmlir_1_1LLVMTypeConverter.html#ae91b3adee39d4b558df51642b88890ae">More...</a><br /></td></tr>
<tr class="separator:ae91b3adee39d4b558df51642b88890ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3faa948105d0db2cd0b26f7ae3920fa"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#ac3faa948105d0db2cd0b26f7ae3920fa">getPointerBitwidth</a> (unsigned addressSpace=0) const</td></tr>
<tr class="memdesc:ac3faa948105d0db2cd0b26f7ae3920fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the pointer bitwidth.  <a href="classmlir_1_1LLVMTypeConverter.html#ac3faa948105d0db2cd0b26f7ae3920fa">More...</a><br /></td></tr>
<tr class="separator:ac3faa948105d0db2cd0b26f7ae3920fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5bdd0b0c1b8f4b7ce1f7504a5673e58"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#ae5bdd0b0c1b8f4b7ce1f7504a5673e58">getMemRefDescriptorSize</a> (MemRefType type, const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;layout) const</td></tr>
<tr class="memdesc:ae5bdd0b0c1b8f4b7ce1f7504a5673e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the memref descriptor object in bytes.  <a href="classmlir_1_1LLVMTypeConverter.html#ae5bdd0b0c1b8f4b7ce1f7504a5673e58">More...</a><br /></td></tr>
<tr class="separator:ae5bdd0b0c1b8f4b7ce1f7504a5673e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5026b6f13d12445a8d60b3c9184aa904"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#a5026b6f13d12445a8d60b3c9184aa904">getUnrankedMemRefDescriptorSize</a> (<a class="el" href="structUnrankedMemRefType.html">UnrankedMemRefType</a> type, const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;layout) const</td></tr>
<tr class="memdesc:a5026b6f13d12445a8d60b3c9184aa904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the unranked memref descriptor object in bytes.  <a href="classmlir_1_1LLVMTypeConverter.html#a5026b6f13d12445a8d60b3c9184aa904">More...</a><br /></td></tr>
<tr class="separator:a5026b6f13d12445a8d60b3c9184aa904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f665228b7d8d25949296df8e80cb19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#ac8f665228b7d8d25949296df8e80cb19">getMemRefAddressSpace</a> (<a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a> type) const</td></tr>
<tr class="memdesc:ac8f665228b7d8d25949296df8e80cb19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> address space corresponding to the memory space of the memref type <code>type</code> or failure if the memory space cannot be converted to an integer.  <a href="classmlir_1_1LLVMTypeConverter.html#ac8f665228b7d8d25949296df8e80cb19">More...</a><br /></td></tr>
<tr class="separator:ac8f665228b7d8d25949296df8e80cb19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1fae4fc72123cef7302a93ba314c6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#aad1fae4fc72123cef7302a93ba314c6a">convertType</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> t, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;results) const</td></tr>
<tr class="memdesc:aad1fae4fc72123cef7302a93ba314c6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the given type.  <a href="classmlir_1_1LLVMTypeConverter.html#aad1fae4fc72123cef7302a93ba314c6a">More...</a><br /></td></tr>
<tr class="separator:aad1fae4fc72123cef7302a93ba314c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c28856d7176c4af44f64906de33b6ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#a7c28856d7176c4af44f64906de33b6ac">convertType</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> t) const</td></tr>
<tr class="memdesc:a7c28856d7176c4af44f64906de33b6ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">This hook simplifies defining 1-1 type conversions.  <a href="classmlir_1_1LLVMTypeConverter.html#a7c28856d7176c4af44f64906de33b6ac">More...</a><br /></td></tr>
<tr class="separator:a7c28856d7176c4af44f64906de33b6ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781dc5f696e4309ad385645a74295fe0"><td class="memTemplParams" colspan="2">template&lt;typename TargetType &gt; </td></tr>
<tr class="memitem:a781dc5f696e4309ad385645a74295fe0"><td class="memTemplItemLeft" align="right" valign="top">TargetType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#a781dc5f696e4309ad385645a74295fe0">convertType</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> t) const</td></tr>
<tr class="memdesc:a781dc5f696e4309ad385645a74295fe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts a 1-1 type conversion, expecting the result type to be <code>TargetType</code>.  <a href="classmlir_1_1LLVMTypeConverter.html#a781dc5f696e4309ad385645a74295fe0">More...</a><br /></td></tr>
<tr class="separator:a781dc5f696e4309ad385645a74295fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmlir_1_1TypeConverter"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmlir_1_1TypeConverter')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmlir_1_1TypeConverter.html">mlir::TypeConverter</a></td></tr>
<tr class="memitem:ac23c45fa40bd2771f27702f46fac5232 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#ac23c45fa40bd2771f27702f46fac5232">~TypeConverter</a> ()=default</td></tr>
<tr class="separator:ac23c45fa40bd2771f27702f46fac5232 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7055830377e3f38b6160a9712b5beba1 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a7055830377e3f38b6160a9712b5beba1">TypeConverter</a> ()=default</td></tr>
<tr class="separator:a7055830377e3f38b6160a9712b5beba1 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b77498262ce63baee43eafd23b3e6df inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a7b77498262ce63baee43eafd23b3e6df">TypeConverter</a> (const <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;other)</td></tr>
<tr class="separator:a7b77498262ce63baee43eafd23b3e6df inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e7c8bca88d9cd366e8b727b1aca27ae inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a7e7c8bca88d9cd366e8b727b1aca27ae">operator=</a> (const <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;other)</td></tr>
<tr class="separator:a7e7c8bca88d9cd366e8b727b1aca27ae inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272bc4144b1ac5a3f7f1ad25c0e39e03 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memTemplParams" colspan="2">template&lt;typename FnT , typename T  = typename llvm::function_traits&lt;                              std::decay_t&lt;FnT&gt;&gt;::template arg_t&lt;0&gt;&gt; </td></tr>
<tr class="memitem:a272bc4144b1ac5a3f7f1ad25c0e39e03 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a272bc4144b1ac5a3f7f1ad25c0e39e03">addConversion</a> (FnT &amp;&amp;callback)</td></tr>
<tr class="memdesc:a272bc4144b1ac5a3f7f1ad25c0e39e03 inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a conversion function.  <a href="classmlir_1_1TypeConverter.html#a272bc4144b1ac5a3f7f1ad25c0e39e03">More...</a><br /></td></tr>
<tr class="separator:a272bc4144b1ac5a3f7f1ad25c0e39e03 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db00a47b187ad5846fea3362969a913 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memTemplParams" colspan="2">template&lt;typename FnT , typename T  = typename llvm::function_traits&lt;                              std::decay_t&lt;FnT&gt;&gt;::template arg_t&lt;1&gt;&gt; </td></tr>
<tr class="memitem:a3db00a47b187ad5846fea3362969a913 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a3db00a47b187ad5846fea3362969a913">addArgumentMaterialization</a> (FnT &amp;&amp;callback)</td></tr>
<tr class="memdesc:a3db00a47b187ad5846fea3362969a913 inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a materialization function, which must be convertible to the following form: <code>std::optional&lt;<a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>&gt;(<a class="el" href="classmlir_1_1OpBuilder.html" title="This class helps build Operations.">OpBuilder</a> &amp;, T, <a class="el" href="classmlir_1_1ValueRange.html" title="This class provides an abstraction over the different types of ranges over Values.">ValueRange</a>, <a class="el" href="classmlir_1_1Location.html" title="This class defines the main interface for locations in MLIR and acts as a non-nullable wrapper around...">Location</a>)</code>, where <code>T</code> is any subclass of <code><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a></code>.  <a href="classmlir_1_1TypeConverter.html#a3db00a47b187ad5846fea3362969a913">More...</a><br /></td></tr>
<tr class="separator:a3db00a47b187ad5846fea3362969a913 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf35c0b4faa6fa6d8eda987ad71393e9 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memTemplParams" colspan="2">template&lt;typename FnT , typename T  = typename llvm::function_traits&lt;                              std::decay_t&lt;FnT&gt;&gt;::template arg_t&lt;1&gt;&gt; </td></tr>
<tr class="memitem:aaf35c0b4faa6fa6d8eda987ad71393e9 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#aaf35c0b4faa6fa6d8eda987ad71393e9">addSourceMaterialization</a> (FnT &amp;&amp;callback)</td></tr>
<tr class="memdesc:aaf35c0b4faa6fa6d8eda987ad71393e9 inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method registers a materialization that will be called when converting a legal type to an illegal source type.  <a href="classmlir_1_1TypeConverter.html#aaf35c0b4faa6fa6d8eda987ad71393e9">More...</a><br /></td></tr>
<tr class="separator:aaf35c0b4faa6fa6d8eda987ad71393e9 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe54f9a4348e1d8aa30535f53ddaf37 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memTemplParams" colspan="2">template&lt;typename FnT , typename T  = typename llvm::function_traits&lt;                              std::decay_t&lt;FnT&gt;&gt;::template arg_t&lt;1&gt;&gt; </td></tr>
<tr class="memitem:acfe54f9a4348e1d8aa30535f53ddaf37 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#acfe54f9a4348e1d8aa30535f53ddaf37">addTargetMaterialization</a> (FnT &amp;&amp;callback)</td></tr>
<tr class="memdesc:acfe54f9a4348e1d8aa30535f53ddaf37 inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method registers a materialization that will be called when converting type from an illegal, or source, type to a legal type.  <a href="classmlir_1_1TypeConverter.html#acfe54f9a4348e1d8aa30535f53ddaf37">More...</a><br /></td></tr>
<tr class="separator:acfe54f9a4348e1d8aa30535f53ddaf37 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b36cbf0a62aab9acb39d9299336980 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memTemplParams" colspan="2">template&lt;typename FnT , typename T  = typename llvm::function_traits&lt;std::decay_t&lt;FnT&gt;&gt;::template arg_t&lt;0&gt;, typename A  = typename llvm::function_traits&lt;std::decay_t&lt;FnT&gt;&gt;::template arg_t&lt;1&gt;&gt; </td></tr>
<tr class="memitem:ac5b36cbf0a62aab9acb39d9299336980 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#ac5b36cbf0a62aab9acb39d9299336980">addTypeAttributeConversion</a> (FnT &amp;&amp;callback)</td></tr>
<tr class="memdesc:ac5b36cbf0a62aab9acb39d9299336980 inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a conversion function for attributes within types.  <a href="classmlir_1_1TypeConverter.html#ac5b36cbf0a62aab9acb39d9299336980">More...</a><br /></td></tr>
<tr class="separator:ac5b36cbf0a62aab9acb39d9299336980 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1fae4fc72123cef7302a93ba314c6a inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#aad1fae4fc72123cef7302a93ba314c6a">convertType</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> t, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;results) const</td></tr>
<tr class="memdesc:aad1fae4fc72123cef7302a93ba314c6a inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the given type.  <a href="classmlir_1_1TypeConverter.html#aad1fae4fc72123cef7302a93ba314c6a">More...</a><br /></td></tr>
<tr class="separator:aad1fae4fc72123cef7302a93ba314c6a inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c28856d7176c4af44f64906de33b6ac inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a7c28856d7176c4af44f64906de33b6ac">convertType</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> t) const</td></tr>
<tr class="memdesc:a7c28856d7176c4af44f64906de33b6ac inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">This hook simplifies defining 1-1 type conversions.  <a href="classmlir_1_1TypeConverter.html#a7c28856d7176c4af44f64906de33b6ac">More...</a><br /></td></tr>
<tr class="separator:a7c28856d7176c4af44f64906de33b6ac inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781dc5f696e4309ad385645a74295fe0 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memTemplParams" colspan="2">template&lt;typename TargetType &gt; </td></tr>
<tr class="memitem:a781dc5f696e4309ad385645a74295fe0 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memTemplItemLeft" align="right" valign="top">TargetType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a781dc5f696e4309ad385645a74295fe0">convertType</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> t) const</td></tr>
<tr class="memdesc:a781dc5f696e4309ad385645a74295fe0 inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts a 1-1 type conversion, expecting the result type to be <code>TargetType</code>.  <a href="classmlir_1_1TypeConverter.html#a781dc5f696e4309ad385645a74295fe0">More...</a><br /></td></tr>
<tr class="separator:a781dc5f696e4309ad385645a74295fe0 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a2339e9128e1b05df14b075f6c3914 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#ad8a2339e9128e1b05df14b075f6c3914">convertTypes</a> (<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> types, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;results) const</td></tr>
<tr class="memdesc:ad8a2339e9128e1b05df14b075f6c3914 inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the given set of types, filling 'results' as necessary.  <a href="classmlir_1_1TypeConverter.html#ad8a2339e9128e1b05df14b075f6c3914">More...</a><br /></td></tr>
<tr class="separator:ad8a2339e9128e1b05df14b075f6c3914 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3050e11aff691748a33f690d842ada1c inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a3050e11aff691748a33f690d842ada1c">isLegal</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type) const</td></tr>
<tr class="memdesc:a3050e11aff691748a33f690d842ada1c inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the given type is legal for this type converter, i.e.  <a href="classmlir_1_1TypeConverter.html#a3050e11aff691748a33f690d842ada1c">More...</a><br /></td></tr>
<tr class="separator:a3050e11aff691748a33f690d842ada1c inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75fd289b2940df99c1e068a8dfef4759 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memTemplParams" colspan="2">template&lt;typename RangeT &gt; </td></tr>
<tr class="memitem:a75fd289b2940df99c1e068a8dfef4759 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!std::is_convertible&lt; RangeT, <a class="el" href="classmlir_1_1Type.html">Type</a> &gt;::value &amp;&amp;!std::is_convertible&lt; RangeT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;::value, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a75fd289b2940df99c1e068a8dfef4759">isLegal</a> (RangeT &amp;&amp;range) const</td></tr>
<tr class="memdesc:a75fd289b2940df99c1e068a8dfef4759 inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if all of the given types are legal for this type converter.  <a href="classmlir_1_1TypeConverter.html#a75fd289b2940df99c1e068a8dfef4759">More...</a><br /></td></tr>
<tr class="separator:a75fd289b2940df99c1e068a8dfef4759 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1eee88c23ccdc294537f1a04a79d3c inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a2b1eee88c23ccdc294537f1a04a79d3c">isLegal</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op) const</td></tr>
<tr class="memdesc:a2b1eee88c23ccdc294537f1a04a79d3c inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the given operation has legal operand and result types.  <a href="classmlir_1_1TypeConverter.html#a2b1eee88c23ccdc294537f1a04a79d3c">More...</a><br /></td></tr>
<tr class="separator:a2b1eee88c23ccdc294537f1a04a79d3c inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672cfe5a3dfbc0a44bb6ad90e496867f inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a672cfe5a3dfbc0a44bb6ad90e496867f">isLegal</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> *region) const</td></tr>
<tr class="memdesc:a672cfe5a3dfbc0a44bb6ad90e496867f inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the types of block arguments within the region are legal.  <a href="classmlir_1_1TypeConverter.html#a672cfe5a3dfbc0a44bb6ad90e496867f">More...</a><br /></td></tr>
<tr class="separator:a672cfe5a3dfbc0a44bb6ad90e496867f inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae22e7873e1d10ad53ffc8bc89bf4e094 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#ae22e7873e1d10ad53ffc8bc89bf4e094">isSignatureLegal</a> (FunctionType ty) const</td></tr>
<tr class="memdesc:ae22e7873e1d10ad53ffc8bc89bf4e094 inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the inputs and outputs of the given function type are legal.  <a href="classmlir_1_1TypeConverter.html#ae22e7873e1d10ad53ffc8bc89bf4e094">More...</a><br /></td></tr>
<tr class="separator:ae22e7873e1d10ad53ffc8bc89bf4e094 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a08ffe75d1915342f5961a910cf700 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a79a08ffe75d1915342f5961a910cf700">convertSignatureArg</a> (unsigned inputNo, <a class="el" href="classmlir_1_1Type.html">Type</a> type, <a class="el" href="classmlir_1_1TypeConverter_1_1SignatureConversion.html">SignatureConversion</a> &amp;result) const</td></tr>
<tr class="memdesc:a79a08ffe75d1915342f5961a910cf700 inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method allows for converting a specific argument of a signature.  <a href="classmlir_1_1TypeConverter.html#a79a08ffe75d1915342f5961a910cf700">More...</a><br /></td></tr>
<tr class="separator:a79a08ffe75d1915342f5961a910cf700 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60393514e60087a6f446c7f63f516bf9 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a60393514e60087a6f446c7f63f516bf9">convertSignatureArgs</a> (<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> types, <a class="el" href="classmlir_1_1TypeConverter_1_1SignatureConversion.html">SignatureConversion</a> &amp;result, unsigned origInputOffset=0) const</td></tr>
<tr class="separator:a60393514e60087a6f446c7f63f516bf9 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad8d5e5f4f53b68ae964d852a16e5352 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classmlir_1_1TypeConverter_1_1SignatureConversion.html">SignatureConversion</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#aad8d5e5f4f53b68ae964d852a16e5352">convertBlockSignature</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *block) const</td></tr>
<tr class="memdesc:aad8d5e5f4f53b68ae964d852a16e5352 inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts the type signature of the given block, by invoking 'convertSignatureArg' for each argument.  <a href="classmlir_1_1TypeConverter.html#aad8d5e5f4f53b68ae964d852a16e5352">More...</a><br /></td></tr>
<tr class="separator:aad8d5e5f4f53b68ae964d852a16e5352 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47cb659fc2a2e5d3df183e53c0502b44 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a47cb659fc2a2e5d3df183e53c0502b44">materializeArgumentConversion</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Type.html">Type</a> resultType, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> inputs) const</td></tr>
<tr class="memdesc:a47cb659fc2a2e5d3df183e53c0502b44 inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Materialize a conversion from a set of types into one result type by generating a cast sequence of some kind.  <a href="classmlir_1_1TypeConverter.html#a47cb659fc2a2e5d3df183e53c0502b44">More...</a><br /></td></tr>
<tr class="separator:a47cb659fc2a2e5d3df183e53c0502b44 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f2a9966e3fca10eef42b6ab35355b41 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a3f2a9966e3fca10eef42b6ab35355b41">materializeSourceConversion</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Type.html">Type</a> resultType, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> inputs) const</td></tr>
<tr class="separator:a3f2a9966e3fca10eef42b6ab35355b41 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e8ac5b4dbc11877317bd52d241aaa4 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#ae0e8ac5b4dbc11877317bd52d241aaa4">materializeTargetConversion</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Type.html">Type</a> resultType, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> inputs) const</td></tr>
<tr class="separator:ae0e8ac5b4dbc11877317bd52d241aaa4 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011b143e5a619f6f44d5bd46c29b95cc inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a011b143e5a619f6f44d5bd46c29b95cc">convertTypeAttribute</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr) const</td></tr>
<tr class="memdesc:a011b143e5a619f6f44d5bd46c29b95cc inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an attribute present <code>attr</code> from within the type <code>type</code> using the registered conversion functions.  <a href="classmlir_1_1TypeConverter.html#a011b143e5a619f6f44d5bd46c29b95cc">More...</a><br /></td></tr>
<tr class="separator:a011b143e5a619f6f44d5bd46c29b95cc inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:add6a58ffa4a0f076c7e513d493c82fb3"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#add6a58ffa4a0f076c7e513d493c82fb3">canConvertToBarePtr</a> (<a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a> type)</td></tr>
<tr class="memdesc:add6a58ffa4a0f076c7e513d493c82fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a memref type can be converted to a bare pointer.  <a href="classmlir_1_1LLVMTypeConverter.html#add6a58ffa4a0f076c7e513d493c82fb3">More...</a><br /></td></tr>
<tr class="separator:add6a58ffa4a0f076c7e513d493c82fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a7c8883828a1c71ea23fd045d82e1eaa1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#a7c8883828a1c71ea23fd045d82e1eaa1">getCurrentThreadRecursiveStack</a> ()</td></tr>
<tr class="separator:a7c8883828a1c71ea23fd045d82e1eaa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a0034100981a301427abe8367c89ef6a3"><td class="memItemLeft" align="right" valign="top">LLVM::LLVMDialect *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#a0034100981a301427abe8367c89ef6a3">llvmDialect</a></td></tr>
<tr class="memdesc:a0034100981a301427abe8367c89ef6a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect.  <a href="classmlir_1_1LLVMTypeConverter.html#a0034100981a301427abe8367c89ef6a3">More...</a><br /></td></tr>
<tr class="separator:a0034100981a301427abe8367c89ef6a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7466ae2ed9e33d91b625d076c4dc517d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt; uint64_t, std::unique_ptr&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#a7466ae2ed9e33d91b625d076c4dc517d">conversionCallStack</a></td></tr>
<tr class="separator:a7466ae2ed9e33d91b625d076c4dc517d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a8ba63d13409bf975cd862683e071a8"><td class="memItemLeft" align="right" valign="top">llvm::sys::SmartRWMutex&lt; true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#a0a8ba63d13409bf975cd862683e071a8">callStackMutex</a></td></tr>
<tr class="separator:a0a8ba63d13409bf975cd862683e071a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:af9b34d77d5e460270f7b831c513dfe1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#af9b34d77d5e460270f7b831c513dfe1b">structFuncArgTypeConverter</a> (const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1Type.html">Type</a> type, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;result)</td></tr>
<tr class="memdesc:af9b34d77d5e460270f7b831c513dfe1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give structFuncArgTypeConverter access to memref-specific functions.  <a href="classmlir_1_1LLVMTypeConverter.html#af9b34d77d5e460270f7b831c513dfe1b">More...</a><br /></td></tr>
<tr class="separator:af9b34d77d5e460270f7b831c513dfe1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Conversion from types to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR dialect. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8h_source.html#l00033">33</a> of file <a class="el" href="TypeConverter_8h_source.html">TypeConverter.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abb9279107c83f744985d247e3c87cc09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb9279107c83f744985d247e3c87cc09">&#9670;&nbsp;</a></span>LLVMTypeConverter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LLVMTypeConverter::LLVMTypeConverter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DataLayoutAnalysis.html">DataLayoutAnalysis</a> *&#160;</td>
          <td class="paramname"><em>analysis</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classmlir_1_1LLVMTypeConverter.html" title="Conversion from types to the LLVM IR dialect.">LLVMTypeConverter</a> using the default <a class="el" href="classmlir_1_1LowerToLLVMOptions.html" title="Options to control the LLVM lowering.">LowerToLLVMOptions</a>. </p>
<p>Create an <a class="el" href="classmlir_1_1LLVMTypeConverter.html" title="Conversion from types to the LLVM IR dialect.">LLVMTypeConverter</a> using default <a class="el" href="classmlir_1_1LowerToLLVMOptions.html" title="Options to control the LLVM lowering.">LowerToLLVMOptions</a>.</p>
<p>Optionally takes a data layout analysis to use in conversions. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00043">43</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

</div>
</div>
<a id="aa0838be3560f61a0c13e8d39ff13f828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0838be3560f61a0c13e8d39ff13f828">&#9670;&nbsp;</a></span>LLVMTypeConverter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LLVMTypeConverter::LLVMTypeConverter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LowerToLLVMOptions.html">LowerToLLVMOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DataLayoutAnalysis.html">DataLayoutAnalysis</a> *&#160;</td>
          <td class="paramname"><em>analysis</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classmlir_1_1LLVMTypeConverter.html" title="Conversion from types to the LLVM IR dialect.">LLVMTypeConverter</a> using custom <a class="el" href="classmlir_1_1LowerToLLVMOptions.html" title="Options to control the LLVM lowering.">LowerToLLVMOptions</a>. </p>
<p>Optionally takes a data layout analysis to use in conversions. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00048">48</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00184">mlir::TypeConverter::addArgumentMaterialization()</a>, <a class="el" href="DialectConversion_8h_source.html#l00164">mlir::TypeConverter::addConversion()</a>, <a class="el" href="DialectConversion_8h_source.html#l00193">mlir::TypeConverter::addSourceMaterialization()</a>, <a class="el" href="DialectConversion_8h_source.html#l00201">mlir::TypeConverter::addTargetMaterialization()</a>, <a class="el" href="DialectConversion_8h_source.html#l00229">mlir::TypeConverter::addTypeAttributeConversion()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02921">convertType()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02977">mlir::TypeConverter::convertTypes()</a>, <a class="el" href="Builders_8cpp_source.html#l00446">mlir::OpBuilder::create()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00510">mlir::get()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00022">getCurrentThreadRecursiveStack()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00408">mlir::LLVM::LLVMStructType::getIdentified()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00436">mlir::LLVM::LLVMStructType::getLiteral()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00402">mlir::Operation::getResult()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00845">mlir::LLVM::isCompatibleType()</a>, <a class="el" href="TypeConverter_8h_source.html#l00152">llvmDialect</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00223">mlir::MemRefDescriptor::pack()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00329">mlir::UnrankedMemRefDescriptor::pack()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="add6a58ffa4a0f076c7e513d493c82fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add6a58ffa4a0f076c7e513d493c82fb3">&#9670;&nbsp;</a></span>canConvertToBarePtr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LLVMTypeConverter::canConvertToBarePtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a memref type can be converted to a bare pointer. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00444">444</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, and <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00807">mlir::getStridesAndOffset()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LowerGpuOpsToROCDLOps_8cpp_source.html#l00059">canBeCalledWithBarePointers()</a>.</p>

</div>
</div>
<a id="aa7ebcd548b2fb3f46bad15f6563786bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7ebcd548b2fb3f46bad15f6563786bf">&#9670;&nbsp;</a></span>convertCallingConventionType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> LLVMTypeConverter::convertCallingConventionType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useBarePtrCallConv</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a type in the context of the default or bare pointer calling convention. </p>
<p>Calling convention sensitive types, such as MemRefType and <a class="el" href="structUnrankedMemRefType.html">UnrankedMemRefType</a>, are converted following the specific rules for the calling convention. Calling convention independent types are converted following the default <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> type conversions. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00511">511</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l02921">convertType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeConverter_8cpp_source.html#l00665">mlir::barePtrFuncArgTypeConverter()</a>, and <a class="el" href="TypeConverter_8cpp_source.html#l00559">packFunctionResults()</a>.</p>

</div>
</div>
<a id="a53a134316f4850a9e646dc68e8376ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53a134316f4850a9e646dc68e8376ad9">&#9670;&nbsp;</a></span>convertFunctionSignature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> LLVMTypeConverter::convertFunctionSignature </td>
          <td>(</td>
          <td class="paramtype">FunctionType&#160;</td>
          <td class="paramname"><em>funcTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isVariadic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useBarePtrCallConv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter_1_1SignatureConversion.html">LLVMTypeConverter::SignatureConversion</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a function type. </p>
<p>The arguments and results are converted one by one and results are packed into a wrapped <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR structure type. <code>result</code> is populated with argument mapping. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00250">250</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l02892">mlir::TypeConverter::SignatureConversion::addInputs()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00665">mlir::barePtrFuncArgTypeConverter()</a>, <a class="el" href="Matchers_8h_source.html#l00285">mlir::detail::enumerate()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00510">mlir::get()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00203">getContext()</a>, <a class="el" href="DialectConversion_8h_source.html#l00073">mlir::TypeConverter::SignatureConversion::getConvertedTypes()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00559">packFunctionResults()</a>, <a class="el" href="classmlir_1_1LLVMTypeConverter.html#af9b34d77d5e460270f7b831c513dfe1b">structFuncArgTypeConverter</a>, and <a class="el" href="LoweringOptions_8h_source.html#l00035">mlir::LowerToLLVMOptions::useBarePtrCallConv</a>.</p>

<p class="reference">Referenced by <a class="el" href="FuncToLLVM_8cpp_source.html#l00322">mlir::convertFuncOpToLLVMFuncOp()</a>, and <a class="el" href="GPUOpsLowering_8cpp_source.html#l00023">mlir::GPUFuncOpLowering::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="ae85823fd715ae2b9b86c5857fb6d37cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae85823fd715ae2b9b86c5857fb6d37cc">&#9670;&nbsp;</a></span>convertFunctionTypeCWrapper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; LLVM::LLVMFunctionType, <a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html">LLVM::LLVMStructType</a> &gt; LLVMTypeConverter::convertFunctionTypeCWrapper </td>
          <td>(</td>
          <td class="paramtype">FunctionType&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the function type to a C-compatible format, in particular using pointers to memref descriptors for arguments. </p>
<p>Also converts the return type to a pointer argument if it is a struct. Returns true if this was the case. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00281">281</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l02921">convertType()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00510">mlir::get()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00203">getContext()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00845">mlir::LLVM::isCompatibleType()</a>, and <a class="el" href="TypeConverter_8cpp_source.html#l00559">packFunctionResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="FuncToLLVM_8cpp_source.html#l00180">wrapExternalFunction()</a>, and <a class="el" href="FuncToLLVM_8cpp_source.html#l00120">wrapForExternalCallers()</a>.</p>

</div>
</div>
<a id="a7c28856d7176c4af44f64906de33b6ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c28856d7176c4af44f64906de33b6ac">&#9670;&nbsp;</a></span>convertType() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> TypeConverter::convertType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This hook simplifies defining 1-1 type conversions. </p>
<p>This function returns the type to convert to on success, and a null type on failure. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l00242">242</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

</div>
</div>
<a id="a781dc5f696e4309ad385645a74295fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a781dc5f696e4309ad385645a74295fe0">&#9670;&nbsp;</a></span>convertType() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TargetType mlir::TypeConverter::convertType </td>
          <td>(</td>
          <td class="paramtype">typename TargetType&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts a 1-1 type conversion, expecting the result type to be <code>TargetType</code>. </p>
<p>Returns the converted type cast to <code>TargetType</code> on success, and a null type on conversion or cast failure. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8h_source.html#l00247">247</a> of file <a class="el" href="DialectConversion_8h_source.html">DialectConversion.h</a>.</p>

</div>
</div>
<a id="aad1fae4fc72123cef7302a93ba314c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad1fae4fc72123cef7302a93ba314c6a">&#9670;&nbsp;</a></span>convertType() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> TypeConverter::convertType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the given type. </p>
<p>This function should return failure if no valid conversion exists, success otherwise. If the new set of types is empty, the type is removed and any usages of the existing value are expected to be removed during conversion. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l00238">238</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SPIRVToLLVM_8cpp_source.html#l00157">broadcast()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00191">mlir::MemRefDescriptor::bufferPtr()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00511">convertCallingConventionType()</a>, <a class="el" href="FuncToLLVM_8cpp_source.html#l00322">mlir::convertFuncOpToLLVMFuncOp()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00281">convertFunctionTypeCWrapper()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00247">mlir::ConvertToLLVMPattern::copyUnrankedDescriptors()</a>, <a class="el" href="VectorPattern_8cpp_source.html#l00019">mlir::LLVM::detail::extractNDVectorTypeInfo()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00062">extractOne()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00049">mlir::MemRefDescriptor::fromStaticShape()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00102">getIndexedPtrs()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00077">getMemRefAlignment()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00045">insertOne()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00048">LLVMTypeConverter()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00023">mlir::GPUFuncOpLowering::matchAndRewrite()</a>, <a class="el" href="FuncToLLVM_8cpp_source.html#l00274">modifyFuncOpToUseBarePtrCallingConv()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00223">mlir::MemRefDescriptor::pack()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00329">mlir::UnrankedMemRefDescriptor::pack()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00538">packOperationResults()</a>, <a class="el" href="AMDGPUToROCDL_8cpp_source.html#l00825">mlir::populateAMDGPUToROCDLConversionPatterns()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00636">mlir::structFuncArgTypeConverter()</a>, <a class="el" href="FuncToLLVM_8cpp_source.html#l00180">wrapExternalFunction()</a>, and <a class="el" href="FuncToLLVM_8cpp_source.html#l00120">wrapForExternalCallers()</a>.</p>

</div>
</div>
<a id="ae1bae21dab08d18741a94aea9fa1b5be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1bae21dab08d18741a94aea9fa1b5be">&#9670;&nbsp;</a></span>getContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp; LLVMTypeConverter::getContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the MLIR context. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00203">203</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeConverter_8h_source.html#l00091">getDialect()</a>.</p>

<p class="reference">Referenced by <a class="el" href="GPUToLLVMConversion_8cpp_source.html#l01737">addOpaquePointerConversion()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00250">convertFunctionSignature()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00281">convertFunctionTypeCWrapper()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00022">getCurrentThreadRecursiveStack()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00207">getIndexType()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00559">packFunctionResults()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00538">packOperationResults()</a>, <a class="el" href="ArmSVE_2Transforms_2LegalizeForLLVMExport_8cpp_source.html#l00143">mlir::populateArmSVELegalizeForLLVMExportPatterns()</a>, <a class="el" href="GPUToLLVMConversion_8cpp_source.html#l01978">mlir::populateGpuToLLVMConversionPatterns()</a>, and <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html#l00325">mlir::populateGpuToNVVMConversionPatterns()</a>.</p>

</div>
</div>
<a id="a7c8883828a1c71ea23fd045d82e1eaa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c8883828a1c71ea23fd045d82e1eaa1">&#9670;&nbsp;</a></span>getCurrentThreadRecursiveStack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp; LLVMTypeConverter::getCurrentThreadRecursiveStack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00022">22</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeConverter_8h_source.html#l00157">callStackMutex</a>, <a class="el" href="TypeConverter_8h_source.html#l00156">conversionCallStack</a>, and <a class="el" href="TypeConverter_8cpp_source.html#l00203">getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeConverter_8cpp_source.html#l00048">LLVMTypeConverter()</a>.</p>

</div>
</div>
<a id="adcd53b4634b1a8d32cebcce2e47fb8eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcd53b4634b1a8d32cebcce2e47fb8eb">&#9670;&nbsp;</a></span>getDataLayout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const llvm::DataLayout&amp; mlir::LLVMTypeConverter::getDataLayout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the data layout to use during and after conversion. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8h_source.html#l00117">117</a> of file <a class="el" href="TypeConverter_8h_source.html">TypeConverter.h</a>.</p>

<p class="reference">References <a class="el" href="LoweringOptions_8h_source.html#l00056">mlir::LowerToLLVMOptions::dataLayout</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00077">getMemRefAlignment()</a>.</p>

</div>
</div>
<a id="a5e5617fe390dff357f3e9e39f9ed9e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e5617fe390dff357f3e9e39f9ed9e38">&#9670;&nbsp;</a></span>getDataLayoutAnalysis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmlir_1_1DataLayoutAnalysis.html">DataLayoutAnalysis</a>* mlir::LLVMTypeConverter::getDataLayoutAnalysis </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the data layout analysis to query during conversion. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8h_source.html#l00120">120</a> of file <a class="el" href="TypeConverter_8h_source.html">TypeConverter.h</a>.</p>

</div>
</div>
<a id="a1fef25eab0df64af252d7d14c4a0caec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fef25eab0df64af252d7d14c4a0caec">&#9670;&nbsp;</a></span>getDialect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LLVM::LLVMDialect* mlir::LLVMTypeConverter::getDialect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8h_source.html#l00091">91</a> of file <a class="el" href="TypeConverter_8h_source.html">TypeConverter.h</a>.</p>

<p class="reference">References <a class="el" href="TypeConverter_8h_source.html#l00152">llvmDialect</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeConverter_8cpp_source.html#l00203">getContext()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00032">mlir::ConvertToLLVMPattern::getDialect()</a>, and <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l01737">mlir::populateVectorToLLVMConversionPatterns()</a>.</p>

</div>
</div>
<a id="aeee2f27593c07c2c8e3bf8195252b1a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeee2f27593c07c2c8e3bf8195252b1a8">&#9670;&nbsp;</a></span>getIndexType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> LLVMTypeConverter::getIndexType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> representation of the index type. </p>
<p>The returned type is an integer type with the size configured for this type converter. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00207">207</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00510">mlir::get()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00203">getContext()</a>, and <a class="el" href="TypeConverter_8h_source.html#l00129">getIndexTypeBitwidth()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefBuilder_8cpp_source.html#l00191">mlir::MemRefDescriptor::bufferPtr()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00352">mlir::UnrankedMemRefDescriptor::computeSizes()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00247">mlir::ConvertToLLVMPattern::copyUnrankedDescriptors()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00036">mlir::ConvertToLLVMPattern::getIndexType()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00380">getMemRefDescriptorSize()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00412">getUnrankedMemRefDescriptorSize()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00453">mlir::UnrankedMemRefDescriptor::offset()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00496">mlir::UnrankedMemRefDescriptor::setSize()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00529">mlir::UnrankedMemRefDescriptor::setStride()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00484">mlir::UnrankedMemRefDescriptor::size()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00473">mlir::UnrankedMemRefDescriptor::sizeBasePtr()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00517">mlir::UnrankedMemRefDescriptor::stride()</a>, and <a class="el" href="MemRefBuilder_8cpp_source.html#l00508">mlir::UnrankedMemRefDescriptor::strideBasePtr()</a>.</p>

</div>
</div>
<a id="ae91b3adee39d4b558df51642b88890ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae91b3adee39d4b558df51642b88890ae">&#9670;&nbsp;</a></span>getIndexTypeBitwidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::LLVMTypeConverter::getIndexTypeBitwidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the bitwidth of the index type when converted to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8h_source.html#l00129">129</a> of file <a class="el" href="TypeConverter_8h_source.html">TypeConverter.h</a>.</p>

<p class="reference">References <a class="el" href="LoweringOptions_8h_source.html#l00066">mlir::LowerToLLVMOptions::getIndexBitwidth()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefBuilder_8cpp_source.html#l00352">mlir::UnrankedMemRefDescriptor::computeSizes()</a>, and <a class="el" href="TypeConverter_8cpp_source.html#l00207">getIndexType()</a>.</p>

</div>
</div>
<a id="ac8f665228b7d8d25949296df8e80cb19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f665228b7d8d25949296df8e80cb19">&#9670;&nbsp;</a></span>getMemRefAddressSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; unsigned &gt; LLVMTypeConverter::getMemRefAddressSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> address space corresponding to the memory space of the memref type <code>type</code> or failure if the memory space cannot be converted to an integer. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00429">429</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l03081">mlir::TypeConverter::convertTypeAttribute()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, and <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00395">mlir::BaseMemRefType::getMemorySpace()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AllocLikeConversion_8cpp_source.html#l00053">castAllocFuncResult()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00247">mlir::ConvertToLLVMPattern::copyUnrankedDescriptors()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00107">mlir::ConvertToLLVMPattern::getElementPtrType()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00380">getMemRefDescriptorSize()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00412">getUnrankedMemRefDescriptorSize()</a>, and <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00092">isMemRefTypeSupported()</a>.</p>

</div>
</div>
<a id="ae5bdd0b0c1b8f4b7ce1f7504a5673e58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5bdd0b0c1b8f4b7ce1f7504a5673e58">&#9670;&nbsp;</a></span>getMemRefDescriptorSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned LLVMTypeConverter::getMemRefDescriptorSize </td>
          <td>(</td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of the memref descriptor object in bytes. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00380">380</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00361">mlir::detail::divideCeil()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00207">getIndexType()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00429">getMemRefAddressSpace()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00211">getPointerBitwidth()</a>, and <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00449">mlir::DataLayout::getTypeSize()</a>.</p>

</div>
</div>
<a id="a48f142ecd8d10e44d253307880715607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48f142ecd8d10e44d253307880715607">&#9670;&nbsp;</a></span>getOptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmlir_1_1LowerToLLVMOptions.html">LowerToLLVMOptions</a>&amp; mlir::LLVMTypeConverter::getOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TypeConverter_8h_source.html#l00093">93</a> of file <a class="el" href="TypeConverter_8h_source.html">TypeConverter.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefToLLVM_8cpp_source.html#l01655">mlir::populateFinalizeMemRefToLLVMConversionPatterns()</a>.</p>

</div>
</div>
<a id="ac3faa948105d0db2cd0b26f7ae3920fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3faa948105d0db2cd0b26f7ae3920fa">&#9670;&nbsp;</a></span>getPointerBitwidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned LLVMTypeConverter::getPointerBitwidth </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>addressSpace</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the pointer bitwidth. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00211">211</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoweringOptions_8h_source.html#l00056">mlir::LowerToLLVMOptions::dataLayout</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefBuilder_8cpp_source.html#l00352">mlir::UnrankedMemRefDescriptor::computeSizes()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00380">getMemRefDescriptorSize()</a>, and <a class="el" href="TypeConverter_8cpp_source.html#l00412">getUnrankedMemRefDescriptorSize()</a>.</p>

</div>
</div>
<a id="a5026b6f13d12445a8d60b3c9184aa904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5026b6f13d12445a8d60b3c9184aa904">&#9670;&nbsp;</a></span>getUnrankedMemRefDescriptorSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned LLVMTypeConverter::getUnrankedMemRefDescriptorSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUnrankedMemRefType.html">UnrankedMemRefType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of the unranked memref descriptor object in bytes. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00412">412</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00361">mlir::detail::divideCeil()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00207">getIndexType()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00429">getMemRefAddressSpace()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00211">getPointerBitwidth()</a>, and <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00449">mlir::DataLayout::getTypeSize()</a>.</p>

</div>
</div>
<a id="a285f908311d50945ff0d644ad3beaee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a285f908311d50945ff0d644ad3beaee7">&#9670;&nbsp;</a></span>packFunctionResults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> LLVMTypeConverter::packFunctionResults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useBarePtrCallConv</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a non-empty list of types to be returned from a function into an LLVM-compatible type. </p>
<p>In particular, if more than one value is returned, create an <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect structure type with elements that correspond to each of the types converted with <code>convertCallingConventionType</code>. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00559">559</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeConverter_8cpp_source.html#l00511">convertCallingConventionType()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00203">getContext()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00436">mlir::LLVM::LLVMStructType::getLiteral()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00845">mlir::LLVM::isCompatibleType()</a>, and <a class="el" href="LoweringOptions_8h_source.html#l00035">mlir::LowerToLLVMOptions::useBarePtrCallConv</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeConverter_8cpp_source.html#l00250">convertFunctionSignature()</a>, and <a class="el" href="TypeConverter_8cpp_source.html#l00281">convertFunctionTypeCWrapper()</a>.</p>

</div>
</div>
<a id="a10b2654ba7a875df2dd830288792934c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10b2654ba7a875df2dd830288792934c">&#9670;&nbsp;</a></span>packOperationResults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> LLVMTypeConverter::packOperationResults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>types</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a non-empty list of types of values produced by an operation into an LLVM-compatible type. </p>
<p>In particular, if more than one value is produced, create a literal structure with elements that correspond to each of the LLVM-compatible types converted with <code>convertType</code>.</p>
<p>In particular, if more than one value is produced, create a literal structure with elements that correspond to each of the types converted with <code>convertType</code>. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00538">538</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l02921">convertType()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00203">getContext()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00436">mlir::LLVM::LLVMStructType::getLiteral()</a>, and <a class="el" href="LLVMTypes_8cpp_source.html#l00845">mlir::LLVM::isCompatibleType()</a>.</p>

</div>
</div>
<a id="a5d31697177d4412398c4c9a114cdb2f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d31697177d4412398c4c9a114cdb2f0">&#9670;&nbsp;</a></span>promoteBarePtrsToDescriptors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LLVMTypeConverter::promoteBarePtrsToDescriptors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionPatternRewriter.html">ConversionPatternRewriter</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt;&#160;</td>
          <td class="paramname"><em>stdTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Promote the bare pointers in 'values' that resulted from memrefs to descriptors. </p>
<p>'stdTypes' holds the types of 'values' before the conversion to the LLVM-IR dialect (i.e., MemRefType, or any other builtin type).</p>
<p>'stdTypes' holds they types of 'values' before the conversion to the LLVM-IR dialect (i.e., MemRefType, or any other builtin type). </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00523">523</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="MemRefBuilder_8cpp_source.html#l00043">mlir::MemRefDescriptor::fromStaticShape()</a>.</p>

</div>
</div>
<a id="a9a0d71d9f3b2bab702e475f6890ed4a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a0d71d9f3b2bab702e475f6890ed4a1">&#9670;&nbsp;</a></span>promoteOneMemRefDescriptor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> LLVMTypeConverter::promoteOneMemRefDescriptor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>operand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Promote the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> struct representation of one MemRef descriptor to stack and use pointer to struct to avoid the complexity of the platform-specific C/C++ ABI lowering related to struct argument passing. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00579">579</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00446">mlir::OpBuilder::create()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00510">mlir::get()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, <a class="el" href="Builders_8cpp_source.html#l00085">mlir::Builder::getI64Type()</a>, <a class="el" href="Builders_8cpp_source.html#l00124">mlir::Builder::getIndexAttr()</a>, and <a class="el" href="Value_8h_source.html#l00125">mlir::Value::getType()</a>.</p>

</div>
</div>
<a id="ab77513f669fae3497ae34732244ac6b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab77513f669fae3497ae34732244ac6b9">&#9670;&nbsp;</a></span>promoteOperands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 4 &gt; LLVMTypeConverter::promoteOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>opOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useBarePtrCallConv</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Promote the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> representation of all operands including promoting MemRef descriptors to stack and use pointers to struct to avoid the complexity of the platform-specific C/C++ ABI lowering related to struct argument passing. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00594">594</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="MemRefBuilder_8cpp_source.html#l00088">mlir::MemRefDescriptor::alignedPtr()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00244">mlir::MemRefDescriptor::unpack()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00343">mlir::UnrankedMemRefDescriptor::unpack()</a>, and <a class="el" href="LoweringOptions_8h_source.html#l00035">mlir::LowerToLLVMOptions::useBarePtrCallConv</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="af9b34d77d5e460270f7b831c513dfe1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b34d77d5e460270f7b831c513dfe1b">&#9670;&nbsp;</a></span>structFuncArgTypeConverter</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> structFuncArgTypeConverter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Give structFuncArgTypeConverter access to memref-specific functions. </p>
<p>It converts a MemRef function argument to a list of non-aggregate types containing descriptor information, and an UnrankedmemRef function argument to a list containing the rank and a pointer to a descriptor struct. </p>

<p class="reference">Referenced by <a class="el" href="TypeConverter_8cpp_source.html#l00250">convertFunctionSignature()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a0a8ba63d13409bf975cd862683e071a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a8ba63d13409bf975cd862683e071a8">&#9670;&nbsp;</a></span>callStackMutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::sys::SmartRWMutex&lt;true&gt; mlir::LLVMTypeConverter::callStackMutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TypeConverter_8h_source.html#l00157">157</a> of file <a class="el" href="TypeConverter_8h_source.html">TypeConverter.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeConverter_8cpp_source.html#l00022">getCurrentThreadRecursiveStack()</a>.</p>

</div>
</div>
<a id="a7466ae2ed9e33d91b625d076c4dc517d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7466ae2ed9e33d91b625d076c4dc517d">&#9670;&nbsp;</a></span>conversionCallStack</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt;uint64_t, std::unique_ptr&lt;<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Type.html">Type</a>&gt; &gt; &gt; mlir::LLVMTypeConverter::conversionCallStack</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TypeConverter_8h_source.html#l00156">156</a> of file <a class="el" href="TypeConverter_8h_source.html">TypeConverter.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeConverter_8cpp_source.html#l00022">getCurrentThreadRecursiveStack()</a>.</p>

</div>
</div>
<a id="a0034100981a301427abe8367c89ef6a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0034100981a301427abe8367c89ef6a3">&#9670;&nbsp;</a></span>llvmDialect</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LLVM::LLVMDialect* mlir::LLVMTypeConverter::llvmDialect</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8h_source.html#l00152">152</a> of file <a class="el" href="TypeConverter_8h_source.html">TypeConverter.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeConverter_8h_source.html#l00091">getDialect()</a>, and <a class="el" href="TypeConverter_8cpp_source.html#l00048">LLVMTypeConverter()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/mlir/Conversion/LLVMCommon/<a class="el" href="TypeConverter_8h_source.html">TypeConverter.h</a></li>
<li>lib/Conversion/LLVMCommon/<a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Dec 9 2023 02:40:35 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
