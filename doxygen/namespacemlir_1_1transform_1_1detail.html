<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::transform::detail Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">18.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1transform.html">transform</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1transform_1_1detail.html">detail</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mlir::transform::detail Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1transform_1_1detail_1_1TransformDialectDataBase.html">TransformDialectDataBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete base class for CRTP <a class="el" href="classmlir_1_1transform_1_1detail_1_1TransformDialectDataBase.html" title="Concrete base class for CRTP TransformDialectDataBase.">TransformDialectDataBase</a>.  <a href="classmlir_1_1transform_1_1detail_1_1TransformDialectDataBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab49efa35a55e8224a1ad36d69d6198c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1transform_1_1detail.html#ab49efa35a55e8224a1ad36d69d6198c9">verifyStructuredOpPredicateOpTrait</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1Value.html">Value</a> structuredOpHandle)</td></tr>
<tr class="separator:ab49efa35a55e8224a1ad36d69d6198c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accfe7c2cf4c9692e48bfb28f0fb39b9b"><td class="memTemplParams" colspan="2">template&lt;typename OpTy &gt; </td></tr>
<tr class="memitem:accfe7c2cf4c9692e48bfb28f0fb39b9b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DiagnosedSilenceableFailure.html">DiagnosedSilenceableFailure</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1transform_1_1detail.html#accfe7c2cf4c9692e48bfb28f0fb39b9b">matchOptionalOperation</a> (OpTy op, <a class="el" href="classmlir_1_1transform_1_1TransformResults.html">TransformResults</a> &amp;results, <a class="el" href="classmlir_1_1transform_1_1TransformState.html">TransformState</a> &amp;state)</td></tr>
<tr class="memdesc:accfe7c2cf4c9692e48bfb28f0fb39b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch <code>matchOperation</code> based on Operation* or std::optional&lt;Operation*&gt; first operand.  <a href="namespacemlir_1_1transform_1_1detail.html#accfe7c2cf4c9692e48bfb28f0fb39b9b">More...</a><br /></td></tr>
<tr class="separator:accfe7c2cf4c9692e48bfb28f0fb39b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac972c3c018134f06d3406b1237310cbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1transform_1_1detail.html#ac972c3c018134f06d3406b1237310cbb">checkImplementsTransformOpInterface</a> (StringRef name, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:ac972c3c018134f06d3406b1237310cbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asserts that the operations provided as template arguments implement the TransformOpInterface and MemoryEffectsOpInterface.  <a href="namespacemlir_1_1transform_1_1detail.html#ac972c3c018134f06d3406b1237310cbb">More...</a><br /></td></tr>
<tr class="separator:ac972c3c018134f06d3406b1237310cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66abffa78647df1f7e48d10ed3c5eeec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1transform_1_1detail.html#a66abffa78647df1f7e48d10ed3c5eeec">checkImplementsTransformHandleTypeInterface</a> (<a class="el" href="classmlir_1_1TypeID.html">TypeID</a> typeID, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a66abffa78647df1f7e48d10ed3c5eeec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asserts that the type provided as template argument implements the TransformHandleTypeInterface.  <a href="namespacemlir_1_1transform_1_1detail.html#a66abffa78647df1f7e48d10ed3c5eeec">More...</a><br /></td></tr>
<tr class="separator:a66abffa78647df1f7e48d10ed3c5eeec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97376b0a911f5a44f05410e33d7fe30e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1transform_1_1detail.html#a97376b0a911f5a44f05410e33d7fe30e">mapPossibleTopLevelTransformOpBlockArguments</a> (<a class="el" href="classmlir_1_1transform_1_1TransformState.html">TransformState</a> &amp;state, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region)</td></tr>
<tr class="memdesc:a97376b0a911f5a44f05410e33d7fe30e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps the only block argument of the op with <a class="el" href="classmlir_1_1transform_1_1PossibleTopLevelTransformOpTrait.html" title="This trait is supposed to be attached to Transform dialect operations that can be standalone top-leve...">PossibleTopLevelTransformOpTrait</a> to either the list of operations associated with its operand or the root of the payload IR, depending on what is available in the context.  <a href="namespacemlir_1_1transform_1_1detail.html#a97376b0a911f5a44f05410e33d7fe30e">More...</a><br /></td></tr>
<tr class="separator:a97376b0a911f5a44f05410e33d7fe30e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af472e3604dc87e29966aba3b81c0a5fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1transform_1_1detail.html#af472e3604dc87e29966aba3b81c0a5fb">verifyPossibleTopLevelTransformOpTrait</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:af472e3604dc87e29966aba3b81c0a5fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verification hook for <a class="el" href="classmlir_1_1transform_1_1PossibleTopLevelTransformOpTrait.html" title="This trait is supposed to be attached to Transform dialect operations that can be standalone top-leve...">PossibleTopLevelTransformOpTrait</a>.  <a href="namespacemlir_1_1transform_1_1detail.html#af472e3604dc87e29966aba3b81c0a5fb">More...</a><br /></td></tr>
<tr class="separator:af472e3604dc87e29966aba3b81c0a5fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc8c491c51ccdf3437db9ee7486b083a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1transform_1_1detail.html#afc8c491c51ccdf3437db9ee7486b083a">getPotentialTopLevelEffects</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *operation, <a class="el" href="classmlir_1_1Value.html">Value</a> root, <a class="el" href="classmlir_1_1Block.html">Block</a> &amp;body, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="namespacemlir_1_1MemoryEffects.html#ac845c307c34161d9e9c0c1a0287c9664">MemoryEffects::EffectInstance</a> &gt; &amp;effects)</td></tr>
<tr class="memdesc:afc8c491c51ccdf3437db9ee7486b083a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <code>effects</code> with side effects implied by <a class="el" href="classmlir_1_1transform_1_1PossibleTopLevelTransformOpTrait.html" title="This trait is supposed to be attached to Transform dialect operations that can be standalone top-leve...">PossibleTopLevelTransformOpTrait</a> for the given operation.  <a href="namespacemlir_1_1transform_1_1detail.html#afc8c491c51ccdf3437db9ee7486b083a">More...</a><br /></td></tr>
<tr class="separator:afc8c491c51ccdf3437db9ee7486b083a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d70b4f0eb6e462437d65f2d7567055"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1transform_1_1detail.html#a08d70b4f0eb6e462437d65f2d7567055">verifyTransformOpInterface</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a08d70b4f0eb6e462437d65f2d7567055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verification hook for TransformOpInterface.  <a href="namespacemlir_1_1transform_1_1detail.html#a08d70b4f0eb6e462437d65f2d7567055">More...</a><br /></td></tr>
<tr class="separator:a08d70b4f0eb6e462437d65f2d7567055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6bed67cf9bef6f84934753a04d80eed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1transform_1_1detail.html#ab6bed67cf9bef6f84934753a04d80eed">prepareValueMappings</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir_1_1transform.html#af0fc847d51f4b4097c66b8b50b09c60c">transform::MappedValue</a> &gt;&gt; &amp;mappings, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> values, const <a class="el" href="classmlir_1_1transform_1_1TransformState.html">transform::TransformState</a> &amp;state)</td></tr>
<tr class="memdesc:ab6bed67cf9bef6f84934753a04d80eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <code>mappings</code> with mapped values associated with the given transform IR values in the given <code>state</code>.  <a href="namespacemlir_1_1transform_1_1detail.html#ab6bed67cf9bef6f84934753a04d80eed">More...</a><br /></td></tr>
<tr class="separator:ab6bed67cf9bef6f84934753a04d80eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d536d06d24d9780714574520f14e25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1transform_1_1detail.html#a81d536d06d24d9780714574520f14e25">forwardTerminatorOperands</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *block, <a class="el" href="classmlir_1_1transform_1_1TransformState.html">transform::TransformState</a> &amp;state, <a class="el" href="classmlir_1_1transform_1_1TransformResults.html">transform::TransformResults</a> &amp;results)</td></tr>
<tr class="memdesc:a81d536d06d24d9780714574520f14e25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <code>results</code> with payload associations that match exactly those of the operands to <code>block</code>'s terminator.  <a href="namespacemlir_1_1transform_1_1detail.html#a81d536d06d24d9780714574520f14e25">More...</a><br /></td></tr>
<tr class="separator:a81d536d06d24d9780714574520f14e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c029c6849c69a0f311170959ae70966"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1transform_1_1TransformState.html">TransformState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1transform_1_1detail.html#a9c029c6849c69a0f311170959ae70966">makeTransformStateForTesting</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> *region, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *payloadRoot)</td></tr>
<tr class="memdesc:a9c029c6849c69a0f311170959ae70966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a dummy transform state for testing purposes.  <a href="namespacemlir_1_1transform_1_1detail.html#a9c029c6849c69a0f311170959ae70966">More...</a><br /></td></tr>
<tr class="separator:a9c029c6849c69a0f311170959ae70966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe281daf80785933afa0acad9fef1c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1transform_1_1detail.html#aabe281daf80785933afa0acad9fef1c7">getConsumedHandleOpOperands</a> (transform::TransformOpInterface transformOp)</td></tr>
<tr class="memdesc:aabe281daf80785933afa0acad9fef1c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all operands that are handles and being consumed by the given op.  <a href="namespacemlir_1_1transform_1_1detail.html#aabe281daf80785933afa0acad9fef1c7">More...</a><br /></td></tr>
<tr class="separator:aabe281daf80785933afa0acad9fef1c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c4853c22618926e8e9f6505afcdff9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1transform_1_1detail.html#a8c4853c22618926e8e9f6505afcdff9d">getParamProducerTransformOpTraitEffects</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="namespacemlir_1_1MemoryEffects.html#ac845c307c34161d9e9c0c1a0287c9664">MemoryEffects::EffectInstance</a> &gt; &amp;effects)</td></tr>
<tr class="memdesc:a8c4853c22618926e8e9f6505afcdff9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-template implementation of <a class="el" href="classmlir_1_1transform_1_1ParamProducerTransformOpTrait.html#ad3321e39e0c4a2102e0ab54da46788c7" title="Populates effects with effect instances described in the trait documentation.">ParamProducerTransformOpTrait::getEffects()</a>.  <a href="namespacemlir_1_1transform_1_1detail.html#a8c4853c22618926e8e9f6505afcdff9d">More...</a><br /></td></tr>
<tr class="separator:a8c4853c22618926e8e9f6505afcdff9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad39ec48980e7ee4339642e7e286d304"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1transform_1_1detail.html#aad39ec48980e7ee4339642e7e286d304">verifyParamProducerTransformOpTrait</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:aad39ec48980e7ee4339642e7e286d304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-template implementation of <a class="el" href="namespacemlir.html#ae4b1ba650fd43b50351e92bbb75bd4c0" title="Perform (potentially expensive) checks of invariants, used to detect compiler bugs,...">ParamProducerTransformOpTrait::verify()</a>.  <a href="namespacemlir_1_1transform_1_1detail.html#aad39ec48980e7ee4339642e7e286d304">More...</a><br /></td></tr>
<tr class="separator:aad39ec48980e7ee4339642e7e286d304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f9cf3218ac160aecacfbdee04aa56b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1transform_1_1detail.html#aa8f9cf3218ac160aecacfbdee04aa56b">checkApplyToOne</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *transformOp, <a class="el" href="classmlir_1_1Location.html">Location</a> payloadOpLoc, const <a class="el" href="classmlir_1_1transform_1_1ApplyToEachResultList.html">ApplyToEachResultList</a> &amp;partialResult)</td></tr>
<tr class="memdesc:aa8f9cf3218ac160aecacfbdee04aa56b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the contents of <code>partialResult</code> matches the number, kind (payload op or parameter) and nullity (either all or none) requirements of <code>transformOp</code>.  <a href="namespacemlir_1_1transform_1_1detail.html#aa8f9cf3218ac160aecacfbdee04aa56b">More...</a><br /></td></tr>
<tr class="separator:aa8f9cf3218ac160aecacfbdee04aa56b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b899140fcc90aabc5b221816337cc4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1transform_1_1detail.html#a7b899140fcc90aabc5b221816337cc4d">setApplyToOneResults</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *transformOp, <a class="el" href="classmlir_1_1transform_1_1TransformResults.html">TransformResults</a> &amp;transformResults, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1transform_1_1ApplyToEachResultList.html">ApplyToEachResultList</a> &gt; results)</td></tr>
<tr class="memdesc:a7b899140fcc90aabc5b221816337cc4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Transpose" the results produced by individual applications, arranging them per result value of the transform op, and populate <code>transformResults</code> with that.  <a href="namespacemlir_1_1transform_1_1detail.html#a7b899140fcc90aabc5b221816337cc4d">More...</a><br /></td></tr>
<tr class="separator:a7b899140fcc90aabc5b221816337cc4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3bcac37879d4e8c9c4c178600aa017"><td class="memTemplParams" colspan="2">template&lt;typename TransformOpTy , typename Range &gt; </td></tr>
<tr class="memitem:afb3bcac37879d4e8c9c4c178600aa017"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DiagnosedSilenceableFailure.html">DiagnosedSilenceableFailure</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1transform_1_1detail.html#afb3bcac37879d4e8c9c4c178600aa017">applyTransformToEach</a> (TransformOpTy transformOp, <a class="el" href="classmlir_1_1transform_1_1TransformRewriter.html">TransformRewriter</a> &amp;rewriter, <a class="el" href="structmlir_1_1Range.html">Range</a> &amp;&amp;targets, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1transform_1_1ApplyToEachResultList.html">ApplyToEachResultList</a> &gt; &amp;results, <a class="el" href="classmlir_1_1transform_1_1TransformState.html">TransformState</a> &amp;state)</td></tr>
<tr class="memdesc:afb3bcac37879d4e8c9c4c178600aa017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a one-to-one or a one-to-many transform to each of the given targets.  <a href="namespacemlir_1_1transform_1_1detail.html#afb3bcac37879d4e8c9c4c178600aa017">More...</a><br /></td></tr>
<tr class="separator:afb3bcac37879d4e8c9c4c178600aa017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee541c7d80632f563472fe99ba8e684"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1transform_1_1detail.html#a8ee541c7d80632f563472fe99ba8e684">checkNestedConsumption</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; targets)</td></tr>
<tr class="memdesc:a8ee541c7d80632f563472fe99ba8e684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports an error and returns failure if <code>targets</code> contains an ancestor operation before its descendant (or a copy of itself).  <a href="namespacemlir_1_1transform_1_1detail.html#a8ee541c7d80632f563472fe99ba8e684">More...</a><br /></td></tr>
<tr class="separator:a8ee541c7d80632f563472fe99ba8e684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b901961a14a54c8a5ce44fbc17e61e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1transform_1_1detail.html#a4b901961a14a54c8a5ce44fbc17e61e6">mergeSymbolsInto</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *target, <a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; other)</td></tr>
<tr class="memdesc:a4b901961a14a54c8a5ce44fbc17e61e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge all symbols from <code>other</code> into <code>target</code>.  <a href="namespacemlir_1_1transform_1_1detail.html#a4b901961a14a54c8a5ce44fbc17e61e6">More...</a><br /></td></tr>
<tr class="separator:a4b901961a14a54c8a5ce44fbc17e61e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af2d34af5df614b30850abce6463789"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1transform_1_1detail.html#a1af2d34af5df614b30850abce6463789">interpreterBaseInitializeImpl</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, StringRef transformFileName, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::string &gt; transformLibraryPaths, std::shared_ptr&lt; <a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ModuleOp &gt;&gt; &amp;module, std::shared_ptr&lt; <a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ModuleOp &gt;&gt; &amp;libraryModule, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; std::optional&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> &gt;(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>)&gt; moduleBuilder=nullptr)</td></tr>
<tr class="memdesc:a1af2d34af5df614b30850abce6463789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template-free implementation of <a class="el" href="classmlir_1_1transform_1_1TransformInterpreterPassBase.html#aa461c75a4b89143286fe10b41cfca7bd">TransformInterpreterPassBase::initialize</a>.  <a href="namespacemlir_1_1transform_1_1detail.html#a1af2d34af5df614b30850abce6463789">More...</a><br /></td></tr>
<tr class="separator:a1af2d34af5df614b30850abce6463789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a5dbbdaf56120611983c48bcbe2757"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1transform_1_1detail.html#a42a5dbbdaf56120611983c48bcbe2757">interpreterBaseRunOnOperationImpl</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *target, StringRef passName, const std::shared_ptr&lt; <a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ModuleOp &gt;&gt; &amp;sharedTransformModule, const std::shared_ptr&lt; <a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ModuleOp &gt;&gt; &amp;libraryModule, const <a class="el" href="classmlir_1_1RaggedArray.html">RaggedArray</a>&lt; <a class="el" href="namespacemlir_1_1transform.html#af0fc847d51f4b4097c66b8b50b09c60c">MappedValue</a> &gt; &amp;extraMappings, const <a class="el" href="classmlir_1_1transform_1_1TransformOptions.html">TransformOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, const <a class="el" href="structmlir_1_1Pass_1_1Option.html">Pass::Option</a>&lt; std::string &gt; &amp;transformFileName, const <a class="el" href="structmlir_1_1Pass_1_1ListOption.html">Pass::ListOption</a>&lt; std::string &gt; &amp;transformLibraryPaths, const <a class="el" href="structmlir_1_1Pass_1_1Option.html">Pass::Option</a>&lt; std::string &gt; &amp;debugPayloadRootTag, const <a class="el" href="structmlir_1_1Pass_1_1Option.html">Pass::Option</a>&lt; std::string &gt; &amp;debugTransformRootTag, StringRef binaryName)</td></tr>
<tr class="memdesc:a42a5dbbdaf56120611983c48bcbe2757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template-free implementation of <a class="el" href="classmlir_1_1transform_1_1TransformInterpreterPassBase.html#a7aec0111a496becc8499f5d833d23045">TransformInterpreterPassBase::runOnOperation</a>.  <a href="namespacemlir_1_1transform_1_1detail.html#a42a5dbbdaf56120611983c48bcbe2757">More...</a><br /></td></tr>
<tr class="separator:a42a5dbbdaf56120611983c48bcbe2757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6312474ea1986d03c2788246b215e70e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1transform_1_1detail.html#a6312474ea1986d03c2788246b215e70e">expandPathsToMLIRFiles</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::string &gt; paths, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; std::string &gt; &amp;fileNames)</td></tr>
<tr class="memdesc:a6312474ea1986d03c2788246b215e70e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expands the given list of <code>paths</code> to a list of <code>.mlir</code> files.  <a href="namespacemlir_1_1transform_1_1detail.html#a6312474ea1986d03c2788246b215e70e">More...</a><br /></td></tr>
<tr class="separator:a6312474ea1986d03c2788246b215e70e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e51908acb17379cdee600e5d14eb504"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1transform_1_1detail.html#a1e51908acb17379cdee600e5d14eb504">parseTransformModuleFromFile</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, llvm::StringRef transformFileName, <a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ModuleOp &gt; &amp;transformModule)</td></tr>
<tr class="memdesc:a1e51908acb17379cdee600e5d14eb504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility to parse and verify the content of a <code>transformFileName</code> MLIR file containing a transform dialect specification.  <a href="namespacemlir_1_1transform_1_1detail.html#a1e51908acb17379cdee600e5d14eb504">More...</a><br /></td></tr>
<tr class="separator:a1e51908acb17379cdee600e5d14eb504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff3c0c4abf23c806d81a4897c638fa8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1transform_1_1detail.html#a0ff3c0c4abf23c806d81a4897c638fa8">assembleTransformLibraryFromPaths</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::string &gt; transformLibraryPaths, <a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ModuleOp &gt; &amp;transformModule)</td></tr>
<tr class="memdesc:a0ff3c0c4abf23c806d81a4897c638fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility to parse, verify, aggregate and link the content of all mlir files nested under <code>transformLibraryPaths</code> and containing transform dialect specifications.  <a href="namespacemlir_1_1transform_1_1detail.html#a0ff3c0c4abf23c806d81a4897c638fa8">More...</a><br /></td></tr>
<tr class="separator:a0ff3c0c4abf23c806d81a4897c638fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2413cdd0547cc80c81350234f5b76e43"><td class="memItemLeft" align="right" valign="top">ModuleOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1transform_1_1detail.html#a2413cdd0547cc80c81350234f5b76e43">getPreloadedTransformModule</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a2413cdd0547cc80c81350234f5b76e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility to load a transform interpreter <code>module</code> from a module that has already been preloaded in the context.  <a href="namespacemlir_1_1transform_1_1detail.html#a2413cdd0547cc80c81350234f5b76e43">More...</a><br /></td></tr>
<tr class="separator:a2413cdd0547cc80c81350234f5b76e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e95146317beb53f05b36c2d9d7a4267"><td class="memItemLeft" align="right" valign="top">TransformOpInterface&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1transform_1_1detail.html#a8e95146317beb53f05b36c2d9d7a4267">findTransformEntryPoint</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *root, ModuleOp module, StringRef entryPoint=TransformDialect::kTransformEntryPointSymbolName)</td></tr>
<tr class="memdesc:a8e95146317beb53f05b36c2d9d7a4267"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first TransformOpInterface named <code>kTransformEntryPointSymbolName</code> that is either:  <a href="namespacemlir_1_1transform_1_1detail.html#a8e95146317beb53f05b36c2d9d7a4267">More...</a><br /></td></tr>
<tr class="separator:a8e95146317beb53f05b36c2d9d7a4267"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="afb3bcac37879d4e8c9c4c178600aa017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb3bcac37879d4e8c9c4c178600aa017">&#9670;&nbsp;</a></span>applyTransformToEach()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TransformOpTy , typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DiagnosedSilenceableFailure.html">DiagnosedSilenceableFailure</a> mlir::transform::detail::applyTransformToEach </td>
          <td>(</td>
          <td class="paramtype">TransformOpTy&#160;</td>
          <td class="paramname"><em>transformOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1transform_1_1TransformRewriter.html">TransformRewriter</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1Range.html">Range</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>targets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1transform_1_1ApplyToEachResultList.html">ApplyToEachResultList</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1transform_1_1TransformState.html">TransformState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a one-to-one or a one-to-many transform to each of the given targets. </p>
<p>Puts the results of transforms, if any, in <code>results</code> in the same order. Fails if any of the application fails. Individual transforms must be callable with the following signature:</p><ul>
<li><a class="el" href="classmlir_1_1DiagnosedSilenceableFailure.html" title="The result of a transform IR operation application.">DiagnosedSilenceableFailure</a>(OpTy, SmallVector&lt;Operation*&gt; &amp;results, state) where OpTy is either</li>
<li><a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> *, in which case the transform is always applied;</li>
<li>a concrete <a class="el" href="classmlir_1_1Op.html" title="This provides public APIs that all operations should have.">Op</a> class, in which case a check is performed whether <code>targets</code> contains operations of the same class and a silenceable failure is reported if it does not. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="TransformInterfaces_8h_source.html#l01450">1450</a> of file <a class="el" href="TransformInterfaces_8h_source.html">TransformInterfaces.h</a>.</p>

</div>
</div>
<a id="a0ff3c0c4abf23c806d81a4897c638fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ff3c0c4abf23c806d81a4897c638fa8">&#9670;&nbsp;</a></span>assembleTransformLibraryFromPaths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::transform::detail::assembleTransformLibraryFromPaths </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>transformLibraryPaths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ModuleOp &gt; &amp;&#160;</td>
          <td class="paramname"><em>transformModule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility to parse, verify, aggregate and link the content of all mlir files nested under <code>transformLibraryPaths</code> and containing transform dialect specifications. </p>

<p class="definition">Definition at line <a class="el" href="TransformInterpreterUtils_8cpp_source.html#l00146">146</a> of file <a class="el" href="TransformInterpreterUtils_8cpp_source.html">TransformInterpreterUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="TransformInterpreterUtils_8cpp_source.html#l00041">expandPathsToMLIRFiles()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="OwningOpRef_8h_source.html#l00050">mlir::OwningOpRef&lt; OpTy &gt;::get()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00510">mlir::get()</a>, <a class="el" href="Dialect_2Transform_2IR_2Utils_8cpp_source.html#l00079">mergeSymbolsInto()</a>, <a class="el" href="TransformInterpreterUtils_8cpp_source.html#l00090">parseTransformModuleFromFile()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

</div>
</div>
<a id="aa8f9cf3218ac160aecacfbdee04aa56b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8f9cf3218ac160aecacfbdee04aa56b">&#9670;&nbsp;</a></span>checkApplyToOne()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::transform::detail::checkApplyToOne </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>transformOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>payloadOpLoc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1transform_1_1ApplyToEachResultList.html">ApplyToEachResultList</a> &amp;&#160;</td>
          <td class="paramname"><em>partialResult</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check that the contents of <code>partialResult</code> matches the number, kind (payload op or parameter) and nullity (either all or none) requirements of <code>transformOp</code>. </p>
<p>Report errors and return failure otherwise. </p>

<p class="definition">Definition at line <a class="el" href="TransformInterfaces_8cpp_source.html#l01443">1443</a> of file <a class="el" href="TransformInterfaces_8cpp_source.html">TransformInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleImport_8cpp_source.html#l00052">diag()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00306">emitDiag()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">mlir::emitError()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00223">mlir::Operation::getLoc()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00119">mlir::Operation::getName()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00399">mlir::Operation::getNumResults()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00410">mlir::Operation::getResults()</a>, <a class="el" href="OperationSupport_8h_source.html#l00476">mlir::OperationName::getStringRef()</a>, <a class="el" href="TransformInterfaces_8h_source.html#l01409">mlir::transform::ApplyToEachResultList::size()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

</div>
</div>
<a id="a66abffa78647df1f7e48d10ed3c5eeec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66abffa78647df1f7e48d10ed3c5eeec">&#9670;&nbsp;</a></span>checkImplementsTransformHandleTypeInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::transform::detail::checkImplementsTransformHandleTypeInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeID.html">TypeID</a>&#160;</td>
          <td class="paramname"><em>typeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asserts that the type provided as template argument implements the TransformHandleTypeInterface. </p>
<p>This must be a dynamic assertion since interface implementations may be registered at runtime. </p>

<p class="definition">Definition at line <a class="el" href="TransformDialect_8cpp_source.html#l00047">47</a> of file <a class="el" href="TransformDialect_8cpp_source.html">TransformDialect.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00966">mlir::AbstractType::lookup()</a>.</p>

</div>
</div>
<a id="ac972c3c018134f06d3406b1237310cbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac972c3c018134f06d3406b1237310cbb">&#9670;&nbsp;</a></span>checkImplementsTransformOpInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::transform::detail::checkImplementsTransformOpInterface </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asserts that the operations provided as template arguments implement the TransformOpInterface and MemoryEffectsOpInterface. </p>
<p>This must be a dynamic assertion since interface implementations may be registered at runtime. </p>

<p class="definition">Definition at line <a class="el" href="TransformDialect_8cpp_source.html#l00023">23</a> of file <a class="el" href="TransformDialect_8cpp_source.html">TransformDialect.cpp</a>.</p>

<p class="reference">References <a class="el" href="OperationSupport_8h_source.html#l00374">mlir::OperationName::hasInterface()</a>, <a class="el" href="OperationSupport_8h_source.html#l00280">mlir::OperationName::hasTrait()</a>, and <a class="el" href="MLIRContext_8cpp_source.html#l00912">mlir::RegisteredOperationName::lookup()</a>.</p>

</div>
</div>
<a id="a8ee541c7d80632f563472fe99ba8e684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ee541c7d80632f563472fe99ba8e684">&#9670;&nbsp;</a></span>checkNestedConsumption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::transform::detail::checkNestedConsumption </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td>
          <td class="paramname"><em>targets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports an error and returns failure if <code>targets</code> contains an ancestor operation before its descendant (or a copy of itself). </p>
<p>Implementation detail for expensive checks during <code><a class="el" href="classmlir_1_1transform_1_1TransformEachOpTrait.html#af845e7db5cfedefa62d5ebe8531f6d3b" title="Calls applyToOne for every payload operation associated with the operand of this transform IR op,...">TransformEachOpTrait::apply</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="TransformInterfaces_8cpp_source.html#l01421">1421</a> of file <a class="el" href="TransformInterfaces_8cpp_source.html">TransformInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleImport_8cpp_source.html#l00052">diag()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">mlir::emitError()</a>, <a class="el" href="Matchers_8h_source.html#l00285">mlir::detail::enumerate()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

</div>
</div>
<a id="a6312474ea1986d03c2788246b215e70e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6312474ea1986d03c2788246b215e70e">&#9670;&nbsp;</a></span>expandPathsToMLIRFiles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::transform::detail::expandPathsToMLIRFiles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>fileNames</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expands the given list of <code>paths</code> to a list of <code>.mlir</code> files. </p>
<p>Each entry in <code>paths</code> may either be a regular file, in which case it ends up in the result list, or a directory, in which case all (regular) <code>.mlir</code> files in that directory are added. Any other file types lead to a failure. </p>

<p class="definition">Definition at line <a class="el" href="TransformInterpreterUtils_8cpp_source.html#l00041">41</a> of file <a class="el" href="TransformInterpreterUtils_8cpp_source.html">TransformInterpreterUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="TransformInterpreterUtils_8cpp_source.html#l00034">DBGS</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">mlir::emitError()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00510">mlir::get()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TransformInterpreterUtils_8cpp_source.html#l00146">assembleTransformLibraryFromPaths()</a>, and <a class="el" href="TransformInterpreterPassBase_8cpp_source.html#l00366">interpreterBaseInitializeImpl()</a>.</p>

</div>
</div>
<a id="a8e95146317beb53f05b36c2d9d7a4267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e95146317beb53f05b36c2d9d7a4267">&#9670;&nbsp;</a></span>findTransformEntryPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">transform::TransformOpInterface mlir::transform::detail::findTransformEntryPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ModuleOp&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>entryPoint</em> = <code>TransformDialect::kTransformEntryPointSymbolName</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first TransformOpInterface named <code>kTransformEntryPointSymbolName</code> that is either: </p>
<ol type="1">
<li>nested under <code>root</code> (takes precedence).</li>
<li>nested under <code>module</code>, if not found in <code>root</code>. Reports errors and returns null if no such operation found. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="TransformInterpreterUtils_8cpp_source.html#l00121">121</a> of file <a class="el" href="TransformInterpreterUtils_8cpp_source.html">TransformInterpreterUtils.cpp</a>.</p>

</div>
</div>
<a id="a81d536d06d24d9780714574520f14e25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81d536d06d24d9780714574520f14e25">&#9670;&nbsp;</a></span>forwardTerminatorOperands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::transform::detail::forwardTerminatorOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1transform_1_1TransformState.html">transform::TransformState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1transform_1_1TransformResults.html">transform::TransformResults</a> &amp;&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates <code>results</code> with payload associations that match exactly those of the operands to <code>block</code>'s terminator. </p>

<p class="definition">Definition at line <a class="el" href="TransformInterfaces_8cpp_source.html#l01551">1551</a> of file <a class="el" href="TransformInterfaces_8cpp_source.html">TransformInterfaces.cpp</a>.</p>

</div>
</div>
<a id="aabe281daf80785933afa0acad9fef1c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabe281daf80785933afa0acad9fef1c7">&#9670;&nbsp;</a></span>getConsumedHandleOpOperands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *&gt; mlir::transform::detail::getConsumedHandleOpOperands </td>
          <td>(</td>
          <td class="paramtype">transform::TransformOpInterface&#160;</td>
          <td class="paramname"><em>transformOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all operands that are handles and being consumed by the given op. </p>

</div>
</div>
<a id="a8c4853c22618926e8e9f6505afcdff9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c4853c22618926e8e9f6505afcdff9d">&#9670;&nbsp;</a></span>getParamProducerTransformOpTraitEffects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::transform::detail::getParamProducerTransformOpTraitEffects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="namespacemlir_1_1MemoryEffects.html#ac845c307c34161d9e9c0c1a0287c9664">MemoryEffects::EffectInstance</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>effects</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Non-template implementation of <a class="el" href="classmlir_1_1transform_1_1ParamProducerTransformOpTrait.html#ad3321e39e0c4a2102e0ab54da46788c7" title="Populates effects with effect instances described in the trait documentation.">ParamProducerTransformOpTrait::getEffects()</a>. </p>

<p class="definition">Definition at line <a class="el" href="TransformInterfaces_8cpp_source.html#l01754">1754</a> of file <a class="el" href="TransformInterfaces_8cpp_source.html">TransformInterfaces.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="TransformInterfaces_8h_source.html#l01334">mlir::transform::ParamProducerTransformOpTrait&lt; OpTy &gt;::getEffects()</a>.</p>

</div>
</div>
<a id="afc8c491c51ccdf3437db9ee7486b083a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc8c491c51ccdf3437db9ee7486b083a">&#9670;&nbsp;</a></span>getPotentialTopLevelEffects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::transform::detail::getPotentialTopLevelEffects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> &amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="namespacemlir_1_1MemoryEffects.html#ac845c307c34161d9e9c0c1a0287c9664">MemoryEffects::EffectInstance</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>effects</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates <code>effects</code> with side effects implied by <a class="el" href="classmlir_1_1transform_1_1PossibleTopLevelTransformOpTrait.html" title="This trait is supposed to be attached to Transform dialect operations that can be standalone top-leve...">PossibleTopLevelTransformOpTrait</a> for the given operation. </p>
<p>The operation may have an optional <code>root</code> operand, indicating it is not in fact top-level. It is also expected to have a single-block body. </p>

<p class="definition">Definition at line <a class="el" href="TransformInterfaces_8cpp_source.html#l01613">1613</a> of file <a class="el" href="TransformInterfaces_8cpp_source.html">TransformInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00373">mlir::Operation::getOperands()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00410">mlir::Operation::getResults()</a>, <a class="el" href="TransformInterfaces_8cpp_source.html#l01833">mlir::transform::onlyReadsHandle()</a>, and <a class="el" href="TransformInterfaces_8cpp_source.html#l01822">mlir::transform::producesHandle()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TransformInterfaces_8h_source.html#l01126">mlir::transform::PossibleTopLevelTransformOpTrait&lt; OpTy &gt;::getPotentialTopLevelEffects()</a>.</p>

</div>
</div>
<a id="a2413cdd0547cc80c81350234f5b76e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2413cdd0547cc80c81350234f5b76e43">&#9670;&nbsp;</a></span>getPreloadedTransformModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ModuleOp mlir::transform::detail::getPreloadedTransformModule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility to load a transform interpreter <code>module</code> from a module that has already been preloaded in the context. </p>
<p>This mode is useful in cases where explicit parsing of a transform library from file is expected to be prohibitively expensive. In such cases, the transform module is expected to be found in the preloaded library modules of the transform dialect. Returns null if the module is not found. </p>

<p class="definition">Definition at line <a class="el" href="TransformInterpreterUtils_8cpp_source.html#l00115">115</a> of file <a class="el" href="TransformInterpreterUtils_8cpp_source.html">TransformInterpreterUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8h_source.html#l00097">mlir::MLIRContext::getOrLoadDialect()</a>.</p>

</div>
</div>
<a id="a1af2d34af5df614b30850abce6463789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1af2d34af5df614b30850abce6463789">&#9670;&nbsp;</a></span>interpreterBaseInitializeImpl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::transform::detail::interpreterBaseInitializeImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>transformFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>transformLibraryPaths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ModuleOp &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ModuleOp &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>libraryModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; std::optional&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> &gt;(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>)&gt;&#160;</td>
          <td class="paramname"><em>moduleBuilder</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template-free implementation of <a class="el" href="classmlir_1_1transform_1_1TransformInterpreterPassBase.html#aa461c75a4b89143286fe10b41cfca7bd">TransformInterpreterPassBase::initialize</a>. </p>

<p class="definition">Definition at line <a class="el" href="TransformInterpreterPassBase_8cpp_source.html#l00366">366</a> of file <a class="el" href="TransformInterpreterPassBase_8cpp_source.html">TransformInterpreterPassBase.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">mlir::emitError()</a>, <a class="el" href="TransformInterpreterUtils_8cpp_source.html#l00041">expandPathsToMLIRFiles()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="OwningOpRef_8h_source.html#l00050">mlir::OwningOpRef&lt; OpTy &gt;::get()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00510">mlir::get()</a>, <a class="el" href="Dialect_2Transform_2IR_2Utils_8cpp_source.html#l00079">mergeSymbolsInto()</a>, <a class="el" href="TransformInterpreterUtils_8cpp_source.html#l00090">parseTransformModuleFromFile()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>, and <a class="el" href="Verifier_8cpp_source.html#l00421">mlir::verify()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TransformInterpreterPassBase_8h_source.html#l00110">mlir::transform::TransformInterpreterPassBase&lt; Concrete, GeneratedBase &gt;::initialize()</a>.</p>

</div>
</div>
<a id="a42a5dbbdaf56120611983c48bcbe2757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a5dbbdaf56120611983c48bcbe2757">&#9670;&nbsp;</a></span>interpreterBaseRunOnOperationImpl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::transform::detail::interpreterBaseRunOnOperationImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>passName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ModuleOp &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>sharedTransformModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ModuleOp &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>libraryModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1RaggedArray.html">RaggedArray</a>&lt; <a class="el" href="namespacemlir_1_1transform.html#af0fc847d51f4b4097c66b8b50b09c60c">MappedValue</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>extraMappings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1transform_1_1TransformOptions.html">TransformOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1Pass_1_1Option.html">Pass::Option</a>&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>transformFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1Pass_1_1ListOption.html">Pass::ListOption</a>&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>transformLibraryPaths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1Pass_1_1Option.html">Pass::Option</a>&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>debugPayloadRootTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1Pass_1_1Option.html">Pass::Option</a>&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>debugTransformRootTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>binaryName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template-free implementation of <a class="el" href="classmlir_1_1transform_1_1TransformInterpreterPassBase.html#a7aec0111a496becc8499f5d833d23045">TransformInterpreterPassBase::runOnOperation</a>. </p>

<p class="definition">Definition at line <a class="el" href="TransformInterpreterPassBase_8cpp_source.html#l00274">274</a> of file <a class="el" href="TransformInterpreterPassBase_8cpp_source.html">TransformInterpreterPassBase.cpp</a>.</p>

<p class="reference">References <a class="el" href="TransformInterfaces_8cpp_source.html#l01982">mlir::transform::applyTransforms()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00686">mlir::Operation::clone()</a>, <a class="el" href="ModuleImport_8cpp_source.html#l00052">diag()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00267">mlir::Operation::emitError()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">mlir::emitError()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="TransformInterpreterPassBase_8cpp_source.html#l00095">findOpWithTag()</a>, <a class="el" href="TransformInterpreterPassBase_8cpp_source.html#l00061">findTopLevelTransform()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00223">mlir::Operation::getLoc()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00337">mlir::SymbolTable::getNearestSymbolTable()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00728">mlir::Operation::hasTrait()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00218">mlir::Operation::isProperAncestor()</a>, <a class="el" href="TransformInterpreterPassBase_8cpp_source.html#l00046">kTransformDialectTagAttrName</a>, <a class="el" href="Dialect_2Transform_2IR_2Utils_8cpp_source.html#l00079">mergeSymbolsInto()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>, and <a class="el" href="TransformInterpreterPassBase_8cpp_source.html#l00207">performOptionalDebugActions()</a>.</p>

</div>
</div>
<a id="a9c029c6849c69a0f311170959ae70966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c029c6849c69a0f311170959ae70966">&#9670;&nbsp;</a></span>makeTransformStateForTesting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1transform_1_1TransformState.html">transform::TransformState</a> mlir::transform::detail::makeTransformStateForTesting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>payloadRoot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a dummy transform state for testing purposes. </p>
<p>This MUST NOT be used outside of test cases. </p>

<p class="definition">Definition at line <a class="el" href="TransformInterfaces_8cpp_source.html#l01572">1572</a> of file <a class="el" href="TransformInterfaces_8cpp_source.html">TransformInterfaces.cpp</a>.</p>

</div>
</div>
<a id="a97376b0a911f5a44f05410e33d7fe30e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97376b0a911f5a44f05410e33d7fe30e">&#9670;&nbsp;</a></span>mapPossibleTopLevelTransformOpBlockArguments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::transform::detail::mapPossibleTopLevelTransformOpBlockArguments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1transform_1_1TransformState.html">TransformState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps the only block argument of the op with <a class="el" href="classmlir_1_1transform_1_1PossibleTopLevelTransformOpTrait.html" title="This trait is supposed to be attached to Transform dialect operations that can be standalone top-leve...">PossibleTopLevelTransformOpTrait</a> to either the list of operations associated with its operand or the root of the payload IR, depending on what is available in the context. </p>

<p class="definition">Definition at line <a class="el" href="TransformInterfaces_8cpp_source.html#l01636">1636</a> of file <a class="el" href="TransformInterfaces_8cpp_source.html">TransformInterfaces.cpp</a>.</p>

</div>
</div>
<a id="accfe7c2cf4c9692e48bfb28f0fb39b9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accfe7c2cf4c9692e48bfb28f0fb39b9b">&#9670;&nbsp;</a></span>matchOptionalOperation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DiagnosedSilenceableFailure.html">DiagnosedSilenceableFailure</a> mlir::transform::detail::matchOptionalOperation </td>
          <td>(</td>
          <td class="paramtype">OpTy&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1transform_1_1TransformResults.html">TransformResults</a> &amp;&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1transform_1_1TransformState.html">TransformState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch <code>matchOperation</code> based on Operation* or std::optional&lt;Operation*&gt; first operand. </p>

<p class="definition">Definition at line <a class="el" href="MatchInterfaces_8h_source.html#l00026">26</a> of file <a class="el" href="MatchInterfaces_8h_source.html">MatchInterfaces.h</a>.</p>

</div>
</div>
<a id="a4b901961a14a54c8a5ce44fbc17e61e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b901961a14a54c8a5ce44fbc17e61e6">&#9670;&nbsp;</a></span>mergeSymbolsInto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> mlir::transform::detail::mergeSymbolsInto </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge all symbols from <code>other</code> into <code>target</code>. </p>
<p>Both ops need to implement the <code><a class="el" href="classmlir_1_1SymbolTable.html" title="This class allows for representing and managing the symbol table used by operations with the &#39;SymbolT...">SymbolTable</a></code> trait. Operations are moved from <code>other</code>, i.e., <code>other</code> may be modified by this function and might not verify after the function returns. Upon merging, private symbols may be renamed in order to avoid collisions in the result. Public symbols may not collide, with the exception of instances of <code>SymbolOpInterface</code>, where collisions are allowed if at least one of the two is external, in which case the other op preserved (or any one of the two if both are external). </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Transform_2IR_2Utils_8cpp_source.html#l00079">79</a> of file <a class="el" href="Dialect_2Transform_2IR_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Transform_2IR_2Utils_8cpp_source.html#l00018">DBGS</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00728">mlir::Operation::hasTrait()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TransformInterpreterUtils_8cpp_source.html#l00185">mlir::transform::applyTransformNamedSequence()</a>, <a class="el" href="TransformInterpreterUtils_8cpp_source.html#l00146">assembleTransformLibraryFromPaths()</a>, <a class="el" href="TransformInterpreterPassBase_8cpp_source.html#l00366">interpreterBaseInitializeImpl()</a>, and <a class="el" href="TransformInterpreterPassBase_8cpp_source.html#l00274">interpreterBaseRunOnOperationImpl()</a>.</p>

</div>
</div>
<a id="a1e51908acb17379cdee600e5d14eb504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e51908acb17379cdee600e5d14eb504">&#9670;&nbsp;</a></span>parseTransformModuleFromFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::transform::detail::parseTransformModuleFromFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>transformFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningOpRef.html">OwningOpRef</a>&lt; ModuleOp &gt; &amp;&#160;</td>
          <td class="paramname"><em>transformModule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility to parse and verify the content of a <code>transformFileName</code> MLIR file containing a transform dialect specification. </p>

<p class="definition">Definition at line <a class="el" href="TransformInterpreterUtils_8cpp_source.html#l00090">90</a> of file <a class="el" href="TransformInterpreterUtils_8cpp_source.html">TransformInterpreterUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="TransformInterpreterUtils_8cpp_source.html#l00034">DBGS</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">mlir::emitError()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00510">mlir::get()</a>, <a class="el" href="namespacemlir.html#a0c2eb0b34f6d7e90435b0a6ce3d8ffaf">mlir::openInputFile()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>, and <a class="el" href="Verifier_8cpp_source.html#l00421">mlir::verify()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TransformInterpreterUtils_8cpp_source.html#l00146">assembleTransformLibraryFromPaths()</a>, and <a class="el" href="TransformInterpreterPassBase_8cpp_source.html#l00366">interpreterBaseInitializeImpl()</a>.</p>

</div>
</div>
<a id="ab6bed67cf9bef6f84934753a04d80eed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6bed67cf9bef6f84934753a04d80eed">&#9670;&nbsp;</a></span>prepareValueMappings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::transform::detail::prepareValueMappings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir_1_1transform.html#af0fc847d51f4b4097c66b8b50b09c60c">transform::MappedValue</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>mappings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1transform_1_1TransformState.html">transform::TransformState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates <code>mappings</code> with mapped values associated with the given transform IR values in the given <code>state</code>. </p>

<p class="definition">Definition at line <a class="el" href="TransformInterfaces_8cpp_source.html#l01533">1533</a> of file <a class="el" href="TransformInterfaces_8cpp_source.html">TransformInterfaces.cpp</a>.</p>

</div>
</div>
<a id="a7b899140fcc90aabc5b221816337cc4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b899140fcc90aabc5b221816337cc4d">&#9670;&nbsp;</a></span>setApplyToOneResults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::transform::detail::setApplyToOneResults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>transformOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1transform_1_1TransformResults.html">TransformResults</a> &amp;&#160;</td>
          <td class="paramname"><em>transformResults</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1transform_1_1ApplyToEachResultList.html">ApplyToEachResultList</a> &gt;&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"Transpose" the results produced by individual applications, arranging them per result value of the transform op, and populate <code>transformResults</code> with that. </p>
<p>The number, kind and nullity of per-application results are assumed to have been verified. </p>

<p class="definition">Definition at line <a class="el" href="TransformInterfaces_8cpp_source.html#l01501">1501</a> of file <a class="el" href="TransformInterfaces_8cpp_source.html">TransformInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00285">mlir::detail::enumerate()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00399">mlir::Operation::getNumResults()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00410">mlir::Operation::getResults()</a>, <a class="el" href="TransformInterfaces_8h_source.html#l00807">mlir::transform::TransformResults::set()</a>, <a class="el" href="TransformInterfaces_8cpp_source.html#l01091">mlir::transform::TransformResults::setParams()</a>, and <a class="el" href="TransformInterfaces_8h_source.html#l00839">mlir::transform::TransformResults::setValues()</a>.</p>

</div>
</div>
<a id="aad39ec48980e7ee4339642e7e286d304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad39ec48980e7ee4339642e7e286d304">&#9670;&nbsp;</a></span>verifyParamProducerTransformOpTrait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::transform::detail::verifyParamProducerTransformOpTrait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Non-template implementation of <a class="el" href="namespacemlir.html#ae4b1ba650fd43b50351e92bbb75bd4c0" title="Perform (potentially expensive) checks of invariants, used to detect compiler bugs,...">ParamProducerTransformOpTrait::verify()</a>. </p>

<p class="definition">Definition at line <a class="el" href="TransformInterfaces_8cpp_source.html#l01769">1769</a> of file <a class="el" href="TransformInterfaces_8cpp_source.html">TransformInterfaces.cpp</a>.</p>

</div>
</div>
<a id="af472e3604dc87e29966aba3b81c0a5fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af472e3604dc87e29966aba3b81c0a5fb">&#9670;&nbsp;</a></span>verifyPossibleTopLevelTransformOpTrait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::transform::detail::verifyPossibleTopLevelTransformOpTrait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verification hook for <a class="el" href="classmlir_1_1transform_1_1PossibleTopLevelTransformOpTrait.html" title="This trait is supposed to be attached to Transform dialect operations that can be standalone top-leve...">PossibleTopLevelTransformOpTrait</a>. </p>

<p class="definition">Definition at line <a class="el" href="TransformInterfaces_8cpp_source.html#l01687">1687</a> of file <a class="el" href="TransformInterfaces_8cpp_source.html">TransformInterfaces.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="TransformInterfaces_8cpp_source.html#l01982">mlir::transform::applyTransforms()</a>.</p>

</div>
</div>
<a id="ab49efa35a55e8224a1ad36d69d6198c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab49efa35a55e8224a1ad36d69d6198c9">&#9670;&nbsp;</a></span>verifyStructuredOpPredicateOpTrait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::transform::detail::verifyStructuredOpPredicateOpTrait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>structuredOpHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LinalgMatchOps_8cpp_source.html#l00144">144</a> of file <a class="el" href="LinalgMatchOps_8cpp_source.html">LinalgMatchOps.cpp</a>.</p>

</div>
</div>
<a id="a08d70b4f0eb6e462437d65f2d7567055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08d70b4f0eb6e462437d65f2d7567055">&#9670;&nbsp;</a></span>verifyTransformOpInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::transform::detail::verifyTransformOpInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verification hook for TransformOpInterface. </p>

<p class="definition">Definition at line <a class="el" href="TransformInterfaces_8cpp_source.html#l01915">1915</a> of file <a class="el" href="TransformInterfaces_8cpp_source.html">TransformInterfaces.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Dec 9 2023 02:40:38 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
