<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'amdgpu' Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.119.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/AMDGPU/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://mlir.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li></ul></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&amp;list_id=177877&amp;order=changeddate%20DESC%2Cpriority%2Cbug_severity&amp;product=MLIR&amp;query_format=specific">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>'amdgpu' Dialect</h1><p>The <code>AMDGPU</code> dialect provides wrappers around AMD-specific functionality
and LLVM intrinsics. These wrappers should be used in conjunction with
more generic dialects, such as <code>gpu</code> and <code>vector</code>, when generating LLVM IR
that will eventually be executed on AMD hardware.</p><p><nav id=TableOfContents><ul><li><a href=#operations>Operations</a><ul><li><a href=#amdgpuext_packed_fp8-amdgpuextpackedfp8op><code>amdgpu.ext_packed_fp8</code> (amdgpu::ExtPackedFp8Op)</a></li><li><a href=#amdgpulds_barrier-amdgpuldsbarrierop><code>amdgpu.lds_barrier</code> (amdgpu::LDSBarrierOp)</a></li><li><a href=#amdgpumfma-amdgpumfmaop><code>amdgpu.mfma</code> (amdgpu::MFMAOp)</a></li><li><a href=#amdgpupacked_stoch_round_fp8-amdgpupackedstochroundfp8op><code>amdgpu.packed_stoch_round_fp8</code> (amdgpu::PackedStochRoundFp8Op)</a></li><li><a href=#amdgpupacked_trunc_2xfp8-amdgpupackedtrunc2xfp8op><code>amdgpu.packed_trunc_2xfp8</code> (amdgpu::PackedTrunc2xFp8Op)</a></li><li><a href=#amdgpuraw_buffer_atomic_cmpswap-amdgpurawbufferatomiccmpswapop><code>amdgpu.raw_buffer_atomic_cmpswap</code> (amdgpu::RawBufferAtomicCmpswapOp)</a></li><li><a href=#amdgpuraw_buffer_atomic_fadd-amdgpurawbufferatomicfaddop><code>amdgpu.raw_buffer_atomic_fadd</code> (amdgpu::RawBufferAtomicFaddOp)</a></li><li><a href=#amdgpuraw_buffer_atomic_fmax-amdgpurawbufferatomicfmaxop><code>amdgpu.raw_buffer_atomic_fmax</code> (amdgpu::RawBufferAtomicFmaxOp)</a></li><li><a href=#amdgpuraw_buffer_atomic_smax-amdgpurawbufferatomicsmaxop><code>amdgpu.raw_buffer_atomic_smax</code> (amdgpu::RawBufferAtomicSmaxOp)</a></li><li><a href=#amdgpuraw_buffer_atomic_umin-amdgpurawbufferatomicuminop><code>amdgpu.raw_buffer_atomic_umin</code> (amdgpu::RawBufferAtomicUminOp)</a></li><li><a href=#amdgpuraw_buffer_load-amdgpurawbufferloadop><code>amdgpu.raw_buffer_load</code> (amdgpu::RawBufferLoadOp)</a></li><li><a href=#amdgpuraw_buffer_store-amdgpurawbufferstoreop><code>amdgpu.raw_buffer_store</code> (amdgpu::RawBufferStoreOp)</a></li><li><a href=#amdgpuwmma-amdgpuwmmaop><code>amdgpu.wmma</code> (amdgpu::WMMAOp)</a></li></ul></li><li><a href=#attributes-12>Attributes</a><ul><li><a href=#mfmapermbattr>MFMAPermBAttr</a></li></ul></li></ul></nav><h2 id=operations>Operations&nbsp;<a class=headline-hash href=#operations>¶</a></h2><p><a href=https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/AMDGPU/IR/AMDGPU.td>source</a></p><h3 id=amdgpuext_packed_fp8-amdgpuextpackedfp8op><code>amdgpu.ext_packed_fp8</code> (amdgpu::ExtPackedFp8Op)&nbsp;<a class=headline-hash href=#amdgpuext_packed_fp8-amdgpuextpackedfp8op>¶</a></h3><p><em>Extend one of a vector of packed fp8 values to a float</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `amdgpu.ext_packed_fp8` attr-dict $source `[` $index `]` `:` type($source) `to` type($res)
</code></pre><p>Extend the value <code>source[index]</code> to a 32-bit float and return it.</p><p>This rather unusual signature arises from the fact that AMD GPUs cannot
easily work with sub 32-bit quantities, so the compiler intrinsics for
extending 8-bit floats (which are, currently, the only way to work with
this operation) take packed vectors of 4 such floats.</p><p>If the passed-in vector has fewer than four elements, or the input is scalar,
the remaining values in the &lt;4 x i8> will be filled with with
undefined values as needed.</p><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>index</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute whose value is non-negative whose maximum value is 3</td></tr></table><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>source</code></td><td>f8E5M2FNUZ type or f8E4M3FNUZ type or vector of f8E5M2FNUZ type or f8E4M3FNUZ type values of length 1/2/3/4</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit float</td></tr></tbody></table><h3 id=amdgpulds_barrier-amdgpuldsbarrierop><code>amdgpu.lds_barrier</code> (amdgpu::LDSBarrierOp)&nbsp;<a class=headline-hash href=#amdgpulds_barrier-amdgpuldsbarrierop>¶</a></h3><p><em>Barrier that includes a wait for LDS memory operations.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `amdgpu.lds_barrier` attr-dict
</code></pre><p><code>amdgpu.lds_barrier</code> is both a barrier (all workitems in a workgroup must reach
the barrier before any of them may proceed past it) and a wait for all
operations that affect the Local Data Store (LDS) issued from that wrokgroup
to complete before the workgroup may continue. Since the LDS is per-workgroup
memory, this barrier may be used, for example, to ensure all workitems have
written data to LDS before any workitem attempts to read from it.</p><p>Note that <code>lds_barrier</code> does <strong>not</strong> force reads to or from global memory
to complete before execution continues. Therefore, it should be used when
operations on global memory can be issued far in advance of when their results
are used (for example, by writing them to LDS).</p><h3 id=amdgpumfma-amdgpumfmaop><code>amdgpu.mfma</code> (amdgpu::MFMAOp)&nbsp;<a class=headline-hash href=#amdgpumfma-amdgpumfmaop>¶</a></h3><p><em>MLIR wrapper for CDNA mfma instructions</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `amdgpu.mfma` $sourceA `*` $sourceB `+` $destC
              attr-dict
              `blgp` `=` $blgp
              `:` type($sourceA) `,` type($sourceB) `,` type($destC)
</code></pre><p>The <code>amdgpu.mfma</code> op is an MLIR wrapper around intrinsics
for various <code>mfma</code> instructions in the CDNA architecture, which perform
multiple outer products in order to allow fast matrix multiplication.</p><p>The wrapper will select an appropriate <code>mfma</code> instruction, if one is available,
based on the provided <code>m</code>, <code>k</code>, <code>n</code>, and <code>nBlks</code> attributes, along with the
types of the source and destination arguments.</p><p>For information on the layouts of the input and output matrces (which are stored
in <code>sourceA</code>, <code>sourceB</code>, <code>destC</code>, and <code>destD</code>), see the CDNA ISA documentation.</p><p>The <code>cbsz</code>, <code>abid</code>, and <code>blgp</code> parameters control how the lanes of the wave
are permuted when matrix data is being loaded: <code>blgp</code> can be any number of
fixed permutations, <code>cbsz</code> specifies the log_2 of the number of chunks the lanes
holding sourceA are split into, and <code>abid</code> selects one of those chunks.</p><p>Note, this wrapper allows specifying <code>vector&lt;4Kxi8></code> arguments to MFMA
intrinsics that take an integer type of width <code>4K</code>. For example,
one can provide a vector&lt;4xi8> as an argument to an MFMA instruction that
logically takes 4 i8s but whose intrinsics are specified to take an i32.
In these cases, the bytes in the vector will be concatenated in little-endian
order (that is, v[0] will go to arg[7:0], v[1] to arg[15:8] and so on).</p><p>The negateA, negateB, and negateC flags are only supported for double-precision
operations on gfx940+.</p><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>m</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>n</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>k</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>blocks</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>cbsz</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>abid</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>blgp</code></td><td>::mlir::amdgpu::MFMAPermBAttr</td><td><details><summary>The possible permutations of the lanes storing B available in an MFMA</summary><p>Enum cases:</p><ul><li>none (<code>none</code>)</li><li>bcast_first_32 (<code>bcast_first_32</code>)</li><li>bcast_second_32 (<code>bcast_second_32</code>)</li><li>rotate_16_right (<code>rotate_16_right</code>)</li><li>bcast_first_16 (<code>bcast_first_16</code>)</li><li>bcast_second_16 (<code>bcast_second_16</code>)</li><li>bcast_third_16 (<code>bcast_third_16</code>)</li><li>bcast_fourth_16 (<code>bcast_fourth_16</code>)</li></ul></details></td></tr><tr><td><code>reducePrecision</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>negateA</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>negateB</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>negateC</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>sourceA</code></td><td>32-bit float or 64-bit float or 32-bit signless integer or 64-bit signless integer or vector of 32-bit float values of length 2 or vector of 16-bit float values of length 4 or vector of bfloat16 type values of length 2/4 or vector of 8-bit signless integer values of length 4/8 or vector of f8E5M2FNUZ type or f8E4M3FNUZ type values of length 8</td></tr><tr><td style=text-align:center><code>sourceB</code></td><td>32-bit float or 64-bit float or 32-bit signless integer or 64-bit signless integer or vector of 32-bit float values of length 2 or vector of 16-bit float values of length 4 or vector of bfloat16 type values of length 2/4 or vector of 8-bit signless integer values of length 4/8 or vector of f8E5M2FNUZ type or f8E4M3FNUZ type values of length 8</td></tr><tr><td style=text-align:center><code>destC</code></td><td>64-bit float or vector of 32-bit float values of length 4/16/32 or vector of 32-bit signless integer values of length 4/16/32 or vector of 64-bit float values of length 4</td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>destD</code></td><td>64-bit float or vector of 32-bit float values of length 4/16/32 or vector of 32-bit signless integer values of length 4/16/32 or vector of 64-bit float values of length 4</td></tr></tbody></table><h3 id=amdgpupacked_stoch_round_fp8-amdgpupackedstochroundfp8op><code>amdgpu.packed_stoch_round_fp8</code> (amdgpu::PackedStochRoundFp8Op)&nbsp;<a class=headline-hash href=#amdgpupacked_stoch_round_fp8-amdgpupackedstochroundfp8op>¶</a></h3><p><em>Round float stochiastically into a packed vector of 8-bit floats</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `amdgpu.packed_stoch_round_fp8` attr-dict $source `+` $stochiasticParam
              `into` ($existing^):(`undef`)? `[` $storeIndex `]`
              `:` type($source) `to` type($res) (`into` type($existing)^)?
</code></pre><p>Round the input <code>source</code>, adding in <code>stochiasticParam</code>, and place it into
the <code>storeIndex</code>th element of <code>res</code>.</p><p>If <code>existing</code> is passed in, elements of <code>res</code> other than the one at <code>storeIndex</code>
are copied from <code>existing</code>.</p><p>The reason for this odd signature is that AMD GPUs cannot easily work with
sub-registers, and so the conversion intrinsics (which are currently the
only way to work with 8-bit float types) take packed vectors of 4 8-bit
values.</p><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>storeIndex</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute whose value is non-negative whose maximum value is 3</td></tr></table><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>source</code></td><td>32-bit float</td></tr><tr><td style=text-align:center><code>stochiasticParam</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>existing</code></td><td>fixed-length vector of f8E4M3FNUZ type or f8E5M2FNUZ type values of length 4</td></tr></tbody></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of f8E4M3FNUZ type or f8E5M2FNUZ type values of length 4</td></tr></tbody></table><h3 id=amdgpupacked_trunc_2xfp8-amdgpupackedtrunc2xfp8op><code>amdgpu.packed_trunc_2xfp8</code> (amdgpu::PackedTrunc2xFp8Op)&nbsp;<a class=headline-hash href=#amdgpupacked_trunc_2xfp8-amdgpupackedtrunc2xfp8op>¶</a></h3><p><em>Round two floats into a packed vector of 8-bit floats</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `amdgpu.packed_trunc_2xfp8` attr-dict $sourceA `,` ($sourceB^):(`undef`)?
              `into` ($existing^):(`undef`)? `[` `word` $wordIndex `]`
              `:` type($sourceA) `to` type($res) (`into` type($existing)^)?
</code></pre><p>Round the inputs <code>sourceA</code> and <code>sourceB</code> (which is undefined if not
specified) into the low or high word (bottom two or top two) elements
of the returned vector, keeping the other two elements of <code>existing</code>
unchanged if present (or undefined if it was not passed in).</p><p>The reason for this odd signature is that AMD GPUs cannot easily work with
sub-registers, and so the conversion intrinsics (which are currently the
only way to work with 8-bit float types) take packed vectors of 4 8-bit
values.</p><p>Traits: AlwaysSpeculatableImplTrait, AttrSizedOperandSegments</p><p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-3>Attributes:&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>wordIndex</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute whose value is non-negative whose maximum value is 1</td></tr></table><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>sourceA</code></td><td>32-bit float</td></tr><tr><td style=text-align:center><code>sourceB</code></td><td>32-bit float</td></tr><tr><td style=text-align:center><code>existing</code></td><td>fixed-length vector of f8E4M3FNUZ type or f8E5M2FNUZ type values of length 4</td></tr></tbody></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of f8E4M3FNUZ type or f8E5M2FNUZ type values of length 4</td></tr></tbody></table><h3 id=amdgpuraw_buffer_atomic_cmpswap-amdgpurawbufferatomiccmpswapop><code>amdgpu.raw_buffer_atomic_cmpswap</code> (amdgpu::RawBufferAtomicCmpswapOp)&nbsp;<a class=headline-hash href=#amdgpuraw_buffer_atomic_cmpswap-amdgpurawbufferatomiccmpswapop>¶</a></h3><p><em>Raw Buffer Atomic compare-and-swap</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `amdgpu.raw_buffer_atomic_cmpswap` attr-dict $src `,` $cmp `-&gt;` $memref `[` $indices `]`
              (`sgprOffset` $sgprOffset^)? `:`
              type($value) `-&gt;` type($memref) `,` type($indices)
</code></pre><p>The <code>amdgpu.raw_buffer_atomic_cmpswap</code> op is a wrapper around the
buffer-based atomic compare-and-swap min available on AMD GPUs.</p><p>The index into the buffer is computed as for <code>memref.store</code> with the addition
of <code>indexOffset</code> (which is used to aid in emitting vectorized code) and,
if present <code>sgprOffset</code> (which is added after bounds checks and includes
any non-zero offset on the memref type).</p><p>All indexing components are given in terms of the memref&rsquo;s element size, not
the byte lengths required by the intrinsic.</p><p>Out of bounds atomic operations are ignored in hardware.</p><p>See <code>amdgpu.raw_buffer_load</code> for a description of how the underlying
instruction is constructed.</p><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-4>Attributes:&nbsp;<a class=headline-hash href=#attributes-4>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>boundsCheck</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>indexOffset</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float</td></tr><tr><td style=text-align:center><code>cmp</code></td><td>any type</td></tr><tr><td style=text-align:center><code>memref</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>indices</code></td><td>variadic of 32-bit signless integer</td></tr><tr><td style=text-align:center><code>sgprOffset</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>any type</td></tr></tbody></table><h3 id=amdgpuraw_buffer_atomic_fadd-amdgpurawbufferatomicfaddop><code>amdgpu.raw_buffer_atomic_fadd</code> (amdgpu::RawBufferAtomicFaddOp)&nbsp;<a class=headline-hash href=#amdgpuraw_buffer_atomic_fadd-amdgpurawbufferatomicfaddop>¶</a></h3><p><em>Raw Buffer Floating-point Atomic Add (MI-* only)</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `amdgpu.raw_buffer_atomic_fadd` attr-dict $value `-&gt;` $memref `[` $indices `]`
              (`sgprOffset` $sgprOffset^)? `:`
              type($value) `-&gt;` type($memref) `,` type($indices)
</code></pre><p>The <code>amdgpu.raw_buffer_atomic_fadd</code> op is a wrapper around the
buffer-based atomic floating point addition available on the MI-* series
of AMD GPUs.</p><p>The index into the buffer is computed as for <code>memref.store</code> with the addition
of <code>indexOffset</code> (which is used to aid in emitting vectorized code) and,
if present <code>sgprOffset</code> (which is added after bounds checks and includes
any non-zero offset on the memref type).</p><p>All indexing components are given in terms of the memref&rsquo;s element size, not
the byte lengths required by the intrinsic.</p><p>Out of bounds atomic operations are ignored in hardware.</p><p>See <code>amdgpu.raw_buffer_load</code> for a description of how the underlying
instruction is constructed.</p><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-5>Attributes:&nbsp;<a class=headline-hash href=#attributes-5>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>boundsCheck</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>indexOffset</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>32-bit float</td></tr><tr><td style=text-align:center><code>memref</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>indices</code></td><td>variadic of 32-bit signless integer</td></tr><tr><td style=text-align:center><code>sgprOffset</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=amdgpuraw_buffer_atomic_fmax-amdgpurawbufferatomicfmaxop><code>amdgpu.raw_buffer_atomic_fmax</code> (amdgpu::RawBufferAtomicFmaxOp)&nbsp;<a class=headline-hash href=#amdgpuraw_buffer_atomic_fmax-amdgpurawbufferatomicfmaxop>¶</a></h3><p><em>Raw Buffer Floating-point Atomic Max (non-GFX9)</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `amdgpu.raw_buffer_atomic_fmax` attr-dict $value `-&gt;` $memref `[` $indices `]`
              (`sgprOffset` $sgprOffset^)? `:`
              type($value) `-&gt;` type($memref) `,` type($indices)
</code></pre><p>The <code>amdgpu.raw_buffer_atomic_fmax</code> op is a wrapper around the
buffer-based atomic floating point max available on AMD GPUs (except GFX9).</p><p>The index into the buffer is computed as for <code>memref.store</code> with the addition
of <code>indexOffset</code> (which is used to aid in emitting vectorized code) and,
if present <code>sgprOffset</code> (which is added after bounds checks and includes
any non-zero offset on the memref type).</p><p>All indexing components are given in terms of the memref&rsquo;s element size, not
the byte lengths required by the intrinsic.</p><p>Out of bounds atomic operations are ignored in hardware.</p><p>See <code>amdgpu.raw_buffer_load</code> for a description of how the underlying
instruction is constructed.</p><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-6>Attributes:&nbsp;<a class=headline-hash href=#attributes-6>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>boundsCheck</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>indexOffset</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>32-bit float or 64-bit float</td></tr><tr><td style=text-align:center><code>memref</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>indices</code></td><td>variadic of 32-bit signless integer</td></tr><tr><td style=text-align:center><code>sgprOffset</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=amdgpuraw_buffer_atomic_smax-amdgpurawbufferatomicsmaxop><code>amdgpu.raw_buffer_atomic_smax</code> (amdgpu::RawBufferAtomicSmaxOp)&nbsp;<a class=headline-hash href=#amdgpuraw_buffer_atomic_smax-amdgpurawbufferatomicsmaxop>¶</a></h3><p><em>Raw Buffer Signed Integer Atomic Max</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `amdgpu.raw_buffer_atomic_smax` attr-dict $value `-&gt;` $memref `[` $indices `]`
              (`sgprOffset` $sgprOffset^)? `:`
              type($value) `-&gt;` type($memref) `,` type($indices)
</code></pre><p>The <code>amdgpu.raw_buffer_atomic_smax</code> op is a wrapper around the
buffer-based atomic signed integer max available on AMD GPUs.</p><p>The index into the buffer is computed as for <code>memref.store</code> with the addition
of <code>indexOffset</code> (which is used to aid in emitting vectorized code) and,
if present <code>sgprOffset</code> (which is added after bounds checks and includes
any non-zero offset on the memref type).</p><p>All indexing components are given in terms of the memref&rsquo;s element size, not
the byte lengths required by the intrinsic.</p><p>Out of bounds atomic operations are ignored in hardware.</p><p>See <code>amdgpu.raw_buffer_load</code> for a description of how the underlying
instruction is constructed.</p><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-7>Attributes:&nbsp;<a class=headline-hash href=#attributes-7>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>boundsCheck</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>indexOffset</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>memref</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>indices</code></td><td>variadic of 32-bit signless integer</td></tr><tr><td style=text-align:center><code>sgprOffset</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=amdgpuraw_buffer_atomic_umin-amdgpurawbufferatomicuminop><code>amdgpu.raw_buffer_atomic_umin</code> (amdgpu::RawBufferAtomicUminOp)&nbsp;<a class=headline-hash href=#amdgpuraw_buffer_atomic_umin-amdgpurawbufferatomicuminop>¶</a></h3><p><em>Raw Buffer Unsigned Integer Atomic Min</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `amdgpu.raw_buffer_atomic_umin` attr-dict $value `-&gt;` $memref `[` $indices `]`
              (`sgprOffset` $sgprOffset^)? `:`
              type($value) `-&gt;` type($memref) `,` type($indices)
</code></pre><p>The <code>amdgpu.raw_buffer_atomic_umin</code> op is a wrapper around the
buffer-based atomic signed integer min available on AMD GPUs.</p><p>The index into the buffer is computed as for <code>memref.store</code> with the addition
of <code>indexOffset</code> (which is used to aid in emitting vectorized code) and,
if present <code>sgprOffset</code> (which is added after bounds checks and includes
any non-zero offset on the memref type).</p><p>All indexing components are given in terms of the memref&rsquo;s element size, not
the byte lengths required by the intrinsic.</p><p>Out of bounds atomic operations are ignored in hardware.</p><p>See <code>amdgpu.raw_buffer_load</code> for a description of how the underlying
instruction is constructed.</p><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-8>Attributes:&nbsp;<a class=headline-hash href=#attributes-8>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>boundsCheck</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>indexOffset</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>memref</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>indices</code></td><td>variadic of 32-bit signless integer</td></tr><tr><td style=text-align:center><code>sgprOffset</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=amdgpuraw_buffer_load-amdgpurawbufferloadop><code>amdgpu.raw_buffer_load</code> (amdgpu::RawBufferLoadOp)&nbsp;<a class=headline-hash href=#amdgpuraw_buffer_load-amdgpurawbufferloadop>¶</a></h3><p><em>Raw Buffer load, exposing GCN features</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `amdgpu.raw_buffer_load` attr-dict $memref `[` $indices `]`
              (`sgprOffset` $sgprOffset^)? `:`
              type($memref) (`,` type($indices)^)? `-&gt;` type($value)
</code></pre><p>The <code>amdgpu.raw_buffer_load</code> op is a wrapper around the buffer load intrinsics
available on AMD GPUs, including extensions in newer GPUs.</p><p>The index into the buffer is computed as for <code>memref.load</code> with the additon
of <code>indexOffset</code> and <code>sgprOffset</code> (which <strong>may or may not</strong> be considered
in bounds checks and includes any offset present on the memref type if it&rsquo;s
non-zero).</p><p>All indices and offsets are in units of the memref&rsquo;s data type and are
converted to bytes during lowering.</p><p>When a load is out of bounds, the instruction returns zero.
Partially-out of bounds have chipset-dependent behavior: whether reading
2 elements starting at index 7 of a <code>memref&lt;8xf32></code> returns the last element
in the first vector component depends on the architecture.</p><p>The memref struct is converted into a buffer resource (a V#) and the arguments
are translated to intrinsic arguments as follows:</p><ul><li>The base address of the buffer is the base address of the memref</li><li>The stride is 0 to enable raw mode</li><li>The number of records is the size of the memref, in bytes
In the case of dynamically-shaped memrefs, this is computed at runtime
as max_d (size(d) * stride(d)) * sizeof(elementType(memref))</li><li>The offset enable bit is 1, the index enable bit is 0.</li><li>The thread ID addition bit is off</li><li>If <code>boundsCheck</code> is false and the target chipset is RDNA, OOB_SELECT is set
to 2 to disable bounds checks, otherwise it is 3</li><li>The cache coherency bits are off</li></ul><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-9>Attributes:&nbsp;<a class=headline-hash href=#attributes-9>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>boundsCheck</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>indexOffset</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-9>Operands:&nbsp;<a class=headline-hash href=#operands-9>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>memref</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>indices</code></td><td>variadic of 32-bit signless integer</td></tr><tr><td style=text-align:center><code>sgprOffset</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>bfloat16 type or 16-bit float or 32-bit float or 32-bit signless integer or 8-bit signless integer or f8E5M2FNUZ type or f8E4M3FNUZ type or vector of 32-bit float or 32-bit signless integer values of length 2/4 or vector of 16-bit float or bfloat16 type values of length 2/4/8 or vector of 8-bit signless integer or f8E5M2FNUZ type or f8E4M3FNUZ type values of length 2/4/8/16</td></tr></tbody></table><h3 id=amdgpuraw_buffer_store-amdgpurawbufferstoreop><code>amdgpu.raw_buffer_store</code> (amdgpu::RawBufferStoreOp)&nbsp;<a class=headline-hash href=#amdgpuraw_buffer_store-amdgpurawbufferstoreop>¶</a></h3><p><em>Raw Buffer Store, exposing GCN features</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `amdgpu.raw_buffer_store` attr-dict $value `-&gt;` $memref `[` $indices `]`
              (`sgprOffset` $sgprOffset^)? `:`
              type($value) `-&gt;` type($memref) (`,` type($indices)^)?
</code></pre><p>The <code>amdgpu.raw_buffer_store</code> op is a wrapper around the buffer store
intrinsics available on AMD GPUs, including extensions in newer GPUs.</p><p>The store index is computed as in <code>memref.store</code> with the addition of
<code>indexOffset</code> (which is included for uniformity with atomics and may be useful
when writing vectorized code) and <code>sgprOffset</code> (which is added after bounds
checks and implicitly includes the offset of the memref type if non-zero).
All index components are in terms of the elements of the memref, not bytes,
and are scaled up appropriately.</p><p>Out of bounds stores are ignored in hardware.
Wthether a vector write that includes some in-bounds and soeme out-of-bounds
components is partically completed is chipset-dependent.</p><p>See <code>amdgpu.raw_buffer_load</code> for a description of how the underlying
instruction is constructed.</p><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-10>Attributes:&nbsp;<a class=headline-hash href=#attributes-10>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>boundsCheck</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>indexOffset</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-10>Operands:&nbsp;<a class=headline-hash href=#operands-10>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>bfloat16 type or 16-bit float or 32-bit float or 32-bit signless integer or 8-bit signless integer or f8E5M2FNUZ type or f8E4M3FNUZ type or vector of 32-bit float or 32-bit signless integer values of length 2/4 or vector of 16-bit float or bfloat16 type values of length 2/4/8 or vector of 8-bit signless integer or f8E5M2FNUZ type or f8E4M3FNUZ type values of length 2/4/8/16</td></tr><tr><td style=text-align:center><code>memref</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>indices</code></td><td>variadic of 32-bit signless integer</td></tr><tr><td style=text-align:center><code>sgprOffset</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=amdgpuwmma-amdgpuwmmaop><code>amdgpu.wmma</code> (amdgpu::WMMAOp)&nbsp;<a class=headline-hash href=#amdgpuwmma-amdgpuwmmaop>¶</a></h3><p><em>MLIR wrapper for RDNA3 wmma instructions</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `amdgpu.wmma` $sourceA `*` $sourceB `+` $destC
              attr-dict
              `:` type($sourceA) `,` type($sourceB) `,` type($destC)
</code></pre><p>The <code>amdgpu.wmma</code> op is an MLIR wrapper around intrinsics
for various <code>wmma</code> instructions in the RDNA3 architecture, which perform
a 16x16 matrix multiplication for different data types.</p><p>When emitting f16->f16 (or bf16->bf16) wmma the output is a 16xf16 (or 16xbf16) vector
containing only 8 valid values:</p><ul><li>If <code>subwordOffset</code> is 0, then the output is stored at indices 0, 2, 4, &mldr;, 14.</li><li>If <code>subwordOffset</code> is 1, then the output is stored at indices 1, 3, 5, &mldr;, 15.</li></ul><p><code>unsignedA</code> and <code>unsignedB</code> flag that the <code>int8</code> LLVM inputs are unsigned.</p><p>The <code>clamp</code> flag is used to saturate the output of type T to numeric_limits<t>::max()
in case of overflow.</p><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-11>Attributes:&nbsp;<a class=headline-hash href=#attributes-11>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>subwordOffset</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute whose minimum value is 0 whose maximum value is 1</td></tr><tr><td><code>unsignedA</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>unsignedB</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>clamp</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-11>Operands:&nbsp;<a class=headline-hash href=#operands-11>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>sourceA</code></td><td>vector of 16-bit float or bfloat16 type or 8-bit signless integer or 8-bit signed integer or 8-bit unsigned integer values of length 16</td></tr><tr><td style=text-align:center><code>sourceB</code></td><td>vector of 16-bit float or bfloat16 type or 8-bit signless integer or 8-bit signed integer or 8-bit unsigned integer values of length 16</td></tr><tr><td style=text-align:center><code>destC</code></td><td>vector of 32-bit float or 32-bit signless integer values of length 4/8 or vector of 16-bit float or bfloat16 type values of length 8/16</td></tr></tbody></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>destD</code></td><td>vector of 32-bit float or 32-bit signless integer values of length 4/8 or vector of 16-bit float or bfloat16 type values of length 8/16</td></tr></tbody></table><h2 id=attributes-12>Attributes&nbsp;<a class=headline-hash href=#attributes-12>¶</a></h2><h3 id=mfmapermbattr>MFMAPermBAttr&nbsp;<a class=headline-hash href=#mfmapermbattr>¶</a></h3><p>The possible permutations of the lanes storing B available in an MFMA</p><p>Syntax:</p><pre tabindex=0><code>#amdgpu.mfma_perm_b&lt;
  ::mlir::amdgpu::MFMAPermB   # value
&gt;
</code></pre><p>Enum cases:</p><ul><li>none (<code>none</code>)</li><li>bcast_first_32 (<code>bcast_first_32</code>)</li><li>bcast_second_32 (<code>bcast_second_32</code>)</li><li>rotate_16_right (<code>rotate_16_right</code>)</li><li>bcast_first_16 (<code>bcast_first_16</code>)</li><li>bcast_second_16 (<code>bcast_second_16</code>)</li><li>bcast_third_16 (<code>bcast_third_16</code>)</li><li>bcast_fourth_16 (<code>bcast_fourth_16</code>)</li></ul><h4 id=parameters>Parameters:&nbsp;<a class=headline-hash href=#parameters>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::amdgpu::MFMAPermB</code></td><td>an enum of type MFMAPermB</td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://mlir.llvm.org/docs/Dialects/Affine/ title="'affine' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - 'affine' Dialect</a>
<a class="nav nav-next" href=https://mlir.llvm.org/docs/Dialects/AMX/ title="'amx' Dialect">Next - 'amx' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=https://mlir.llvm.org/users/>Users of MLIR</a></li><li><a href=https://mlir.llvm.org/pubs/>MLIR Related Publications</a></li><li><a href=https://mlir.llvm.org/talks/>Talks</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/deprecation/>Deprecations & Current Refactoring<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/deprecation/TestingGuide/>Testing Guide haha</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/getting_started/ReportingIssues/>Reporting Issues</a></li><li><a href=https://mlir.llvm.org/getting_started/Debugging/>Debugging Tips</a></li><li><a href=https://mlir.llvm.org/getting_started/Faq/>FAQ</a></li><li><a href=https://mlir.llvm.org/getting_started/Contributing/>How to Contribute</a></li><li><a href=https://mlir.llvm.org/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=https://mlir.llvm.org/getting_started/openprojects/>Open Projects</a></li><li><a href=https://mlir.llvm.org/getting_started/Glossary/>Glossary</a></li><li><a href=https://mlir.llvm.org/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-reduce/>MLIR Reduce</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/ActionTracing/>Action: Tracing and Debugging MLIR-based Compilers</a></li><li><a href=https://mlir.llvm.org/docs/BufferDeallocationInternals/>Buffer Deallocation - Internals</a></li><li><a href=https://mlir.llvm.org/docs/Bufferization/>Bufferization</a></li><li><a href=https://mlir.llvm.org/docs/DataLayout/>Data Layout Modeling</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/DefiningDialects/>Defining Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/DefiningDialects/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Operations/>Operation Definition Specification (ODS)</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/DialectConversion/>Dialect Conversion</a></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Affine/>'affine' Dialect</a></li><li class=active><a href=https://mlir.llvm.org/docs/Dialects/AMDGPU/>'amdgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArithOps/>'arith' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSME/>'ArmSME' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IndexOps/>'index' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IRDL/>'irdl' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Mesh/>'mesh' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/>'omp' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/UBOps/>'ub' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MatchOpInterfaces/>OpInterface definitions</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Interfaces/>Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=https://mlir.llvm.org/docs/BytecodeFormat/>MLIR Bytecode Format</a></li><li><a href=https://mlir.llvm.org/docs/CAPI/>MLIR C API</a></li><li><a href=https://mlir.llvm.org/docs/LangRef/>MLIR Language Reference</a></li><li><a href=https://mlir.llvm.org/docs/ReleaseNotes/>MLIR Release Notes</a></li><li><a href=https://mlir.llvm.org/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=https://mlir.llvm.org/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/Passes/>Passes</a></li><li><a href=https://mlir.llvm.org/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=https://mlir.llvm.org/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=https://mlir.llvm.org/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/SideEffectsAndSpeculation/>Side Effects & Speculation</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/ShapeInference/>Shape Inference</a></li><li><a href=https://mlir.llvm.org/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=https://mlir.llvm.org/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=https://mlir.llvm.org/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Traits/>Traits<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Traits/Broadcastable/>The `Broadcastable` Trait</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/transform/>Transform Dialect Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch0/>Chapter 0: A Primer on “Structured” Linalg Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch1/>Chapter 1: Combining Existing Transformations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch2/>Chapter 2: Adding a Simple New Transformation Operation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch3/>Chapter 3: More than Simple Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/ChH/>Chapter H: Reproducing Halide Schedule</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>