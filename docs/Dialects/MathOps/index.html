<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'math' Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.119.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/MathOps/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://mlir.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li></ul></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&amp;list_id=177877&amp;order=changeddate%20DESC%2Cpriority%2Cbug_severity&amp;product=MLIR&amp;query_format=specific">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>'math' Dialect</h1><p>The math dialect is intended to hold mathematical operations on integer and
floating types beyond simple arithmetics. Each operation works on scalar, vector
or tensor type. On vector and tensor type operations apply elementwise unless
explicitly specified otherwise. As an example, the floating point absolute value
can be expressed as:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar absolute value.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> math<span class=p>.</span>absf <span class=nv>%b</span> <span class=p>:</span> <span class=k>f64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Vector elementwise absolute value.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%f</span> <span class=p>=</span> math<span class=p>.</span>absf <span class=nv>%g</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Tensor elementwise absolute value.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%x</span> <span class=p>=</span> math<span class=p>.</span>absf <span class=nv>%y</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span>f8<span class=p>&gt;</span>
</span></span></code></pre></div><p><nav id=TableOfContents><ul><li><a href=#operations>Operations</a><ul><li><a href=#mathabsf-mathabsfop><code>math.absf</code> (math::AbsFOp)</a></li><li><a href=#mathabsi-mathabsiop><code>math.absi</code> (math::AbsIOp)</a></li><li><a href=#mathacos-mathacosop><code>math.acos</code> (math::AcosOp)</a></li><li><a href=#mathatan-mathatanop><code>math.atan</code> (math::AtanOp)</a></li><li><a href=#mathatan2-mathatan2op><code>math.atan2</code> (math::Atan2Op)</a></li><li><a href=#mathcbrt-mathcbrtop><code>math.cbrt</code> (math::CbrtOp)</a></li><li><a href=#mathceil-mathceilop><code>math.ceil</code> (math::CeilOp)</a></li><li><a href=#mathcopysign-mathcopysignop><code>math.copysign</code> (math::CopySignOp)</a></li><li><a href=#mathcos-mathcosop><code>math.cos</code> (math::CosOp)</a></li><li><a href=#mathctlz-mathcountleadingzerosop><code>math.ctlz</code> (math::CountLeadingZerosOp)</a></li><li><a href=#mathctpop-mathctpopop><code>math.ctpop</code> (math::CtPopOp)</a></li><li><a href=#mathcttz-mathcounttrailingzerosop><code>math.cttz</code> (math::CountTrailingZerosOp)</a></li><li><a href=#matherf-matherfop><code>math.erf</code> (math::ErfOp)</a></li><li><a href=#mathexp-mathexpop><code>math.exp</code> (math::ExpOp)</a></li><li><a href=#mathexp2-mathexp2op><code>math.exp2</code> (math::Exp2Op)</a></li><li><a href=#mathexpm1-mathexpm1op><code>math.expm1</code> (math::ExpM1Op)</a></li><li><a href=#mathfloor-mathfloorop><code>math.floor</code> (math::FloorOp)</a></li><li><a href=#mathfma-mathfmaop><code>math.fma</code> (math::FmaOp)</a></li><li><a href=#mathfpowi-mathfpowiop><code>math.fpowi</code> (math::FPowIOp)</a></li><li><a href=#mathipowi-mathipowiop><code>math.ipowi</code> (math::IPowIOp)</a></li><li><a href=#mathlog-mathlogop><code>math.log</code> (math::LogOp)</a></li><li><a href=#mathlog10-mathlog10op><code>math.log10</code> (math::Log10Op)</a></li><li><a href=#mathlog1p-mathlog1pop><code>math.log1p</code> (math::Log1pOp)</a></li><li><a href=#mathlog2-mathlog2op><code>math.log2</code> (math::Log2Op)</a></li><li><a href=#mathpowf-mathpowfop><code>math.powf</code> (math::PowFOp)</a></li><li><a href=#mathround-mathroundop><code>math.round</code> (math::RoundOp)</a></li><li><a href=#mathroundeven-mathroundevenop><code>math.roundeven</code> (math::RoundEvenOp)</a></li><li><a href=#mathrsqrt-mathrsqrtop><code>math.rsqrt</code> (math::RsqrtOp)</a></li><li><a href=#mathsin-mathsinop><code>math.sin</code> (math::SinOp)</a></li><li><a href=#mathsqrt-mathsqrtop><code>math.sqrt</code> (math::SqrtOp)</a></li><li><a href=#mathtan-mathtanop><code>math.tan</code> (math::TanOp)</a></li><li><a href=#mathtanh-mathtanhop><code>math.tanh</code> (math::TanhOp)</a></li><li><a href=#mathtrunc-mathtruncop><code>math.trunc</code> (math::TruncOp)</a></li></ul></li></ul></nav><h2 id=operations>Operations&nbsp;<a class=headline-hash href=#operations>¶</a></h2><p><a href=https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/Math/IR/MathOps.td>source</a></p><h3 id=mathabsf-mathabsfop><code>math.absf</code> (math::AbsFOp)&nbsp;<a class=headline-hash href=#mathabsf-mathabsfop>¶</a></h3><p><em>Floating point absolute-value operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `math.absf` $operand (`fastmath` `` $fastmath^)?
              attr-dict `:` type($result)
</code></pre><p>The <code>absf</code> operation computes the absolute value. It takes one operand of
floating point type (i.e., scalar, tensor or vector) and returns one result
of the same type.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar absolute value.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> math<span class=p>.</span>absf <span class=nv>%b</span> <span class=p>:</span> <span class=k>f64</span>
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait, Elementwise, SameOperandsAndResultType, Scalarizable, Tensorizable, Vectorizable</p><p>Interfaces: ArithFastMathInterface, ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), VectorUnrollOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmath</code></td><td>::mlir::arith::FastMathFlagsAttr</td><td><details><summary>Floating point fast math flags</summary><p>Enum cases:</p><ul><li>none (<code>none</code>)</li><li>reassoc (<code>reassoc</code>)</li><li>nnan (<code>nnan</code>)</li><li>ninf (<code>ninf</code>)</li><li>nsz (<code>nsz</code>)</li><li>arcp (<code>arcp</code>)</li><li>contract (<code>contract</code>)</li><li>afn (<code>afn</code>)</li><li>fast (<code>fast</code>)</li></ul></details></td></tr></table><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>floating-point-like</td></tr></tbody></table><h3 id=mathabsi-mathabsiop><code>math.absi</code> (math::AbsIOp)&nbsp;<a class=headline-hash href=#mathabsi-mathabsiop>¶</a></h3><p><em>Integer absolute-value operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `math.absi` $operand attr-dict `:` type($result)
</code></pre><p>The <code>absi</code> operation computes the absolute value. It takes one operand of
integer type (i.e., scalar, tensor or vector) and returns one result of the
same type.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar absolute value.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> math<span class=p>.</span>absi <span class=nv>%b</span> <span class=p>:</span> <span class=k>i64</span>
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait, Elementwise, SameOperandsAndResultType, Scalarizable, Tensorizable, Vectorizable</p><p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), VectorUnrollOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless-integer-like</td></tr></tbody></table><h3 id=mathacos-mathacosop><code>math.acos</code> (math::AcosOp)&nbsp;<a class=headline-hash href=#mathacos-mathacosop>¶</a></h3><p><em>Arcus cosine of the specified value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `math.acos` $operand (`fastmath` `` $fastmath^)?
              attr-dict `:` type($result)
</code></pre><p>Syntax:</p><pre tabindex=0><code>operation ::= ssa-id `=` `math.acos` ssa-use `:` type
</code></pre><p>The <code>acos</code> operation computes the arcus cosine of a given value. It takes one
operand of floating point type (i.e., scalar, tensor or vector) and returns one
result of the same type. It has no standard attributes.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar arcus cosine value.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> math<span class=p>.</span>acos <span class=nv>%b</span> <span class=p>:</span> <span class=k>f64</span>
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait, Elementwise, SameOperandsAndResultType, Scalarizable, Tensorizable, Vectorizable</p><p>Interfaces: ArithFastMathInterface, ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), VectorUnrollOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmath</code></td><td>::mlir::arith::FastMathFlagsAttr</td><td><details><summary>Floating point fast math flags</summary><p>Enum cases:</p><ul><li>none (<code>none</code>)</li><li>reassoc (<code>reassoc</code>)</li><li>nnan (<code>nnan</code>)</li><li>ninf (<code>ninf</code>)</li><li>nsz (<code>nsz</code>)</li><li>arcp (<code>arcp</code>)</li><li>contract (<code>contract</code>)</li><li>afn (<code>afn</code>)</li><li>fast (<code>fast</code>)</li></ul></details></td></tr></table><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>floating-point-like</td></tr></tbody></table><h3 id=mathatan-mathatanop><code>math.atan</code> (math::AtanOp)&nbsp;<a class=headline-hash href=#mathatan-mathatanop>¶</a></h3><p><em>Arcus tangent of the given value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `math.atan` $operand (`fastmath` `` $fastmath^)?
              attr-dict `:` type($result)
</code></pre><p>Syntax:</p><pre tabindex=0><code>operation ::= ssa-id `=` `math.atan` ssa-use `:` type
</code></pre><p>The <code>atan</code> operation computes the arcus tangent of a given value. It takes
one operand of floating point type (i.e., scalar, tensor or vector) and returns
one result of the same type. It has no standard attributes.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Arcus tangent of scalar value.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> math<span class=p>.</span>atan <span class=nv>%b</span> <span class=p>:</span> <span class=k>f64</span>
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait, Elementwise, SameOperandsAndResultType, Scalarizable, Tensorizable, Vectorizable</p><p>Interfaces: ArithFastMathInterface, ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), VectorUnrollOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmath</code></td><td>::mlir::arith::FastMathFlagsAttr</td><td><details><summary>Floating point fast math flags</summary><p>Enum cases:</p><ul><li>none (<code>none</code>)</li><li>reassoc (<code>reassoc</code>)</li><li>nnan (<code>nnan</code>)</li><li>ninf (<code>ninf</code>)</li><li>nsz (<code>nsz</code>)</li><li>arcp (<code>arcp</code>)</li><li>contract (<code>contract</code>)</li><li>afn (<code>afn</code>)</li><li>fast (<code>fast</code>)</li></ul></details></td></tr></table><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>floating-point-like</td></tr></tbody></table><h3 id=mathatan2-mathatan2op><code>math.atan2</code> (math::Atan2Op)&nbsp;<a class=headline-hash href=#mathatan2-mathatan2op>¶</a></h3><p><em>2-argument arcus tangent of the given values</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `math.atan2` $lhs `,` $rhs (`fastmath` `` $fastmath^)?
              attr-dict `:` type($result)
</code></pre><p>Syntax:</p><pre tabindex=0><code>operation ::= ssa-id `=` `math.atan2` ssa-use `,` ssa-use `:` type
</code></pre><p>The <code>atan2</code> operation takes two operands and returns one result, all of
which must be of the same type. The operands must be of floating point type
(i.e., scalar, tensor or vector).</p><p>The 2-argument arcus tangent <code>atan2(y, x)</code> returns the angle in the
Euclidian plane between the positive x-axis and the ray through the point
(x, y). It is a generalization of the 1-argument arcus tangent which
returns the angle on the basis of the ratio y/x.</p><p>See also
<a href=https://en.wikipedia.org/wiki/Atan2>https://en.wikipedia.org/wiki/Atan2</a></p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar variant.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> math<span class=p>.</span>atan2 <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>f32</span>
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait, Elementwise, SameOperandsAndResultType, Scalarizable, Tensorizable, Vectorizable</p><p>Interfaces: ArithFastMathInterface, ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), VectorUnrollOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-3>Attributes:&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmath</code></td><td>::mlir::arith::FastMathFlagsAttr</td><td><details><summary>Floating point fast math flags</summary><p>Enum cases:</p><ul><li>none (<code>none</code>)</li><li>reassoc (<code>reassoc</code>)</li><li>nnan (<code>nnan</code>)</li><li>ninf (<code>ninf</code>)</li><li>nsz (<code>nsz</code>)</li><li>arcp (<code>arcp</code>)</li><li>contract (<code>contract</code>)</li><li>afn (<code>afn</code>)</li><li>fast (<code>fast</code>)</li></ul></details></td></tr></table><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>floating-point-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>floating-point-like</td></tr></tbody></table><h3 id=mathcbrt-mathcbrtop><code>math.cbrt</code> (math::CbrtOp)&nbsp;<a class=headline-hash href=#mathcbrt-mathcbrtop>¶</a></h3><p><em>Cube root of the specified value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `math.cbrt` $operand (`fastmath` `` $fastmath^)?
              attr-dict `:` type($result)
</code></pre><p>The <code>cbrt</code> operation computes the cube root. It takes one operand of
floating point type (i.e., scalar, tensor or vector) and returns one result
of the same type. It has no standard attributes.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar cube root value.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> math<span class=p>.</span>cbrt <span class=nv>%b</span> <span class=p>:</span> <span class=k>f64</span>
</span></span></code></pre></div><p>Note: This op is not equivalent to powf(&mldr;, 1/3.0).</p><p>Traits: AlwaysSpeculatableImplTrait, Elementwise, SameOperandsAndResultType, Scalarizable, Tensorizable, Vectorizable</p><p>Interfaces: ArithFastMathInterface, ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), VectorUnrollOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-4>Attributes:&nbsp;<a class=headline-hash href=#attributes-4>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmath</code></td><td>::mlir::arith::FastMathFlagsAttr</td><td><details><summary>Floating point fast math flags</summary><p>Enum cases:</p><ul><li>none (<code>none</code>)</li><li>reassoc (<code>reassoc</code>)</li><li>nnan (<code>nnan</code>)</li><li>ninf (<code>ninf</code>)</li><li>nsz (<code>nsz</code>)</li><li>arcp (<code>arcp</code>)</li><li>contract (<code>contract</code>)</li><li>afn (<code>afn</code>)</li><li>fast (<code>fast</code>)</li></ul></details></td></tr></table><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>floating-point-like</td></tr></tbody></table><h3 id=mathceil-mathceilop><code>math.ceil</code> (math::CeilOp)&nbsp;<a class=headline-hash href=#mathceil-mathceilop>¶</a></h3><p><em>Ceiling of the specified value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `math.ceil` $operand (`fastmath` `` $fastmath^)?
              attr-dict `:` type($result)
</code></pre><p>Syntax:</p><pre tabindex=0><code>operation ::= ssa-id `=` `math.ceil` ssa-use `:` type
</code></pre><p>The <code>ceil</code> operation computes the ceiling of a given value. It takes one
operand of floating point type (i.e., scalar, tensor or vector) and returns one
result of the same type. It has no standard attributes.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar ceiling value.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> math<span class=p>.</span>ceil <span class=nv>%b</span> <span class=p>:</span> <span class=k>f64</span>
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait, Elementwise, SameOperandsAndResultType, Scalarizable, Tensorizable, Vectorizable</p><p>Interfaces: ArithFastMathInterface, ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), VectorUnrollOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-5>Attributes:&nbsp;<a class=headline-hash href=#attributes-5>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmath</code></td><td>::mlir::arith::FastMathFlagsAttr</td><td><details><summary>Floating point fast math flags</summary><p>Enum cases:</p><ul><li>none (<code>none</code>)</li><li>reassoc (<code>reassoc</code>)</li><li>nnan (<code>nnan</code>)</li><li>ninf (<code>ninf</code>)</li><li>nsz (<code>nsz</code>)</li><li>arcp (<code>arcp</code>)</li><li>contract (<code>contract</code>)</li><li>afn (<code>afn</code>)</li><li>fast (<code>fast</code>)</li></ul></details></td></tr></table><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>floating-point-like</td></tr></tbody></table><h3 id=mathcopysign-mathcopysignop><code>math.copysign</code> (math::CopySignOp)&nbsp;<a class=headline-hash href=#mathcopysign-mathcopysignop>¶</a></h3><p><em>A copysign operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `math.copysign` $lhs `,` $rhs (`fastmath` `` $fastmath^)?
              attr-dict `:` type($result)
</code></pre><p>Syntax:</p><pre tabindex=0><code>operation ::= ssa-id `=` `math.copysign` ssa-use `,` ssa-use `:` type
</code></pre><p>The <code>copysign</code> returns a value with the magnitude of the first operand and
the sign of the second operand. It takes two operands and returns one result of
the same type. The operands must be of floating point type (i.e., scalar,
tensor or vector). It has no standard attributes.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar copysign value.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> math<span class=p>.</span>copysign <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>f64</span>
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait, Elementwise, SameOperandsAndResultType, Scalarizable, Tensorizable, Vectorizable</p><p>Interfaces: ArithFastMathInterface, ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), VectorUnrollOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-6>Attributes:&nbsp;<a class=headline-hash href=#attributes-6>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmath</code></td><td>::mlir::arith::FastMathFlagsAttr</td><td><details><summary>Floating point fast math flags</summary><p>Enum cases:</p><ul><li>none (<code>none</code>)</li><li>reassoc (<code>reassoc</code>)</li><li>nnan (<code>nnan</code>)</li><li>ninf (<code>ninf</code>)</li><li>nsz (<code>nsz</code>)</li><li>arcp (<code>arcp</code>)</li><li>contract (<code>contract</code>)</li><li>afn (<code>afn</code>)</li><li>fast (<code>fast</code>)</li></ul></details></td></tr></table><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>floating-point-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>floating-point-like</td></tr></tbody></table><h3 id=mathcos-mathcosop><code>math.cos</code> (math::CosOp)&nbsp;<a class=headline-hash href=#mathcos-mathcosop>¶</a></h3><p><em>Cosine of the specified value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `math.cos` $operand (`fastmath` `` $fastmath^)?
              attr-dict `:` type($result)
</code></pre><p>Syntax:</p><pre tabindex=0><code>operation ::= ssa-id `=` `math.cos` ssa-use `:` type
</code></pre><p>The <code>cos</code> operation computes the cosine of a given value. It takes one
operand of floating point type (i.e., scalar, tensor or vector) and returns one
result of the same type. It has no standard attributes.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar cosine value.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> math<span class=p>.</span>cos <span class=nv>%b</span> <span class=p>:</span> <span class=k>f64</span>
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait, Elementwise, SameOperandsAndResultType, Scalarizable, Tensorizable, Vectorizable</p><p>Interfaces: ArithFastMathInterface, ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), VectorUnrollOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-7>Attributes:&nbsp;<a class=headline-hash href=#attributes-7>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmath</code></td><td>::mlir::arith::FastMathFlagsAttr</td><td><details><summary>Floating point fast math flags</summary><p>Enum cases:</p><ul><li>none (<code>none</code>)</li><li>reassoc (<code>reassoc</code>)</li><li>nnan (<code>nnan</code>)</li><li>ninf (<code>ninf</code>)</li><li>nsz (<code>nsz</code>)</li><li>arcp (<code>arcp</code>)</li><li>contract (<code>contract</code>)</li><li>afn (<code>afn</code>)</li><li>fast (<code>fast</code>)</li></ul></details></td></tr></table><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-8>Results:&nbsp;<a class=headline-hash href=#results-8>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>floating-point-like</td></tr></tbody></table><h3 id=mathctlz-mathcountleadingzerosop><code>math.ctlz</code> (math::CountLeadingZerosOp)&nbsp;<a class=headline-hash href=#mathctlz-mathcountleadingzerosop>¶</a></h3><p><em>Counts the leading zeros an integer value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `math.ctlz` $operand attr-dict `:` type($result)
</code></pre><p>The <code>ctlz</code> operation computes the number of leading zeros of an integer value.
It operates on scalar, tensor or vector.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar ctlz function value.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> math<span class=p>.</span>ctlz <span class=nv>%b</span> <span class=p>:</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait, Elementwise, SameOperandsAndResultType, Scalarizable, Tensorizable, Vectorizable</p><p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), VectorUnrollOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-9>Operands:&nbsp;<a class=headline-hash href=#operands-9>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-9>Results:&nbsp;<a class=headline-hash href=#results-9>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless-integer-like</td></tr></tbody></table><h3 id=mathctpop-mathctpopop><code>math.ctpop</code> (math::CtPopOp)&nbsp;<a class=headline-hash href=#mathctpop-mathctpopop>¶</a></h3><p><em>Counts the number of set bits of an integer value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `math.ctpop` $operand attr-dict `:` type($result)
</code></pre><p>The <code>ctpop</code> operation computes the number of set bits of an integer value.
It operates on scalar, tensor or vector.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar ctpop function value.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> math<span class=p>.</span>ctpop <span class=nv>%b</span> <span class=p>:</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait, Elementwise, SameOperandsAndResultType, Scalarizable, Tensorizable, Vectorizable</p><p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), VectorUnrollOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-10>Operands:&nbsp;<a class=headline-hash href=#operands-10>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-10>Results:&nbsp;<a class=headline-hash href=#results-10>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless-integer-like</td></tr></tbody></table><h3 id=mathcttz-mathcounttrailingzerosop><code>math.cttz</code> (math::CountTrailingZerosOp)&nbsp;<a class=headline-hash href=#mathcttz-mathcounttrailingzerosop>¶</a></h3><p><em>Counts the trailing zeros an integer value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `math.cttz` $operand attr-dict `:` type($result)
</code></pre><p>The <code>cttz</code> operation computes the number of trailing zeros of an integer value.
It operates on scalar, tensor or vector.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar cttz function value.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> math<span class=p>.</span>cttz <span class=nv>%b</span> <span class=p>:</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait, Elementwise, SameOperandsAndResultType, Scalarizable, Tensorizable, Vectorizable</p><p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), VectorUnrollOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-11>Operands:&nbsp;<a class=headline-hash href=#operands-11>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-11>Results:&nbsp;<a class=headline-hash href=#results-11>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless-integer-like</td></tr></tbody></table><h3 id=matherf-matherfop><code>math.erf</code> (math::ErfOp)&nbsp;<a class=headline-hash href=#matherf-matherfop>¶</a></h3><p><em>Error function of the specified value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `math.erf` $operand (`fastmath` `` $fastmath^)?
              attr-dict `:` type($result)
</code></pre><p>Syntax:</p><pre tabindex=0><code>operation ::= ssa-id `=` `math.erf` ssa-use `:` type
</code></pre><p>The <code>erf</code> operation computes the error function. It takes one operand of
floating point type (i.e., scalar, tensor or vector) and returns one result of
the same type. It has no standard attributes.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar error function value.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> math<span class=p>.</span>erf <span class=nv>%b</span> <span class=p>:</span> <span class=k>f64</span>
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait, Elementwise, SameOperandsAndResultType, Scalarizable, Tensorizable, Vectorizable</p><p>Interfaces: ArithFastMathInterface, ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), VectorUnrollOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-8>Attributes:&nbsp;<a class=headline-hash href=#attributes-8>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmath</code></td><td>::mlir::arith::FastMathFlagsAttr</td><td><details><summary>Floating point fast math flags</summary><p>Enum cases:</p><ul><li>none (<code>none</code>)</li><li>reassoc (<code>reassoc</code>)</li><li>nnan (<code>nnan</code>)</li><li>ninf (<code>ninf</code>)</li><li>nsz (<code>nsz</code>)</li><li>arcp (<code>arcp</code>)</li><li>contract (<code>contract</code>)</li><li>afn (<code>afn</code>)</li><li>fast (<code>fast</code>)</li></ul></details></td></tr></table><h4 id=operands-12>Operands:&nbsp;<a class=headline-hash href=#operands-12>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-12>Results:&nbsp;<a class=headline-hash href=#results-12>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>floating-point-like</td></tr></tbody></table><h3 id=mathexp-mathexpop><code>math.exp</code> (math::ExpOp)&nbsp;<a class=headline-hash href=#mathexp-mathexpop>¶</a></h3><p><em>Base-e exponential of the specified value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `math.exp` $operand (`fastmath` `` $fastmath^)?
              attr-dict `:` type($result)
</code></pre><p>Syntax:</p><pre tabindex=0><code>operation ::= ssa-id `=` `math.exp` ssa-use `:` type
</code></pre><p>The <code>exp</code> operation takes one operand of floating point type (i.e., scalar,
tensor or vector) and returns one result of the same type. It has no standard
attributes.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar natural exponential.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> math<span class=p>.</span>exp <span class=nv>%b</span> <span class=p>:</span> <span class=k>f64</span>
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait, Elementwise, SameOperandsAndResultType, Scalarizable, Tensorizable, Vectorizable</p><p>Interfaces: ArithFastMathInterface, ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), VectorUnrollOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-9>Attributes:&nbsp;<a class=headline-hash href=#attributes-9>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmath</code></td><td>::mlir::arith::FastMathFlagsAttr</td><td><details><summary>Floating point fast math flags</summary><p>Enum cases:</p><ul><li>none (<code>none</code>)</li><li>reassoc (<code>reassoc</code>)</li><li>nnan (<code>nnan</code>)</li><li>ninf (<code>ninf</code>)</li><li>nsz (<code>nsz</code>)</li><li>arcp (<code>arcp</code>)</li><li>contract (<code>contract</code>)</li><li>afn (<code>afn</code>)</li><li>fast (<code>fast</code>)</li></ul></details></td></tr></table><h4 id=operands-13>Operands:&nbsp;<a class=headline-hash href=#operands-13>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-13>Results:&nbsp;<a class=headline-hash href=#results-13>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>floating-point-like</td></tr></tbody></table><h3 id=mathexp2-mathexp2op><code>math.exp2</code> (math::Exp2Op)&nbsp;<a class=headline-hash href=#mathexp2-mathexp2op>¶</a></h3><p><em>Base-2 exponential of the specified value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `math.exp2` $operand (`fastmath` `` $fastmath^)?
              attr-dict `:` type($result)
</code></pre><p>Syntax:</p><pre tabindex=0><code>operation ::= ssa-id `=` `math.exp2` ssa-use `:` type
</code></pre><p>The <code>exp</code> operation takes one operand of floating point type (i.e., scalar,
tensor or vector) and returns one result of the same type. It has no standard
attributes.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar natural exponential.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> math<span class=p>.</span>exp2 <span class=nv>%b</span> <span class=p>:</span> <span class=k>f64</span>
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait, Elementwise, SameOperandsAndResultType, Scalarizable, Tensorizable, Vectorizable</p><p>Interfaces: ArithFastMathInterface, ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), VectorUnrollOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-10>Attributes:&nbsp;<a class=headline-hash href=#attributes-10>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmath</code></td><td>::mlir::arith::FastMathFlagsAttr</td><td><details><summary>Floating point fast math flags</summary><p>Enum cases:</p><ul><li>none (<code>none</code>)</li><li>reassoc (<code>reassoc</code>)</li><li>nnan (<code>nnan</code>)</li><li>ninf (<code>ninf</code>)</li><li>nsz (<code>nsz</code>)</li><li>arcp (<code>arcp</code>)</li><li>contract (<code>contract</code>)</li><li>afn (<code>afn</code>)</li><li>fast (<code>fast</code>)</li></ul></details></td></tr></table><h4 id=operands-14>Operands:&nbsp;<a class=headline-hash href=#operands-14>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-14>Results:&nbsp;<a class=headline-hash href=#results-14>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>floating-point-like</td></tr></tbody></table><h3 id=mathexpm1-mathexpm1op><code>math.expm1</code> (math::ExpM1Op)&nbsp;<a class=headline-hash href=#mathexpm1-mathexpm1op>¶</a></h3><p><em>Base-e exponential of the specified value minus 1</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `math.expm1` $operand (`fastmath` `` $fastmath^)?
              attr-dict `:` type($result)
</code></pre><p>Syntax:</p><pre tabindex=0><code>operation ::= ssa-id `=` `math.expm1` ssa-use `:` type
</code></pre><p>expm1(x) := exp(x) - 1</p><p>The <code>expm1</code> operation takes one operand of floating point type (i.e.,
scalar, tensor or vector) and returns one result of the same type. It has no
standard attributes.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar natural exponential minus 1.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> math<span class=p>.</span>expm1 <span class=nv>%b</span> <span class=p>:</span> <span class=k>f64</span>
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait, Elementwise, SameOperandsAndResultType, Scalarizable, Tensorizable, Vectorizable</p><p>Interfaces: ArithFastMathInterface, ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), VectorUnrollOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-11>Attributes:&nbsp;<a class=headline-hash href=#attributes-11>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmath</code></td><td>::mlir::arith::FastMathFlagsAttr</td><td><details><summary>Floating point fast math flags</summary><p>Enum cases:</p><ul><li>none (<code>none</code>)</li><li>reassoc (<code>reassoc</code>)</li><li>nnan (<code>nnan</code>)</li><li>ninf (<code>ninf</code>)</li><li>nsz (<code>nsz</code>)</li><li>arcp (<code>arcp</code>)</li><li>contract (<code>contract</code>)</li><li>afn (<code>afn</code>)</li><li>fast (<code>fast</code>)</li></ul></details></td></tr></table><h4 id=operands-15>Operands:&nbsp;<a class=headline-hash href=#operands-15>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-15>Results:&nbsp;<a class=headline-hash href=#results-15>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>floating-point-like</td></tr></tbody></table><h3 id=mathfloor-mathfloorop><code>math.floor</code> (math::FloorOp)&nbsp;<a class=headline-hash href=#mathfloor-mathfloorop>¶</a></h3><p><em>Floor of the specified value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `math.floor` $operand (`fastmath` `` $fastmath^)?
              attr-dict `:` type($result)
</code></pre><p>Syntax:</p><pre tabindex=0><code>operation ::= ssa-id `=` `math.floor` ssa-use `:` type
</code></pre><p>The <code>floor</code> operation computes the floor of a given value. It takes one
operand of floating point type (i.e., scalar, tensor or vector) and returns one
result of the same type. It has no standard attributes.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar floor value.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> math<span class=p>.</span>floor <span class=nv>%b</span> <span class=p>:</span> <span class=k>f64</span>
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait, Elementwise, SameOperandsAndResultType, Scalarizable, Tensorizable, Vectorizable</p><p>Interfaces: ArithFastMathInterface, ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), VectorUnrollOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-12>Attributes:&nbsp;<a class=headline-hash href=#attributes-12>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmath</code></td><td>::mlir::arith::FastMathFlagsAttr</td><td><details><summary>Floating point fast math flags</summary><p>Enum cases:</p><ul><li>none (<code>none</code>)</li><li>reassoc (<code>reassoc</code>)</li><li>nnan (<code>nnan</code>)</li><li>ninf (<code>ninf</code>)</li><li>nsz (<code>nsz</code>)</li><li>arcp (<code>arcp</code>)</li><li>contract (<code>contract</code>)</li><li>afn (<code>afn</code>)</li><li>fast (<code>fast</code>)</li></ul></details></td></tr></table><h4 id=operands-16>Operands:&nbsp;<a class=headline-hash href=#operands-16>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-16>Results:&nbsp;<a class=headline-hash href=#results-16>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>floating-point-like</td></tr></tbody></table><h3 id=mathfma-mathfmaop><code>math.fma</code> (math::FmaOp)&nbsp;<a class=headline-hash href=#mathfma-mathfmaop>¶</a></h3><p><em>Floating point fused multipy-add operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `math.fma` $a `,` $b `,` $c (`fastmath` `` $fastmath^)?
              attr-dict `:` type($result)
</code></pre><p>Syntax:</p><pre tabindex=0><code>operation ::= ssa-id `=` `math.fma` ssa-use `,` ssa-use `,` ssa-use `:` type
</code></pre><p>The <code>fma</code> operation takes three operands and returns one result, each of
these is required to be the same type. Operands must be of floating point type
(i.e., scalar, tensor or vector).</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar fused multiply-add: d = a*b + c
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%d</span> <span class=p>=</span> math<span class=p>.</span>fma <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>f64</span>
</span></span></code></pre></div><p>The semantics of the operation correspond to those of the <code>llvm.fma</code>
<a href=https://llvm.org/docs/LangRef.html#llvm-fma-intrinsic>intrinsic</a>. In the
particular case of lowering to LLVM, this is guaranteed to lower
to the <code>llvm.fma.*</code> intrinsic.</p><p>Traits: AlwaysSpeculatableImplTrait, Elementwise, SameOperandsAndResultType, Scalarizable, Tensorizable, Vectorizable</p><p>Interfaces: ArithFastMathInterface, ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), VectorUnrollOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-13>Attributes:&nbsp;<a class=headline-hash href=#attributes-13>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmath</code></td><td>::mlir::arith::FastMathFlagsAttr</td><td><details><summary>Floating point fast math flags</summary><p>Enum cases:</p><ul><li>none (<code>none</code>)</li><li>reassoc (<code>reassoc</code>)</li><li>nnan (<code>nnan</code>)</li><li>ninf (<code>ninf</code>)</li><li>nsz (<code>nsz</code>)</li><li>arcp (<code>arcp</code>)</li><li>contract (<code>contract</code>)</li><li>afn (<code>afn</code>)</li><li>fast (<code>fast</code>)</li></ul></details></td></tr></table><h4 id=operands-17>Operands:&nbsp;<a class=headline-hash href=#operands-17>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>floating-point-like</td></tr><tr><td style=text-align:center><code>b</code></td><td>floating-point-like</td></tr><tr><td style=text-align:center><code>c</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-17>Results:&nbsp;<a class=headline-hash href=#results-17>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>floating-point-like</td></tr></tbody></table><h3 id=mathfpowi-mathfpowiop><code>math.fpowi</code> (math::FPowIOp)&nbsp;<a class=headline-hash href=#mathfpowi-mathfpowiop>¶</a></h3><p><em>Floating point raised to the signed integer power</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `math.fpowi` $lhs `,` $rhs (`fastmath` `` $fastmath^)?
              attr-dict `:` type($lhs) `,` type($rhs)
</code></pre><p>Syntax:</p><pre tabindex=0><code>operation ::= ssa-id `=` `math.fpowi` ssa-use `,` ssa-use `:` type
</code></pre><p>The <code>fpowi</code> operation takes a <code>base</code> operand of floating point type
(i.e. scalar, tensor or vector) and a <code>power</code> operand of integer type
(also scalar, tensor or vector) and returns one result of the same type
as <code>base</code>. The result is <code>base</code> raised to the power of <code>power</code>.
The operation is elementwise for non-scalars, e.g.:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%v</span> <span class=p>=</span> math<span class=p>.</span>fpowi <span class=nv>%base</span><span class=p>,</span> <span class=nv>%power</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>i32</span>
</span></span></code></pre></div><p>The result is a vector of:</p><pre tabindex=0><code>[&lt;math.fpowi %base[0], %power[0]&gt;, &lt;math.fpowi %base[1], %power[1]&gt;]
</code></pre><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar exponentiation.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> math<span class=p>.</span>fpowi <span class=nv>%base</span><span class=p>,</span> <span class=nv>%power</span> <span class=p>:</span> <span class=k>f64</span><span class=p>,</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait, Elementwise, SameOperandsAndResultShape, Scalarizable, Tensorizable, Vectorizable</p><p>Interfaces: ArithFastMathInterface, ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), VectorUnrollOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-14>Attributes:&nbsp;<a class=headline-hash href=#attributes-14>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmath</code></td><td>::mlir::arith::FastMathFlagsAttr</td><td><details><summary>Floating point fast math flags</summary><p>Enum cases:</p><ul><li>none (<code>none</code>)</li><li>reassoc (<code>reassoc</code>)</li><li>nnan (<code>nnan</code>)</li><li>ninf (<code>ninf</code>)</li><li>nsz (<code>nsz</code>)</li><li>arcp (<code>arcp</code>)</li><li>contract (<code>contract</code>)</li><li>afn (<code>afn</code>)</li><li>fast (<code>fast</code>)</li></ul></details></td></tr></table><h4 id=operands-18>Operands:&nbsp;<a class=headline-hash href=#operands-18>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>floating-point-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-18>Results:&nbsp;<a class=headline-hash href=#results-18>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>floating-point-like</td></tr></tbody></table><h3 id=mathipowi-mathipowiop><code>math.ipowi</code> (math::IPowIOp)&nbsp;<a class=headline-hash href=#mathipowi-mathipowiop>¶</a></h3><p><em>Signed integer raised to the power of operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `math.ipowi` $lhs `,` $rhs attr-dict `:` type($result)
</code></pre><p>Syntax:</p><pre tabindex=0><code>operation ::= ssa-id `=` `math.ipowi` ssa-use `,` ssa-use `:` type
</code></pre><p>The <code>ipowi</code> operation takes two operands of integer type (i.e., scalar,
tensor or vector) and returns one result of the same type. Operands
must have the same type.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar signed integer exponentiation.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> math<span class=p>.</span>ipowi <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait, Elementwise, SameOperandsAndResultType, Scalarizable, Tensorizable, Vectorizable</p><p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), VectorUnrollOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-19>Operands:&nbsp;<a class=headline-hash href=#operands-19>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-19>Results:&nbsp;<a class=headline-hash href=#results-19>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless-integer-like</td></tr></tbody></table><h3 id=mathlog-mathlogop><code>math.log</code> (math::LogOp)&nbsp;<a class=headline-hash href=#mathlog-mathlogop>¶</a></h3><p><em>Base-e logarithm of the specified value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `math.log` $operand (`fastmath` `` $fastmath^)?
              attr-dict `:` type($result)
</code></pre><p>Computes the base-e logarithm of the given value. It takes one operand of
floating point type (i.e., scalar, tensor or vector) and returns one result of
the same type.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar log operation.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%y</span> <span class=p>=</span> math<span class=p>.</span>log <span class=nv>%x</span> <span class=p>:</span> <span class=k>f64</span>
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait, Elementwise, SameOperandsAndResultType, Scalarizable, Tensorizable, Vectorizable</p><p>Interfaces: ArithFastMathInterface, ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), VectorUnrollOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-15>Attributes:&nbsp;<a class=headline-hash href=#attributes-15>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmath</code></td><td>::mlir::arith::FastMathFlagsAttr</td><td><details><summary>Floating point fast math flags</summary><p>Enum cases:</p><ul><li>none (<code>none</code>)</li><li>reassoc (<code>reassoc</code>)</li><li>nnan (<code>nnan</code>)</li><li>ninf (<code>ninf</code>)</li><li>nsz (<code>nsz</code>)</li><li>arcp (<code>arcp</code>)</li><li>contract (<code>contract</code>)</li><li>afn (<code>afn</code>)</li><li>fast (<code>fast</code>)</li></ul></details></td></tr></table><h4 id=operands-20>Operands:&nbsp;<a class=headline-hash href=#operands-20>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-20>Results:&nbsp;<a class=headline-hash href=#results-20>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>floating-point-like</td></tr></tbody></table><h3 id=mathlog10-mathlog10op><code>math.log10</code> (math::Log10Op)&nbsp;<a class=headline-hash href=#mathlog10-mathlog10op>¶</a></h3><p><em>Base-10 logarithm of the specified value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `math.log10` $operand (`fastmath` `` $fastmath^)?
              attr-dict `:` type($result)
</code></pre><p>Computes the base-10 logarithm of the given value. It takes one operand of
floating point type (i.e., scalar, tensor or vector) and returns one result of
the same type.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar log10 operation.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%y</span> <span class=p>=</span> math<span class=p>.</span>log10 <span class=nv>%x</span> <span class=p>:</span> <span class=k>f64</span>
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait, Elementwise, SameOperandsAndResultType, Scalarizable, Tensorizable, Vectorizable</p><p>Interfaces: ArithFastMathInterface, ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), VectorUnrollOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-16>Attributes:&nbsp;<a class=headline-hash href=#attributes-16>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmath</code></td><td>::mlir::arith::FastMathFlagsAttr</td><td><details><summary>Floating point fast math flags</summary><p>Enum cases:</p><ul><li>none (<code>none</code>)</li><li>reassoc (<code>reassoc</code>)</li><li>nnan (<code>nnan</code>)</li><li>ninf (<code>ninf</code>)</li><li>nsz (<code>nsz</code>)</li><li>arcp (<code>arcp</code>)</li><li>contract (<code>contract</code>)</li><li>afn (<code>afn</code>)</li><li>fast (<code>fast</code>)</li></ul></details></td></tr></table><h4 id=operands-21>Operands:&nbsp;<a class=headline-hash href=#operands-21>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-21>Results:&nbsp;<a class=headline-hash href=#results-21>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>floating-point-like</td></tr></tbody></table><h3 id=mathlog1p-mathlog1pop><code>math.log1p</code> (math::Log1pOp)&nbsp;<a class=headline-hash href=#mathlog1p-mathlog1pop>¶</a></h3><p><em>Computes the natural logarithm of one plus the given value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `math.log1p` $operand (`fastmath` `` $fastmath^)?
              attr-dict `:` type($result)
</code></pre><p>Computes the base-e logarithm of one plus the given value. It takes one
operand of floating point type (i.e., scalar, tensor or vector) and returns one
result of the same type.</p><p>log1p(x) := log(1 + x)</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar log1p operation.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%y</span> <span class=p>=</span> math<span class=p>.</span>log1p <span class=nv>%x</span> <span class=p>:</span> <span class=k>f64</span>
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait, Elementwise, SameOperandsAndResultType, Scalarizable, Tensorizable, Vectorizable</p><p>Interfaces: ArithFastMathInterface, ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), VectorUnrollOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-17>Attributes:&nbsp;<a class=headline-hash href=#attributes-17>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmath</code></td><td>::mlir::arith::FastMathFlagsAttr</td><td><details><summary>Floating point fast math flags</summary><p>Enum cases:</p><ul><li>none (<code>none</code>)</li><li>reassoc (<code>reassoc</code>)</li><li>nnan (<code>nnan</code>)</li><li>ninf (<code>ninf</code>)</li><li>nsz (<code>nsz</code>)</li><li>arcp (<code>arcp</code>)</li><li>contract (<code>contract</code>)</li><li>afn (<code>afn</code>)</li><li>fast (<code>fast</code>)</li></ul></details></td></tr></table><h4 id=operands-22>Operands:&nbsp;<a class=headline-hash href=#operands-22>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-22>Results:&nbsp;<a class=headline-hash href=#results-22>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>floating-point-like</td></tr></tbody></table><h3 id=mathlog2-mathlog2op><code>math.log2</code> (math::Log2Op)&nbsp;<a class=headline-hash href=#mathlog2-mathlog2op>¶</a></h3><p><em>Base-2 logarithm of the specified value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `math.log2` $operand (`fastmath` `` $fastmath^)?
              attr-dict `:` type($result)
</code></pre><p>Computes the base-2 logarithm of the given value. It takes one operand of
floating point type (i.e., scalar, tensor or vector) and returns one result of
the same type.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar log2 operation.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%y</span> <span class=p>=</span> math<span class=p>.</span>log2 <span class=nv>%x</span> <span class=p>:</span> <span class=k>f64</span>
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait, Elementwise, SameOperandsAndResultType, Scalarizable, Tensorizable, Vectorizable</p><p>Interfaces: ArithFastMathInterface, ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), VectorUnrollOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-18>Attributes:&nbsp;<a class=headline-hash href=#attributes-18>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmath</code></td><td>::mlir::arith::FastMathFlagsAttr</td><td><details><summary>Floating point fast math flags</summary><p>Enum cases:</p><ul><li>none (<code>none</code>)</li><li>reassoc (<code>reassoc</code>)</li><li>nnan (<code>nnan</code>)</li><li>ninf (<code>ninf</code>)</li><li>nsz (<code>nsz</code>)</li><li>arcp (<code>arcp</code>)</li><li>contract (<code>contract</code>)</li><li>afn (<code>afn</code>)</li><li>fast (<code>fast</code>)</li></ul></details></td></tr></table><h4 id=operands-23>Operands:&nbsp;<a class=headline-hash href=#operands-23>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-23>Results:&nbsp;<a class=headline-hash href=#results-23>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>floating-point-like</td></tr></tbody></table><h3 id=mathpowf-mathpowfop><code>math.powf</code> (math::PowFOp)&nbsp;<a class=headline-hash href=#mathpowf-mathpowfop>¶</a></h3><p><em>Floating point raised to the power of operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `math.powf` $lhs `,` $rhs (`fastmath` `` $fastmath^)?
              attr-dict `:` type($result)
</code></pre><p>Syntax:</p><pre tabindex=0><code>operation ::= ssa-id `=` `math.powf` ssa-use `,` ssa-use `:` type
</code></pre><p>The <code>powf</code> operation takes two operands of floating point type (i.e.,
scalar, tensor or vector) and returns one result of the same type. Operands
must have the same type.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar exponentiation.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> math<span class=p>.</span>powf <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>f64</span>
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait, Elementwise, SameOperandsAndResultType, Scalarizable, Tensorizable, Vectorizable</p><p>Interfaces: ArithFastMathInterface, ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), VectorUnrollOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-19>Attributes:&nbsp;<a class=headline-hash href=#attributes-19>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmath</code></td><td>::mlir::arith::FastMathFlagsAttr</td><td><details><summary>Floating point fast math flags</summary><p>Enum cases:</p><ul><li>none (<code>none</code>)</li><li>reassoc (<code>reassoc</code>)</li><li>nnan (<code>nnan</code>)</li><li>ninf (<code>ninf</code>)</li><li>nsz (<code>nsz</code>)</li><li>arcp (<code>arcp</code>)</li><li>contract (<code>contract</code>)</li><li>afn (<code>afn</code>)</li><li>fast (<code>fast</code>)</li></ul></details></td></tr></table><h4 id=operands-24>Operands:&nbsp;<a class=headline-hash href=#operands-24>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>floating-point-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-24>Results:&nbsp;<a class=headline-hash href=#results-24>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>floating-point-like</td></tr></tbody></table><h3 id=mathround-mathroundop><code>math.round</code> (math::RoundOp)&nbsp;<a class=headline-hash href=#mathround-mathroundop>¶</a></h3><p><em>Round of the specified value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `math.round` $operand (`fastmath` `` $fastmath^)?
              attr-dict `:` type($result)
</code></pre><p>Syntax:</p><pre tabindex=0><code>operation ::= ssa-id `=` `math.round` ssa-use `:` type
</code></pre><p>The <code>round</code> operation returns the operand rounded to the nearest integer
value in floating-point format. It takes one operand of floating point type
(i.e., scalar, tensor or vector) and produces one result of the same type. The
operation rounds the argument to the nearest integer value in floating-point
format, rounding halfway cases away from zero, regardless of the current
rounding direction.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar round operation.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> math<span class=p>.</span>round <span class=nv>%b</span> <span class=p>:</span> <span class=k>f64</span>
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait, Elementwise, SameOperandsAndResultType, Scalarizable, Tensorizable, Vectorizable</p><p>Interfaces: ArithFastMathInterface, ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), VectorUnrollOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-20>Attributes:&nbsp;<a class=headline-hash href=#attributes-20>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmath</code></td><td>::mlir::arith::FastMathFlagsAttr</td><td><details><summary>Floating point fast math flags</summary><p>Enum cases:</p><ul><li>none (<code>none</code>)</li><li>reassoc (<code>reassoc</code>)</li><li>nnan (<code>nnan</code>)</li><li>ninf (<code>ninf</code>)</li><li>nsz (<code>nsz</code>)</li><li>arcp (<code>arcp</code>)</li><li>contract (<code>contract</code>)</li><li>afn (<code>afn</code>)</li><li>fast (<code>fast</code>)</li></ul></details></td></tr></table><h4 id=operands-25>Operands:&nbsp;<a class=headline-hash href=#operands-25>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-25>Results:&nbsp;<a class=headline-hash href=#results-25>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>floating-point-like</td></tr></tbody></table><h3 id=mathroundeven-mathroundevenop><code>math.roundeven</code> (math::RoundEvenOp)&nbsp;<a class=headline-hash href=#mathroundeven-mathroundevenop>¶</a></h3><p><em>Round of the specified value with halfway cases to even</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `math.roundeven` $operand (`fastmath` `` $fastmath^)?
              attr-dict `:` type($result)
</code></pre><p>Syntax:</p><pre tabindex=0><code>operation ::= ssa-id `=` `math.roundeven` ssa-use `:` type
</code></pre><p>The <code>roundeven</code> operation returns the operand rounded to the nearest integer
value in floating-point format. It takes one operand of floating point type
(i.e., scalar, tensor or vector) and produces one result of the same type. The
operation rounds the argument to the nearest integer value in floating-point
format, rounding halfway cases to even, regardless of the current
rounding direction.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar round operation.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> math<span class=p>.</span>roundeven <span class=nv>%b</span> <span class=p>:</span> <span class=k>f64</span>
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait, Elementwise, SameOperandsAndResultType, Scalarizable, Tensorizable, Vectorizable</p><p>Interfaces: ArithFastMathInterface, ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), VectorUnrollOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-21>Attributes:&nbsp;<a class=headline-hash href=#attributes-21>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmath</code></td><td>::mlir::arith::FastMathFlagsAttr</td><td><details><summary>Floating point fast math flags</summary><p>Enum cases:</p><ul><li>none (<code>none</code>)</li><li>reassoc (<code>reassoc</code>)</li><li>nnan (<code>nnan</code>)</li><li>ninf (<code>ninf</code>)</li><li>nsz (<code>nsz</code>)</li><li>arcp (<code>arcp</code>)</li><li>contract (<code>contract</code>)</li><li>afn (<code>afn</code>)</li><li>fast (<code>fast</code>)</li></ul></details></td></tr></table><h4 id=operands-26>Operands:&nbsp;<a class=headline-hash href=#operands-26>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-26>Results:&nbsp;<a class=headline-hash href=#results-26>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>floating-point-like</td></tr></tbody></table><h3 id=mathrsqrt-mathrsqrtop><code>math.rsqrt</code> (math::RsqrtOp)&nbsp;<a class=headline-hash href=#mathrsqrt-mathrsqrtop>¶</a></h3><p><em>Reciprocal of sqrt (1 / sqrt of the specified value)</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `math.rsqrt` $operand (`fastmath` `` $fastmath^)?
              attr-dict `:` type($result)
</code></pre><p>The <code>rsqrt</code> operation computes the reciprocal of the square root. It takes
one operand of floating point type (i.e., scalar, tensor or vector) and returns
one result of the same type. It has no standard attributes.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar reciprocal square root value.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> math<span class=p>.</span>rsqrt <span class=nv>%b</span> <span class=p>:</span> <span class=k>f64</span>
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait, Elementwise, SameOperandsAndResultType, Scalarizable, Tensorizable, Vectorizable</p><p>Interfaces: ArithFastMathInterface, ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), VectorUnrollOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-22>Attributes:&nbsp;<a class=headline-hash href=#attributes-22>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmath</code></td><td>::mlir::arith::FastMathFlagsAttr</td><td><details><summary>Floating point fast math flags</summary><p>Enum cases:</p><ul><li>none (<code>none</code>)</li><li>reassoc (<code>reassoc</code>)</li><li>nnan (<code>nnan</code>)</li><li>ninf (<code>ninf</code>)</li><li>nsz (<code>nsz</code>)</li><li>arcp (<code>arcp</code>)</li><li>contract (<code>contract</code>)</li><li>afn (<code>afn</code>)</li><li>fast (<code>fast</code>)</li></ul></details></td></tr></table><h4 id=operands-27>Operands:&nbsp;<a class=headline-hash href=#operands-27>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-27>Results:&nbsp;<a class=headline-hash href=#results-27>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>floating-point-like</td></tr></tbody></table><h3 id=mathsin-mathsinop><code>math.sin</code> (math::SinOp)&nbsp;<a class=headline-hash href=#mathsin-mathsinop>¶</a></h3><p><em>Sine of the specified value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `math.sin` $operand (`fastmath` `` $fastmath^)?
              attr-dict `:` type($result)
</code></pre><p>Syntax:</p><pre tabindex=0><code>operation ::= ssa-id `=` `math.sin` ssa-use `:` type
</code></pre><p>The <code>sin</code> operation computes the sine of a given value. It takes one
operand of floating point type (i.e., scalar, tensor or vector) and returns one
result of the same type. It has no standard attributes.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar sine value.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> math<span class=p>.</span>sin <span class=nv>%b</span> <span class=p>:</span> <span class=k>f64</span>
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait, Elementwise, SameOperandsAndResultType, Scalarizable, Tensorizable, Vectorizable</p><p>Interfaces: ArithFastMathInterface, ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), VectorUnrollOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-23>Attributes:&nbsp;<a class=headline-hash href=#attributes-23>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmath</code></td><td>::mlir::arith::FastMathFlagsAttr</td><td><details><summary>Floating point fast math flags</summary><p>Enum cases:</p><ul><li>none (<code>none</code>)</li><li>reassoc (<code>reassoc</code>)</li><li>nnan (<code>nnan</code>)</li><li>ninf (<code>ninf</code>)</li><li>nsz (<code>nsz</code>)</li><li>arcp (<code>arcp</code>)</li><li>contract (<code>contract</code>)</li><li>afn (<code>afn</code>)</li><li>fast (<code>fast</code>)</li></ul></details></td></tr></table><h4 id=operands-28>Operands:&nbsp;<a class=headline-hash href=#operands-28>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-28>Results:&nbsp;<a class=headline-hash href=#results-28>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>floating-point-like</td></tr></tbody></table><h3 id=mathsqrt-mathsqrtop><code>math.sqrt</code> (math::SqrtOp)&nbsp;<a class=headline-hash href=#mathsqrt-mathsqrtop>¶</a></h3><p><em>Sqrt of the specified value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `math.sqrt` $operand (`fastmath` `` $fastmath^)?
              attr-dict `:` type($result)
</code></pre><p>The <code>sqrt</code> operation computes the square root. It takes one operand of
floating point type (i.e., scalar, tensor or vector) and returns one result of
the same type. It has no standard attributes.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar square root value.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> math<span class=p>.</span>sqrt <span class=nv>%b</span> <span class=p>:</span> <span class=k>f64</span>
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait, Elementwise, SameOperandsAndResultType, Scalarizable, Tensorizable, Vectorizable</p><p>Interfaces: ArithFastMathInterface, ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), VectorUnrollOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-24>Attributes:&nbsp;<a class=headline-hash href=#attributes-24>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmath</code></td><td>::mlir::arith::FastMathFlagsAttr</td><td><details><summary>Floating point fast math flags</summary><p>Enum cases:</p><ul><li>none (<code>none</code>)</li><li>reassoc (<code>reassoc</code>)</li><li>nnan (<code>nnan</code>)</li><li>ninf (<code>ninf</code>)</li><li>nsz (<code>nsz</code>)</li><li>arcp (<code>arcp</code>)</li><li>contract (<code>contract</code>)</li><li>afn (<code>afn</code>)</li><li>fast (<code>fast</code>)</li></ul></details></td></tr></table><h4 id=operands-29>Operands:&nbsp;<a class=headline-hash href=#operands-29>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-29>Results:&nbsp;<a class=headline-hash href=#results-29>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>floating-point-like</td></tr></tbody></table><h3 id=mathtan-mathtanop><code>math.tan</code> (math::TanOp)&nbsp;<a class=headline-hash href=#mathtan-mathtanop>¶</a></h3><p><em>Tangent of the specified value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `math.tan` $operand (`fastmath` `` $fastmath^)?
              attr-dict `:` type($result)
</code></pre><p>The <code>tan</code> operation computes the tangent. It takes one operand
of floating point type (i.e., scalar, tensor or vector) and returns one
result of the same type. It has no standard attributes.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar tangent value.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> math<span class=p>.</span>tan <span class=nv>%b</span> <span class=p>:</span> <span class=k>f64</span>
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait, Elementwise, SameOperandsAndResultType, Scalarizable, Tensorizable, Vectorizable</p><p>Interfaces: ArithFastMathInterface, ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), VectorUnrollOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-25>Attributes:&nbsp;<a class=headline-hash href=#attributes-25>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmath</code></td><td>::mlir::arith::FastMathFlagsAttr</td><td><details><summary>Floating point fast math flags</summary><p>Enum cases:</p><ul><li>none (<code>none</code>)</li><li>reassoc (<code>reassoc</code>)</li><li>nnan (<code>nnan</code>)</li><li>ninf (<code>ninf</code>)</li><li>nsz (<code>nsz</code>)</li><li>arcp (<code>arcp</code>)</li><li>contract (<code>contract</code>)</li><li>afn (<code>afn</code>)</li><li>fast (<code>fast</code>)</li></ul></details></td></tr></table><h4 id=operands-30>Operands:&nbsp;<a class=headline-hash href=#operands-30>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-30>Results:&nbsp;<a class=headline-hash href=#results-30>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>floating-point-like</td></tr></tbody></table><h3 id=mathtanh-mathtanhop><code>math.tanh</code> (math::TanhOp)&nbsp;<a class=headline-hash href=#mathtanh-mathtanhop>¶</a></h3><p><em>Hyperbolic tangent of the specified value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `math.tanh` $operand (`fastmath` `` $fastmath^)?
              attr-dict `:` type($result)
</code></pre><p>The <code>tanh</code> operation computes the hyperbolic tangent. It takes one operand
of floating point type (i.e., scalar, tensor or vector) and returns one
result of the same type. It has no standard attributes.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar hyperbolic tangent value.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> math<span class=p>.</span>tanh <span class=nv>%b</span> <span class=p>:</span> <span class=k>f64</span>
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait, Elementwise, SameOperandsAndResultType, Scalarizable, Tensorizable, Vectorizable</p><p>Interfaces: ArithFastMathInterface, ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), VectorUnrollOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-26>Attributes:&nbsp;<a class=headline-hash href=#attributes-26>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmath</code></td><td>::mlir::arith::FastMathFlagsAttr</td><td><details><summary>Floating point fast math flags</summary><p>Enum cases:</p><ul><li>none (<code>none</code>)</li><li>reassoc (<code>reassoc</code>)</li><li>nnan (<code>nnan</code>)</li><li>ninf (<code>ninf</code>)</li><li>nsz (<code>nsz</code>)</li><li>arcp (<code>arcp</code>)</li><li>contract (<code>contract</code>)</li><li>afn (<code>afn</code>)</li><li>fast (<code>fast</code>)</li></ul></details></td></tr></table><h4 id=operands-31>Operands:&nbsp;<a class=headline-hash href=#operands-31>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-31>Results:&nbsp;<a class=headline-hash href=#results-31>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>floating-point-like</td></tr></tbody></table><h3 id=mathtrunc-mathtruncop><code>math.trunc</code> (math::TruncOp)&nbsp;<a class=headline-hash href=#mathtrunc-mathtruncop>¶</a></h3><p><em>Trunc of the specified value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `math.trunc` $operand (`fastmath` `` $fastmath^)?
              attr-dict `:` type($result)
</code></pre><p>Syntax:</p><pre tabindex=0><code>operation ::= ssa-id `=` `math.trunc` ssa-use `:` type
</code></pre><p>The <code>trunc</code> operation returns the operand rounded to the nearest integer
value in floating-point format. It takes one operand of floating point type
(i.e., scalar, tensor or vector) and produces one result of the same type.
The operation always rounds to the nearest integer not larger in magnitude
than the operand, regardless of the current rounding direction.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar trunc operation.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> math<span class=p>.</span>trunc <span class=nv>%b</span> <span class=p>:</span> <span class=k>f64</span>
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait, Elementwise, SameOperandsAndResultType, Scalarizable, Tensorizable, Vectorizable</p><p>Interfaces: ArithFastMathInterface, ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), VectorUnrollOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-27>Attributes:&nbsp;<a class=headline-hash href=#attributes-27>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmath</code></td><td>::mlir::arith::FastMathFlagsAttr</td><td><details><summary>Floating point fast math flags</summary><p>Enum cases:</p><ul><li>none (<code>none</code>)</li><li>reassoc (<code>reassoc</code>)</li><li>nnan (<code>nnan</code>)</li><li>ninf (<code>ninf</code>)</li><li>nsz (<code>nsz</code>)</li><li>arcp (<code>arcp</code>)</li><li>contract (<code>contract</code>)</li><li>afn (<code>afn</code>)</li><li>fast (<code>fast</code>)</li></ul></details></td></tr></table><h4 id=operands-32>Operands:&nbsp;<a class=headline-hash href=#operands-32>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-32>Results:&nbsp;<a class=headline-hash href=#results-32>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>floating-point-like</td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://mlir.llvm.org/docs/Dialects/LLVM/ title="'llvm' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - 'llvm' Dialect</a>
<a class="nav nav-next" href=https://mlir.llvm.org/docs/Dialects/MemRef/ title="'memref' Dialect">Next - 'memref' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=https://mlir.llvm.org/users/>Users of MLIR</a></li><li><a href=https://mlir.llvm.org/pubs/>MLIR Related Publications</a></li><li><a href=https://mlir.llvm.org/talks/>Talks</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/deprecation/>Deprecations & Current Refactoring<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/deprecation/TestingGuide/>Testing Guide haha</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/getting_started/ReportingIssues/>Reporting Issues</a></li><li><a href=https://mlir.llvm.org/getting_started/Debugging/>Debugging Tips</a></li><li><a href=https://mlir.llvm.org/getting_started/Faq/>FAQ</a></li><li><a href=https://mlir.llvm.org/getting_started/Contributing/>How to Contribute</a></li><li><a href=https://mlir.llvm.org/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=https://mlir.llvm.org/getting_started/openprojects/>Open Projects</a></li><li><a href=https://mlir.llvm.org/getting_started/Glossary/>Glossary</a></li><li><a href=https://mlir.llvm.org/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-reduce/>MLIR Reduce</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/ActionTracing/>Action: Tracing and Debugging MLIR-based Compilers</a></li><li><a href=https://mlir.llvm.org/docs/BufferDeallocationInternals/>Buffer Deallocation - Internals</a></li><li><a href=https://mlir.llvm.org/docs/Bufferization/>Bufferization</a></li><li><a href=https://mlir.llvm.org/docs/DataLayout/>Data Layout Modeling</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/DefiningDialects/>Defining Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/DefiningDialects/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Operations/>Operation Definition Specification (ODS)</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/DialectConversion/>Dialect Conversion</a></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMDGPU/>'amdgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArithOps/>'arith' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSME/>'ArmSME' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IndexOps/>'index' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IRDL/>'irdl' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li class=active><a href=https://mlir.llvm.org/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Mesh/>'mesh' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/>'omp' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/UBOps/>'ub' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MatchOpInterfaces/>OpInterface definitions</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Interfaces/>Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=https://mlir.llvm.org/docs/BytecodeFormat/>MLIR Bytecode Format</a></li><li><a href=https://mlir.llvm.org/docs/CAPI/>MLIR C API</a></li><li><a href=https://mlir.llvm.org/docs/LangRef/>MLIR Language Reference</a></li><li><a href=https://mlir.llvm.org/docs/ReleaseNotes/>MLIR Release Notes</a></li><li><a href=https://mlir.llvm.org/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=https://mlir.llvm.org/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/Passes/>Passes</a></li><li><a href=https://mlir.llvm.org/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=https://mlir.llvm.org/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=https://mlir.llvm.org/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/SideEffectsAndSpeculation/>Side Effects & Speculation</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/ShapeInference/>Shape Inference</a></li><li><a href=https://mlir.llvm.org/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=https://mlir.llvm.org/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=https://mlir.llvm.org/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Traits/>Traits<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Traits/Broadcastable/>The `Broadcastable` Trait</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/transform/>Transform Dialect Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch0/>Chapter 0: A Primer on “Structured” Linalg Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch1/>Chapter 1: Combining Existing Transformations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch2/>Chapter 2: Adding a Simple New Transformation Operation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch3/>Chapter 3: More than Simple Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/ChH/>Chapter H: Reproducing Halide Schedule</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>