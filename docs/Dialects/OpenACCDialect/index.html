<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'acc' Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.119.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/OpenACCDialect/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://mlir.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li></ul></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&amp;list_id=177877&amp;order=changeddate%20DESC%2Cpriority%2Cbug_severity&amp;product=MLIR&amp;query_format=specific">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>'acc' Dialect</h1><p>An OpenACC dialect for MLIR.
This dialect models the construct from the OpenACC 3.3 directive language.</p><p><nav id=TableOfContents><ul><li><a href=#operations>Operations</a><ul><li><a href=#accatomiccapture-accatomiccaptureop><code>acc.atomic.capture</code> (acc::AtomicCaptureOp)</a></li><li><a href=#accatomicread-accatomicreadop><code>acc.atomic.read</code> (acc::AtomicReadOp)</a></li><li><a href=#accatomicupdate-accatomicupdateop><code>acc.atomic.update</code> (acc::AtomicUpdateOp)</a></li><li><a href=#accatomicwrite-accatomicwriteop><code>acc.atomic.write</code> (acc::AtomicWriteOp)</a></li><li><a href=#accattach-accattachop><code>acc.attach</code> (acc::AttachOp)</a></li><li><a href=#accbounds-accdataboundsop><code>acc.bounds</code> (acc::DataBoundsOp)</a></li><li><a href=#acccache-acccacheop><code>acc.cache</code> (acc::CacheOp)</a></li><li><a href=#acccopyin-acccopyinop><code>acc.copyin</code> (acc::CopyinOp)</a></li><li><a href=#acccopyout-acccopyoutop><code>acc.copyout</code> (acc::CopyoutOp)</a></li><li><a href=#acccreate-acccreateop><code>acc.create</code> (acc::CreateOp)</a></li><li><a href=#accdata-accdataop><code>acc.data</code> (acc::DataOp)</a></li><li><a href=#accdeclare-accdeclareop><code>acc.declare</code> (acc::DeclareOp)</a></li><li><a href=#accdeclare_device_resident-accdeclaredeviceresidentop><code>acc.declare_device_resident</code> (acc::DeclareDeviceResidentOp)</a></li><li><a href=#accdeclare_enter-accdeclareenterop><code>acc.declare_enter</code> (acc::DeclareEnterOp)</a></li><li><a href=#accdeclare_exit-accdeclareexitop><code>acc.declare_exit</code> (acc::DeclareExitOp)</a></li><li><a href=#accdeclare_link-accdeclarelinkop><code>acc.declare_link</code> (acc::DeclareLinkOp)</a></li><li><a href=#accdelete-accdeleteop><code>acc.delete</code> (acc::DeleteOp)</a></li><li><a href=#accdetach-accdetachop><code>acc.detach</code> (acc::DetachOp)</a></li><li><a href=#accdeviceptr-accdeviceptrop><code>acc.deviceptr</code> (acc::DevicePtrOp)</a></li><li><a href=#accenter_data-accenterdataop><code>acc.enter_data</code> (acc::EnterDataOp)</a></li><li><a href=#accexit_data-accexitdataop><code>acc.exit_data</code> (acc::ExitDataOp)</a></li><li><a href=#accfirstprivate-accfirstprivateop><code>acc.firstprivate</code> (acc::FirstprivateOp)</a></li><li><a href=#accfirstprivaterecipe-accfirstprivaterecipeop><code>acc.firstprivate.recipe</code> (acc::FirstprivateRecipeOp)</a></li><li><a href=#accgetdeviceptr-accgetdeviceptrop><code>acc.getdeviceptr</code> (acc::GetDevicePtrOp)</a></li><li><a href=#accglobal_ctor-accglobalconstructorop><code>acc.global_ctor</code> (acc::GlobalConstructorOp)</a></li><li><a href=#accglobal_dtor-accglobaldestructorop><code>acc.global_dtor</code> (acc::GlobalDestructorOp)</a></li><li><a href=#acchost_data-acchostdataop><code>acc.host_data</code> (acc::HostDataOp)</a></li><li><a href=#accinit-accinitop><code>acc.init</code> (acc::InitOp)</a></li><li><a href=#acckernels-acckernelsop><code>acc.kernels</code> (acc::KernelsOp)</a></li><li><a href=#accloop-accloopop><code>acc.loop</code> (acc::LoopOp)</a></li><li><a href=#accnocreate-accnocreateop><code>acc.nocreate</code> (acc::NoCreateOp)</a></li><li><a href=#accparallel-accparallelop><code>acc.parallel</code> (acc::ParallelOp)</a></li><li><a href=#accpresent-accpresentop><code>acc.present</code> (acc::PresentOp)</a></li><li><a href=#accprivate-accprivateop><code>acc.private</code> (acc::PrivateOp)</a></li><li><a href=#accprivaterecipe-accprivaterecipeop><code>acc.private.recipe</code> (acc::PrivateRecipeOp)</a></li><li><a href=#accreduction-accreductionop><code>acc.reduction</code> (acc::ReductionOp)</a></li><li><a href=#accreductionrecipe-accreductionrecipeop><code>acc.reduction.recipe</code> (acc::ReductionRecipeOp)</a></li><li><a href=#accroutine-accroutineop><code>acc.routine</code> (acc::RoutineOp)</a></li><li><a href=#accserial-accserialop><code>acc.serial</code> (acc::SerialOp)</a></li><li><a href=#accset-accsetop><code>acc.set</code> (acc::SetOp)</a></li><li><a href=#accshutdown-accshutdownop><code>acc.shutdown</code> (acc::ShutdownOp)</a></li><li><a href=#accterminator-accterminatorop><code>acc.terminator</code> (acc::TerminatorOp)</a></li><li><a href=#accupdate-accupdateop><code>acc.update</code> (acc::UpdateOp)</a></li><li><a href=#accupdate_device-accupdatedeviceop><code>acc.update_device</code> (acc::UpdateDeviceOp)</a></li><li><a href=#accupdate_host-accupdatehostop><code>acc.update_host</code> (acc::UpdateHostOp)</a></li><li><a href=#accuse_device-accusedeviceop><code>acc.use_device</code> (acc::UseDeviceOp)</a></li><li><a href=#accwait-accwaitop><code>acc.wait</code> (acc::WaitOp)</a></li><li><a href=#accyield-accyieldop><code>acc.yield</code> (acc::YieldOp)</a></li></ul></li><li><a href=#attributes-40>Attributes</a><ul><li><a href=#declareactionattr>DeclareActionAttr</a></li><li><a href=#declareattr>DeclareAttr</a></li><li><a href=#clausedefaultvalueattr>ClauseDefaultValueAttr</a></li><li><a href=#dataclauseattr>DataClauseAttr</a></li><li><a href=#devicetypeattr>DeviceTypeAttr</a></li><li><a href=#reductionoperatorattr>ReductionOperatorAttr</a></li><li><a href=#routineinfoattr>RoutineInfoAttr</a></li></ul></li><li><a href=#types>Types</a><ul><li><a href=#databoundstype>DataBoundsType</a></li><li><a href=#declaretokentype>DeclareTokenType</a></li></ul></li></ul></nav><h2 id=operations>Operations&nbsp;<a class=headline-hash href=#operations>¶</a></h2><p><a href=https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/OpenACC/OpenACCOps.td>source</a></p><h3 id=accatomiccapture-accatomiccaptureop><code>acc.atomic.capture</code> (acc::AtomicCaptureOp)&nbsp;<a class=headline-hash href=#accatomiccapture-accatomiccaptureop>¶</a></h3><p><em>Performs an atomic capture</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `acc.atomic.capture` $region attr-dict
</code></pre><p>This operation performs an atomic capture.</p><p>The region has the following allowed forms:</p><pre tabindex=0><code>  acc.atomic.capture {
    acc.atomic.update ...
    acc.atomic.read ...
    acc.terminator
  }

  acc.atomic.capture {
    acc.atomic.read ...
    acc.atomic.update ...
    acc.terminator
  }

  acc.atomic.capture {
    acc.atomic.read ...
    acc.atomic.write ...
    acc.terminator
  }
</code></pre><p>Traits: RecursiveMemoryEffects, SingleBlock, SingleBlockImplicitTerminator<terminatorop></p><p>Interfaces: AtomicCaptureOpInterface</p><h3 id=accatomicread-accatomicreadop><code>acc.atomic.read</code> (acc::AtomicReadOp)&nbsp;<a class=headline-hash href=#accatomicread-accatomicreadop>¶</a></h3><p><em>Performs an atomic read</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `acc.atomic.read` $v `=` $x
              `:` type($x) `,` $element_type attr-dict
</code></pre><p>This operation performs an atomic read.</p><p>The operand <code>x</code> is the address from where the value is atomically read.
The operand <code>v</code> is the address where the value is stored after reading.</p><p>Interfaces: AtomicReadOpInterface</p><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>element_type</code></td><td>::mlir::TypeAttr</td><td>any type attribute</td></tr></table><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>x</code></td><td>pointer-like type</td></tr><tr><td style=text-align:center><code>v</code></td><td>pointer-like type</td></tr></tbody></table><h3 id=accatomicupdate-accatomicupdateop><code>acc.atomic.update</code> (acc::AtomicUpdateOp)&nbsp;<a class=headline-hash href=#accatomicupdate-accatomicupdateop>¶</a></h3><p><em>Performs an atomic update</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `acc.atomic.update` $x `:` type($x) $region attr-dict
</code></pre><p>This operation performs an atomic update.</p><p>The operand <code>x</code> is exactly the same as the operand <code>x</code> in the OpenACC
Standard (OpenACC 3.3, section 2.12). It is the address of the variable
that is being updated. <code>x</code> is atomically read/written.</p><p>The region describes how to update the value of <code>x</code>. It takes the value at
<code>x</code> as an input and must yield the updated value. Only the update to <code>x</code> is
atomic. Generally the region must have only one instruction, but can
potentially have more than one instructions too. The update is sematically
similar to a compare-exchange loop based atomic update.</p><p>The syntax of atomic update operation is different from atomic read and
atomic write operations. This is because only the host dialect knows how to
appropriately update a value. For example, while generating LLVM IR, if
there are no special <code>atomicrmw</code> instructions for the operation-type
combination in atomic update, a compare-exchange loop is generated, where
the core update operation is directly translated like regular operations by
the host dialect. The front-end must handle semantic checks for allowed
operations.</p><p>Traits: RecursiveMemoryEffects, SingleBlock, SingleBlockImplicitTerminator<yieldop></p><p>Interfaces: AtomicUpdateOpInterface</p><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>x</code></td><td>pointer-like type</td></tr></tbody></table><h3 id=accatomicwrite-accatomicwriteop><code>acc.atomic.write</code> (acc::AtomicWriteOp)&nbsp;<a class=headline-hash href=#accatomicwrite-accatomicwriteop>¶</a></h3><p><em>Performs an atomic write</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `acc.atomic.write` $x `=` $expr
              `:` type($x) `,` type($expr)
              attr-dict
</code></pre><p>This operation performs an atomic write.</p><p>The operand <code>x</code> is the address to where the <code>expr</code> is atomically
written w.r.t. multiple threads. The evaluation of <code>expr</code> need not be
atomic w.r.t. the write to address. In general, the type(x) must
dereference to type(expr).</p><p>Interfaces: AtomicWriteOpInterface</p><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>x</code></td><td>pointer-like type</td></tr><tr><td style=text-align:center><code>expr</code></td><td>any type</td></tr></tbody></table><h3 id=accattach-accattachop><code>acc.attach</code> (acc::AttachOp)&nbsp;<a class=headline-hash href=#accattach-accattachop>¶</a></h3><p><em>Represents acc attach semantics which updates a pointer in device memory with the corresponding device address of the pointee.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `acc.attach` `varPtr` `(` $varPtr `:` type($varPtr) `)`
              oilist(
              `varPtrPtr` `(` $varPtrPtr `:` type($varPtrPtr) `)`
              | `bounds` `(` $bounds `)`
              ) `-&gt;` type($accPtr) attr-dict
</code></pre><p>Description of arguments:</p><ul><li><code>varPtr</code>: The address of variable to copy.</li><li><code>varPtrPtr</code>: Specifies the address of varPtr - only used when the variable
copied is a field in a struct. This is important for OpenACC due to implicit
attach semantics on data clauses (2.6.4).</li><li><code>bounds</code>: Used when copying just slice of array or array&rsquo;s bounds are not
encoded in type. They are in rank order where rank 0 is inner-most dimension.</li><li><code>dataClause</code>: Keeps track of the data clause the user used. This is because
the acc operations are decomposed. So a &lsquo;copy&rsquo; clause is decomposed to both
<code>acc.copyin</code> and <code>acc.copyout</code> operations, but both have dataClause that
specifies <code>acc_copy</code> in this field.</li><li><code>structured</code>: Flag to note whether this is associated with structured region
(parallel, kernels, data) or unstructured (enter data, exit data). This is
important due to spec specifically calling out structured and dynamic reference
counters (2.6.7).</li><li><code>implicit</code>: Whether this is an implicitly generated operation, such as copies
done to satisfy &ldquo;Variables with Implicitly Determined Data Attributes&rdquo; in 2.6.2.</li><li><code>name</code>: Holds the name of variable as specified in user clause (including bounds).</li></ul><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dataClause</code></td><td>::mlir::acc::DataClauseAttr</td><td><details><summary>data clauses supported by OpenACC</summary><p>Enum cases:</p><ul><li>acc_copyin (<code>acc_copyin</code>)</li><li>acc_copyin_readonly (<code>acc_copyin_readonly</code>)</li><li>acc_copy (<code>acc_copy</code>)</li><li>acc_copyout (<code>acc_copyout</code>)</li><li>acc_copyout_zero (<code>acc_copyout_zero</code>)</li><li>acc_present (<code>acc_present</code>)</li><li>acc_create (<code>acc_create</code>)</li><li>acc_create_zero (<code>acc_create_zero</code>)</li><li>acc_delete (<code>acc_delete</code>)</li><li>acc_attach (<code>acc_attach</code>)</li><li>acc_detach (<code>acc_detach</code>)</li><li>acc_no_create (<code>acc_no_create</code>)</li><li>acc_private (<code>acc_private</code>)</li><li>acc_firstprivate (<code>acc_firstprivate</code>)</li><li>acc_deviceptr (<code>acc_deviceptr</code>)</li><li>acc_getdeviceptr (<code>acc_getdeviceptr</code>)</li><li>acc_update_host (<code>acc_update_host</code>)</li><li>acc_update_self (<code>acc_update_self</code>)</li><li>acc_update_device (<code>acc_update_device</code>)</li><li>acc_use_device (<code>acc_use_device</code>)</li><li>acc_reduction (<code>acc_reduction</code>)</li><li>acc_declare_device_resident (<code>acc_declare_device_resident</code>)</li><li>acc_declare_link (<code>acc_declare_link</code>)</li><li>acc_cache (<code>acc_cache</code>)</li><li>acc_cache_readonly (<code>acc_cache_readonly</code>)</li></ul></details></td></tr><tr><td><code>structured</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>implicit</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>varPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>varPtrPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>bounds</code></td><td>variadic of Type for representing acc data clause bounds information</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>accPtr</code></td><td>PointerLikeType instance</td></tr></tbody></table><h3 id=accbounds-accdataboundsop><code>acc.bounds</code> (acc::DataBoundsOp)&nbsp;<a class=headline-hash href=#accbounds-accdataboundsop>¶</a></h3><p><em>Represents normalized bounds information for acc data clause.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `acc.bounds` oilist(
              `lowerbound` `(` $lowerbound `:` type($lowerbound) `)`
              | `upperbound` `(` $upperbound `:` type($upperbound) `)`
              | `extent` `(` $extent `:` type($extent) `)`
              | `stride` `(` $stride `:` type($stride) `)`
              | `startIdx` `(` $startIdx `:` type($startIdx) `)`
              ) attr-dict
</code></pre><p>This operation is used to record bounds used in acc data clause in a
normalized fashion (zero-based). This works well with the <code>PointerLikeType</code>
requirement in data clauses - since a <code>lowerbound</code> of 0 means looking
at data at the zero offset from pointer.</p><p>The operation must have an <code>upperbound</code> or <code>extent</code> (or both are allowed -
but not checked for consistency). When the source language&rsquo;s arrays are
not zero-based, the <code>startIdx</code> must specify the zero-position index.</p><p>Examples below show copying a slice of 10-element array except first element.
Note that the examples use extent in data clause for C++ and upperbound
for Fortran (as per 2.7.1). To simplify examples, the constants are used
directly in the acc.bounds operands - this is not the syntax of operation.</p><p>C++:</p><pre tabindex=0><code>int array[10];
#pragma acc copy(array[1:9])
</code></pre><p>=></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>acc<span class=p>.</span>bounds lb<span class=p>(</span><span class=m>1</span><span class=p>)</span> ub<span class=p>(</span><span class=m>9</span><span class=p>)</span> extent<span class=p>(</span><span class=m>9</span><span class=p>)</span> startIdx<span class=p>(</span><span class=m>0</span><span class=p>)</span>
</span></span></code></pre></div><p>Fortran:</p><pre tabindex=0><code>integer :: array(1:10)
!$acc copy(array(2:10))
</code></pre><p>=></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>acc<span class=p>.</span>bounds lb<span class=p>(</span><span class=m>1</span><span class=p>)</span> ub<span class=p>(</span><span class=m>9</span><span class=p>)</span> extent<span class=p>(</span><span class=m>9</span><span class=p>)</span> startIdx<span class=p>(</span><span class=m>1</span><span class=p>)</span>
</span></span></code></pre></div><p>Traits: AttrSizedOperandSegments</p><p>Interfaces: NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>strideInBytes</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr></table><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lowerbound</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>upperbound</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>extent</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>stride</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>startIdx</code></td><td>integer or index</td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>Type for representing acc data clause bounds information</td></tr></tbody></table><h3 id=acccache-acccacheop><code>acc.cache</code> (acc::CacheOp)&nbsp;<a class=headline-hash href=#acccache-acccacheop>¶</a></h3><p><em>Represents the cache directive that is associated with a loop.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `acc.cache` `varPtr` `(` $varPtr `:` type($varPtr) `)`
              oilist(
              `varPtrPtr` `(` $varPtrPtr `:` type($varPtrPtr) `)`
              | `bounds` `(` $bounds `)`
              ) `-&gt;` type($accPtr) attr-dict
</code></pre><p>Description of arguments:</p><ul><li><code>varPtr</code>: The address of variable to copy.</li><li><code>varPtrPtr</code>: Specifies the address of varPtr - only used when the variable
copied is a field in a struct. This is important for OpenACC due to implicit
attach semantics on data clauses (2.6.4).</li><li><code>bounds</code>: Used when copying just slice of array or array&rsquo;s bounds are not
encoded in type. They are in rank order where rank 0 is inner-most dimension.</li><li><code>dataClause</code>: Keeps track of the data clause the user used. This is because
the acc operations are decomposed. So a &lsquo;copy&rsquo; clause is decomposed to both
<code>acc.copyin</code> and <code>acc.copyout</code> operations, but both have dataClause that
specifies <code>acc_copy</code> in this field.</li><li><code>structured</code>: Flag to note whether this is associated with structured region
(parallel, kernels, data) or unstructured (enter data, exit data). This is
important due to spec specifically calling out structured and dynamic reference
counters (2.6.7).</li><li><code>implicit</code>: Whether this is an implicitly generated operation, such as copies
done to satisfy &ldquo;Variables with Implicitly Determined Data Attributes&rdquo; in 2.6.2.</li><li><code>name</code>: Holds the name of variable as specified in user clause (including bounds).</li></ul><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-3>Attributes:&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dataClause</code></td><td>::mlir::acc::DataClauseAttr</td><td><details><summary>data clauses supported by OpenACC</summary><p>Enum cases:</p><ul><li>acc_copyin (<code>acc_copyin</code>)</li><li>acc_copyin_readonly (<code>acc_copyin_readonly</code>)</li><li>acc_copy (<code>acc_copy</code>)</li><li>acc_copyout (<code>acc_copyout</code>)</li><li>acc_copyout_zero (<code>acc_copyout_zero</code>)</li><li>acc_present (<code>acc_present</code>)</li><li>acc_create (<code>acc_create</code>)</li><li>acc_create_zero (<code>acc_create_zero</code>)</li><li>acc_delete (<code>acc_delete</code>)</li><li>acc_attach (<code>acc_attach</code>)</li><li>acc_detach (<code>acc_detach</code>)</li><li>acc_no_create (<code>acc_no_create</code>)</li><li>acc_private (<code>acc_private</code>)</li><li>acc_firstprivate (<code>acc_firstprivate</code>)</li><li>acc_deviceptr (<code>acc_deviceptr</code>)</li><li>acc_getdeviceptr (<code>acc_getdeviceptr</code>)</li><li>acc_update_host (<code>acc_update_host</code>)</li><li>acc_update_self (<code>acc_update_self</code>)</li><li>acc_update_device (<code>acc_update_device</code>)</li><li>acc_use_device (<code>acc_use_device</code>)</li><li>acc_reduction (<code>acc_reduction</code>)</li><li>acc_declare_device_resident (<code>acc_declare_device_resident</code>)</li><li>acc_declare_link (<code>acc_declare_link</code>)</li><li>acc_cache (<code>acc_cache</code>)</li><li>acc_cache_readonly (<code>acc_cache_readonly</code>)</li></ul></details></td></tr><tr><td><code>structured</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>implicit</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>varPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>varPtrPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>bounds</code></td><td>variadic of Type for representing acc data clause bounds information</td></tr></tbody></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>accPtr</code></td><td>PointerLikeType instance</td></tr></tbody></table><h3 id=acccopyin-acccopyinop><code>acc.copyin</code> (acc::CopyinOp)&nbsp;<a class=headline-hash href=#acccopyin-acccopyinop>¶</a></h3><p><em>Represents copyin semantics for acc data clauses like acc copyin and acc copy.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `acc.copyin` `varPtr` `(` $varPtr `:` type($varPtr) `)`
              oilist(
              `varPtrPtr` `(` $varPtrPtr `:` type($varPtrPtr) `)`
              | `bounds` `(` $bounds `)`
              ) `-&gt;` type($accPtr) attr-dict
</code></pre><p>Description of arguments:</p><ul><li><code>varPtr</code>: The address of variable to copy.</li><li><code>varPtrPtr</code>: Specifies the address of varPtr - only used when the variable
copied is a field in a struct. This is important for OpenACC due to implicit
attach semantics on data clauses (2.6.4).</li><li><code>bounds</code>: Used when copying just slice of array or array&rsquo;s bounds are not
encoded in type. They are in rank order where rank 0 is inner-most dimension.</li><li><code>dataClause</code>: Keeps track of the data clause the user used. This is because
the acc operations are decomposed. So a &lsquo;copy&rsquo; clause is decomposed to both
<code>acc.copyin</code> and <code>acc.copyout</code> operations, but both have dataClause that
specifies <code>acc_copy</code> in this field.</li><li><code>structured</code>: Flag to note whether this is associated with structured region
(parallel, kernels, data) or unstructured (enter data, exit data). This is
important due to spec specifically calling out structured and dynamic reference
counters (2.6.7).</li><li><code>implicit</code>: Whether this is an implicitly generated operation, such as copies
done to satisfy &ldquo;Variables with Implicitly Determined Data Attributes&rdquo; in 2.6.2.</li><li><code>name</code>: Holds the name of variable as specified in user clause (including bounds).</li></ul><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-4>Attributes:&nbsp;<a class=headline-hash href=#attributes-4>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dataClause</code></td><td>::mlir::acc::DataClauseAttr</td><td><details><summary>data clauses supported by OpenACC</summary><p>Enum cases:</p><ul><li>acc_copyin (<code>acc_copyin</code>)</li><li>acc_copyin_readonly (<code>acc_copyin_readonly</code>)</li><li>acc_copy (<code>acc_copy</code>)</li><li>acc_copyout (<code>acc_copyout</code>)</li><li>acc_copyout_zero (<code>acc_copyout_zero</code>)</li><li>acc_present (<code>acc_present</code>)</li><li>acc_create (<code>acc_create</code>)</li><li>acc_create_zero (<code>acc_create_zero</code>)</li><li>acc_delete (<code>acc_delete</code>)</li><li>acc_attach (<code>acc_attach</code>)</li><li>acc_detach (<code>acc_detach</code>)</li><li>acc_no_create (<code>acc_no_create</code>)</li><li>acc_private (<code>acc_private</code>)</li><li>acc_firstprivate (<code>acc_firstprivate</code>)</li><li>acc_deviceptr (<code>acc_deviceptr</code>)</li><li>acc_getdeviceptr (<code>acc_getdeviceptr</code>)</li><li>acc_update_host (<code>acc_update_host</code>)</li><li>acc_update_self (<code>acc_update_self</code>)</li><li>acc_update_device (<code>acc_update_device</code>)</li><li>acc_use_device (<code>acc_use_device</code>)</li><li>acc_reduction (<code>acc_reduction</code>)</li><li>acc_declare_device_resident (<code>acc_declare_device_resident</code>)</li><li>acc_declare_link (<code>acc_declare_link</code>)</li><li>acc_cache (<code>acc_cache</code>)</li><li>acc_cache_readonly (<code>acc_cache_readonly</code>)</li></ul></details></td></tr><tr><td><code>structured</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>implicit</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>varPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>varPtrPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>bounds</code></td><td>variadic of Type for representing acc data clause bounds information</td></tr></tbody></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>accPtr</code></td><td>PointerLikeType instance</td></tr></tbody></table><h3 id=acccopyout-acccopyoutop><code>acc.copyout</code> (acc::CopyoutOp)&nbsp;<a class=headline-hash href=#acccopyout-acccopyoutop>¶</a></h3><p><em>Represents acc copyout semantics - reverse of copyin.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `acc.copyout` `accPtr` `(` $accPtr `:` type($accPtr) `)`
              oilist(
              `bounds` `(` $bounds `)`
              | `to` `varPtr` `(` $varPtr `:` type($varPtr) `)`
              ) attr-dict
</code></pre><ul><li><code>varPtr</code>: The address of variable to copy back to. This only applies to
<code>acc.copyout</code></li><li><code>accPtr</code>: The acc address of variable. This is the link from the data-entry
operation used.</li><li><code>bounds</code>: Used when copying just slice of array or array&rsquo;s bounds are not
encoded in type. They are in rank order where rank 0 is inner-most dimension.</li><li><code>dataClause</code>: Keeps track of the data clause the user used. This is because
the acc operations are decomposed. So a &lsquo;copy&rsquo; clause is decomposed to both
<code>acc.copyin</code> and <code>acc.copyout</code> operations, but both have dataClause that
specifies <code>acc_copy</code> in this field.</li><li><code>structured</code>: Flag to note whether this is associated with structured region
(parallel, kernels, data) or unstructured (enter data, exit data). This is
important due to spec specifically calling out structured and dynamic reference
counters (2.6.7).</li><li><code>implicit</code>: Whether this is an implicitly generated operation, such as copies
done to satisfy &ldquo;Variables with Implicitly Determined Data Attributes&rdquo; in 2.6.2.</li><li><code>name</code>: Holds the name of variable as specified in user clause (including bounds).</li></ul><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-5>Attributes:&nbsp;<a class=headline-hash href=#attributes-5>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dataClause</code></td><td>::mlir::acc::DataClauseAttr</td><td><details><summary>data clauses supported by OpenACC</summary><p>Enum cases:</p><ul><li>acc_copyin (<code>acc_copyin</code>)</li><li>acc_copyin_readonly (<code>acc_copyin_readonly</code>)</li><li>acc_copy (<code>acc_copy</code>)</li><li>acc_copyout (<code>acc_copyout</code>)</li><li>acc_copyout_zero (<code>acc_copyout_zero</code>)</li><li>acc_present (<code>acc_present</code>)</li><li>acc_create (<code>acc_create</code>)</li><li>acc_create_zero (<code>acc_create_zero</code>)</li><li>acc_delete (<code>acc_delete</code>)</li><li>acc_attach (<code>acc_attach</code>)</li><li>acc_detach (<code>acc_detach</code>)</li><li>acc_no_create (<code>acc_no_create</code>)</li><li>acc_private (<code>acc_private</code>)</li><li>acc_firstprivate (<code>acc_firstprivate</code>)</li><li>acc_deviceptr (<code>acc_deviceptr</code>)</li><li>acc_getdeviceptr (<code>acc_getdeviceptr</code>)</li><li>acc_update_host (<code>acc_update_host</code>)</li><li>acc_update_self (<code>acc_update_self</code>)</li><li>acc_update_device (<code>acc_update_device</code>)</li><li>acc_use_device (<code>acc_use_device</code>)</li><li>acc_reduction (<code>acc_reduction</code>)</li><li>acc_declare_device_resident (<code>acc_declare_device_resident</code>)</li><li>acc_declare_link (<code>acc_declare_link</code>)</li><li>acc_cache (<code>acc_cache</code>)</li><li>acc_cache_readonly (<code>acc_cache_readonly</code>)</li></ul></details></td></tr><tr><td><code>structured</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>implicit</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>accPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>varPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>bounds</code></td><td>variadic of Type for representing acc data clause bounds information</td></tr></tbody></table><h3 id=acccreate-acccreateop><code>acc.create</code> (acc::CreateOp)&nbsp;<a class=headline-hash href=#acccreate-acccreateop>¶</a></h3><p><em>Represents create semantics for acc data clauses like acc create and acc copyout.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `acc.create` `varPtr` `(` $varPtr `:` type($varPtr) `)`
              oilist(
              `varPtrPtr` `(` $varPtrPtr `:` type($varPtrPtr) `)`
              | `bounds` `(` $bounds `)`
              ) `-&gt;` type($accPtr) attr-dict
</code></pre><p>Description of arguments:</p><ul><li><code>varPtr</code>: The address of variable to copy.</li><li><code>varPtrPtr</code>: Specifies the address of varPtr - only used when the variable
copied is a field in a struct. This is important for OpenACC due to implicit
attach semantics on data clauses (2.6.4).</li><li><code>bounds</code>: Used when copying just slice of array or array&rsquo;s bounds are not
encoded in type. They are in rank order where rank 0 is inner-most dimension.</li><li><code>dataClause</code>: Keeps track of the data clause the user used. This is because
the acc operations are decomposed. So a &lsquo;copy&rsquo; clause is decomposed to both
<code>acc.copyin</code> and <code>acc.copyout</code> operations, but both have dataClause that
specifies <code>acc_copy</code> in this field.</li><li><code>structured</code>: Flag to note whether this is associated with structured region
(parallel, kernels, data) or unstructured (enter data, exit data). This is
important due to spec specifically calling out structured and dynamic reference
counters (2.6.7).</li><li><code>implicit</code>: Whether this is an implicitly generated operation, such as copies
done to satisfy &ldquo;Variables with Implicitly Determined Data Attributes&rdquo; in 2.6.2.</li><li><code>name</code>: Holds the name of variable as specified in user clause (including bounds).</li></ul><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-6>Attributes:&nbsp;<a class=headline-hash href=#attributes-6>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dataClause</code></td><td>::mlir::acc::DataClauseAttr</td><td><details><summary>data clauses supported by OpenACC</summary><p>Enum cases:</p><ul><li>acc_copyin (<code>acc_copyin</code>)</li><li>acc_copyin_readonly (<code>acc_copyin_readonly</code>)</li><li>acc_copy (<code>acc_copy</code>)</li><li>acc_copyout (<code>acc_copyout</code>)</li><li>acc_copyout_zero (<code>acc_copyout_zero</code>)</li><li>acc_present (<code>acc_present</code>)</li><li>acc_create (<code>acc_create</code>)</li><li>acc_create_zero (<code>acc_create_zero</code>)</li><li>acc_delete (<code>acc_delete</code>)</li><li>acc_attach (<code>acc_attach</code>)</li><li>acc_detach (<code>acc_detach</code>)</li><li>acc_no_create (<code>acc_no_create</code>)</li><li>acc_private (<code>acc_private</code>)</li><li>acc_firstprivate (<code>acc_firstprivate</code>)</li><li>acc_deviceptr (<code>acc_deviceptr</code>)</li><li>acc_getdeviceptr (<code>acc_getdeviceptr</code>)</li><li>acc_update_host (<code>acc_update_host</code>)</li><li>acc_update_self (<code>acc_update_self</code>)</li><li>acc_update_device (<code>acc_update_device</code>)</li><li>acc_use_device (<code>acc_use_device</code>)</li><li>acc_reduction (<code>acc_reduction</code>)</li><li>acc_declare_device_resident (<code>acc_declare_device_resident</code>)</li><li>acc_declare_link (<code>acc_declare_link</code>)</li><li>acc_cache (<code>acc_cache</code>)</li><li>acc_cache_readonly (<code>acc_cache_readonly</code>)</li></ul></details></td></tr><tr><td><code>structured</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>implicit</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>varPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>varPtrPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>bounds</code></td><td>variadic of Type for representing acc data clause bounds information</td></tr></tbody></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>accPtr</code></td><td>PointerLikeType instance</td></tr></tbody></table><h3 id=accdata-accdataop><code>acc.data</code> (acc::DataOp)&nbsp;<a class=headline-hash href=#accdata-accdataop>¶</a></h3><p><em>Data construct</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `acc.data` oilist(
              `if` `(` $ifCond `)`
              | `async` `(` $async `:` type($async) `)`
              | `dataOperands` `(` $dataClauseOperands `:` type($dataClauseOperands) `)`
              | `wait_devnum` `(` $waitDevnum `:` type($waitDevnum) `)`
              | `wait` `(` $waitOperands `:` type($waitOperands) `)`
              )
              $region attr-dict-with-keyword
</code></pre><p>The &ldquo;acc.data&rdquo; operation represents a data construct. It defines vars to
be allocated in the current device memory for the duration of the region,
whether data should be copied from local memory to the current device
memory upon region entry , and copied from device memory to local memory
upon region exit.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>acc<span class=p>.</span>data present<span class=p>(</span><span class=nv>%a</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>10x10x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=nv>%b</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>10x10x</span><span class=k>f32</span><span class=p>&gt;,</span>
</span></span><span class=line><span class=cl>    <span class=nv>%c</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>10x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=nv>%d</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>10x</span><span class=k>f32</span><span class=p>&gt;)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c>// data region
</span></span></span><span class=line><span class=cl><span class=c></span><span class=p>}</span>
</span></span></code></pre></div><p>Traits: AttrSizedOperandSegments, RecursiveMemoryEffects</p><h4 id=attributes-7>Attributes:&nbsp;<a class=headline-hash href=#attributes-7>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>asyncAttr</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>waitAttr</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>defaultAttr</code></td><td>::mlir::acc::ClauseDefaultValueAttr</td><td><details><summary>DefaultValue Clause</summary><p>Enum cases:</p><ul><li>present (<code>Present</code>)</li><li>none (<code>None</code>)</li></ul></details></td></tr></table><h4 id=operands-9>Operands:&nbsp;<a class=headline-hash href=#operands-9>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ifCond</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>async</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>waitDevnum</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>waitOperands</code></td><td>variadic of integer or index</td></tr><tr><td style=text-align:center><code>dataClauseOperands</code></td><td>variadic of PointerLikeType instance</td></tr></tbody></table><h3 id=accdeclare-accdeclareop><code>acc.declare</code> (acc::DeclareOp)&nbsp;<a class=headline-hash href=#accdeclare-accdeclareop>¶</a></h3><p><em>Declare implicit region</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `acc.declare` `dataOperands` `(` $dataClauseOperands `:` type($dataClauseOperands) `)`
              $region attr-dict-with-keyword
</code></pre><p>The &ldquo;acc.declare&rdquo; operation represents an implicit declare region in
function (and subroutine in Fortran).</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%pa</span> <span class=p>=</span> acc<span class=p>.</span>present varPtr<span class=p>(</span><span class=nv>%a</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>10x10x</span><span class=k>f32</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>10x10x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>acc<span class=p>.</span>declare dataOperands<span class=p>(</span><span class=nv>%pa</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>10x10x</span><span class=k>f32</span><span class=p>&gt;)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c>// implicit region
</span></span></span><span class=line><span class=cl><span class=c></span><span class=p>}</span>
</span></span></code></pre></div><p>Traits: RecursiveMemoryEffects</p><h4 id=operands-10>Operands:&nbsp;<a class=headline-hash href=#operands-10>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dataClauseOperands</code></td><td>variadic of PointerLikeType instance</td></tr></tbody></table><h3 id=accdeclare_device_resident-accdeclaredeviceresidentop><code>acc.declare_device_resident</code> (acc::DeclareDeviceResidentOp)&nbsp;<a class=headline-hash href=#accdeclare_device_resident-accdeclaredeviceresidentop>¶</a></h3><p><em>Represents acc declare device_resident semantics.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `acc.declare_device_resident` `varPtr` `(` $varPtr `:` type($varPtr) `)`
              oilist(
              `varPtrPtr` `(` $varPtrPtr `:` type($varPtrPtr) `)`
              | `bounds` `(` $bounds `)`
              ) `-&gt;` type($accPtr) attr-dict
</code></pre><p>Description of arguments:</p><ul><li><code>varPtr</code>: The address of variable to copy.</li><li><code>varPtrPtr</code>: Specifies the address of varPtr - only used when the variable
copied is a field in a struct. This is important for OpenACC due to implicit
attach semantics on data clauses (2.6.4).</li><li><code>bounds</code>: Used when copying just slice of array or array&rsquo;s bounds are not
encoded in type. They are in rank order where rank 0 is inner-most dimension.</li><li><code>dataClause</code>: Keeps track of the data clause the user used. This is because
the acc operations are decomposed. So a &lsquo;copy&rsquo; clause is decomposed to both
<code>acc.copyin</code> and <code>acc.copyout</code> operations, but both have dataClause that
specifies <code>acc_copy</code> in this field.</li><li><code>structured</code>: Flag to note whether this is associated with structured region
(parallel, kernels, data) or unstructured (enter data, exit data). This is
important due to spec specifically calling out structured and dynamic reference
counters (2.6.7).</li><li><code>implicit</code>: Whether this is an implicitly generated operation, such as copies
done to satisfy &ldquo;Variables with Implicitly Determined Data Attributes&rdquo; in 2.6.2.</li><li><code>name</code>: Holds the name of variable as specified in user clause (including bounds).</li></ul><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-8>Attributes:&nbsp;<a class=headline-hash href=#attributes-8>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dataClause</code></td><td>::mlir::acc::DataClauseAttr</td><td><details><summary>data clauses supported by OpenACC</summary><p>Enum cases:</p><ul><li>acc_copyin (<code>acc_copyin</code>)</li><li>acc_copyin_readonly (<code>acc_copyin_readonly</code>)</li><li>acc_copy (<code>acc_copy</code>)</li><li>acc_copyout (<code>acc_copyout</code>)</li><li>acc_copyout_zero (<code>acc_copyout_zero</code>)</li><li>acc_present (<code>acc_present</code>)</li><li>acc_create (<code>acc_create</code>)</li><li>acc_create_zero (<code>acc_create_zero</code>)</li><li>acc_delete (<code>acc_delete</code>)</li><li>acc_attach (<code>acc_attach</code>)</li><li>acc_detach (<code>acc_detach</code>)</li><li>acc_no_create (<code>acc_no_create</code>)</li><li>acc_private (<code>acc_private</code>)</li><li>acc_firstprivate (<code>acc_firstprivate</code>)</li><li>acc_deviceptr (<code>acc_deviceptr</code>)</li><li>acc_getdeviceptr (<code>acc_getdeviceptr</code>)</li><li>acc_update_host (<code>acc_update_host</code>)</li><li>acc_update_self (<code>acc_update_self</code>)</li><li>acc_update_device (<code>acc_update_device</code>)</li><li>acc_use_device (<code>acc_use_device</code>)</li><li>acc_reduction (<code>acc_reduction</code>)</li><li>acc_declare_device_resident (<code>acc_declare_device_resident</code>)</li><li>acc_declare_link (<code>acc_declare_link</code>)</li><li>acc_cache (<code>acc_cache</code>)</li><li>acc_cache_readonly (<code>acc_cache_readonly</code>)</li></ul></details></td></tr><tr><td><code>structured</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>implicit</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-11>Operands:&nbsp;<a class=headline-hash href=#operands-11>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>varPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>varPtrPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>bounds</code></td><td>variadic of Type for representing acc data clause bounds information</td></tr></tbody></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>accPtr</code></td><td>PointerLikeType instance</td></tr></tbody></table><h3 id=accdeclare_enter-accdeclareenterop><code>acc.declare_enter</code> (acc::DeclareEnterOp)&nbsp;<a class=headline-hash href=#accdeclare_enter-accdeclareenterop>¶</a></h3><p><em>Declare directive - entry to implicit data region</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `acc.declare_enter` oilist(
              `dataOperands` `(` $dataClauseOperands `:` type($dataClauseOperands) `)`
              )
              attr-dict-with-keyword
</code></pre><p>The &ldquo;acc.declare_enter&rdquo; operation represents the OpenACC declare directive
and captures the entry semantics to the implicit data region.
This operation is modeled similarly to &ldquo;acc.enter_data&rdquo;.</p><p>Example showing <code>acc declare create(a)</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> acc<span class=p>.</span>create varPtr<span class=p>(</span><span class=nv>%a</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>.</span>ptr
</span></span><span class=line><span class=cl>acc<span class=p>.</span>declare_enter dataOperands<span class=p>(</span><span class=nv>%0</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>)</span>
</span></span></code></pre></div><h4 id=operands-12>Operands:&nbsp;<a class=headline-hash href=#operands-12>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dataClauseOperands</code></td><td>variadic of PointerLikeType instance</td></tr></tbody></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>token</code></td><td>declare token type</td></tr></tbody></table><h3 id=accdeclare_exit-accdeclareexitop><code>acc.declare_exit</code> (acc::DeclareExitOp)&nbsp;<a class=headline-hash href=#accdeclare_exit-accdeclareexitop>¶</a></h3><p><em>Declare directive - exit from implicit data region</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `acc.declare_exit` oilist(
              `token` `(` $token `)` |
              `dataOperands` `(` $dataClauseOperands `:` type($dataClauseOperands) `)`
              )
              attr-dict-with-keyword
</code></pre><p>The &ldquo;acc.declare_exit&rdquo; operation represents the OpenACC declare directive
and captures the exit semantics from the implicit data region.
This operation is modeled similarly to &ldquo;acc.exit_data&rdquo;.</p><p>Example showing <code>acc declare device_resident(a)</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> acc<span class=p>.</span>getdeviceptr varPtr<span class=p>(</span><span class=nv>%a</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>.</span>ptr <span class=p>{</span><span class=nl>dataClause =</span> <span class=nv>#acc</span><span class=p>&lt;</span>data_clause declare_device_resident<span class=p>&gt;}</span>
</span></span><span class=line><span class=cl>acc<span class=p>.</span>declare_exit dataOperands<span class=p>(</span><span class=nv>%0</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>)</span>
</span></span><span class=line><span class=cl>acc<span class=p>.</span>delete accPtr<span class=p>(</span><span class=nv>%0</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>)</span> <span class=p>{</span><span class=nl>dataClause =</span> <span class=nv>#acc</span><span class=p>&lt;</span>data_clause declare_device_resident<span class=p>&gt;}</span>
</span></span></code></pre></div><p>Traits: AttrSizedOperandSegments</p><h4 id=operands-13>Operands:&nbsp;<a class=headline-hash href=#operands-13>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>token</code></td><td>declare token type</td></tr><tr><td style=text-align:center><code>dataClauseOperands</code></td><td>variadic of PointerLikeType instance</td></tr></tbody></table><h3 id=accdeclare_link-accdeclarelinkop><code>acc.declare_link</code> (acc::DeclareLinkOp)&nbsp;<a class=headline-hash href=#accdeclare_link-accdeclarelinkop>¶</a></h3><p><em>Represents acc declare link semantics.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `acc.declare_link` `varPtr` `(` $varPtr `:` type($varPtr) `)`
              oilist(
              `varPtrPtr` `(` $varPtrPtr `:` type($varPtrPtr) `)`
              | `bounds` `(` $bounds `)`
              ) `-&gt;` type($accPtr) attr-dict
</code></pre><p>Description of arguments:</p><ul><li><code>varPtr</code>: The address of variable to copy.</li><li><code>varPtrPtr</code>: Specifies the address of varPtr - only used when the variable
copied is a field in a struct. This is important for OpenACC due to implicit
attach semantics on data clauses (2.6.4).</li><li><code>bounds</code>: Used when copying just slice of array or array&rsquo;s bounds are not
encoded in type. They are in rank order where rank 0 is inner-most dimension.</li><li><code>dataClause</code>: Keeps track of the data clause the user used. This is because
the acc operations are decomposed. So a &lsquo;copy&rsquo; clause is decomposed to both
<code>acc.copyin</code> and <code>acc.copyout</code> operations, but both have dataClause that
specifies <code>acc_copy</code> in this field.</li><li><code>structured</code>: Flag to note whether this is associated with structured region
(parallel, kernels, data) or unstructured (enter data, exit data). This is
important due to spec specifically calling out structured and dynamic reference
counters (2.6.7).</li><li><code>implicit</code>: Whether this is an implicitly generated operation, such as copies
done to satisfy &ldquo;Variables with Implicitly Determined Data Attributes&rdquo; in 2.6.2.</li><li><code>name</code>: Holds the name of variable as specified in user clause (including bounds).</li></ul><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-9>Attributes:&nbsp;<a class=headline-hash href=#attributes-9>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dataClause</code></td><td>::mlir::acc::DataClauseAttr</td><td><details><summary>data clauses supported by OpenACC</summary><p>Enum cases:</p><ul><li>acc_copyin (<code>acc_copyin</code>)</li><li>acc_copyin_readonly (<code>acc_copyin_readonly</code>)</li><li>acc_copy (<code>acc_copy</code>)</li><li>acc_copyout (<code>acc_copyout</code>)</li><li>acc_copyout_zero (<code>acc_copyout_zero</code>)</li><li>acc_present (<code>acc_present</code>)</li><li>acc_create (<code>acc_create</code>)</li><li>acc_create_zero (<code>acc_create_zero</code>)</li><li>acc_delete (<code>acc_delete</code>)</li><li>acc_attach (<code>acc_attach</code>)</li><li>acc_detach (<code>acc_detach</code>)</li><li>acc_no_create (<code>acc_no_create</code>)</li><li>acc_private (<code>acc_private</code>)</li><li>acc_firstprivate (<code>acc_firstprivate</code>)</li><li>acc_deviceptr (<code>acc_deviceptr</code>)</li><li>acc_getdeviceptr (<code>acc_getdeviceptr</code>)</li><li>acc_update_host (<code>acc_update_host</code>)</li><li>acc_update_self (<code>acc_update_self</code>)</li><li>acc_update_device (<code>acc_update_device</code>)</li><li>acc_use_device (<code>acc_use_device</code>)</li><li>acc_reduction (<code>acc_reduction</code>)</li><li>acc_declare_device_resident (<code>acc_declare_device_resident</code>)</li><li>acc_declare_link (<code>acc_declare_link</code>)</li><li>acc_cache (<code>acc_cache</code>)</li><li>acc_cache_readonly (<code>acc_cache_readonly</code>)</li></ul></details></td></tr><tr><td><code>structured</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>implicit</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-14>Operands:&nbsp;<a class=headline-hash href=#operands-14>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>varPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>varPtrPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>bounds</code></td><td>variadic of Type for representing acc data clause bounds information</td></tr></tbody></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>accPtr</code></td><td>PointerLikeType instance</td></tr></tbody></table><h3 id=accdelete-accdeleteop><code>acc.delete</code> (acc::DeleteOp)&nbsp;<a class=headline-hash href=#accdelete-accdeleteop>¶</a></h3><p><em>Represents acc delete semantics - reverse of create.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `acc.delete` `accPtr` `(` $accPtr `:` type($accPtr) `)`
              oilist(
              `bounds` `(` $bounds `)`
              | `to` `varPtr` `(` $varPtr `:` type($varPtr) `)`
              ) attr-dict
</code></pre><ul><li><code>varPtr</code>: The address of variable to copy back to. This only applies to
<code>acc.copyout</code></li><li><code>accPtr</code>: The acc address of variable. This is the link from the data-entry
operation used.</li><li><code>bounds</code>: Used when copying just slice of array or array&rsquo;s bounds are not
encoded in type. They are in rank order where rank 0 is inner-most dimension.</li><li><code>dataClause</code>: Keeps track of the data clause the user used. This is because
the acc operations are decomposed. So a &lsquo;copy&rsquo; clause is decomposed to both
<code>acc.copyin</code> and <code>acc.copyout</code> operations, but both have dataClause that
specifies <code>acc_copy</code> in this field.</li><li><code>structured</code>: Flag to note whether this is associated with structured region
(parallel, kernels, data) or unstructured (enter data, exit data). This is
important due to spec specifically calling out structured and dynamic reference
counters (2.6.7).</li><li><code>implicit</code>: Whether this is an implicitly generated operation, such as copies
done to satisfy &ldquo;Variables with Implicitly Determined Data Attributes&rdquo; in 2.6.2.</li><li><code>name</code>: Holds the name of variable as specified in user clause (including bounds).</li></ul><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-10>Attributes:&nbsp;<a class=headline-hash href=#attributes-10>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dataClause</code></td><td>::mlir::acc::DataClauseAttr</td><td><details><summary>data clauses supported by OpenACC</summary><p>Enum cases:</p><ul><li>acc_copyin (<code>acc_copyin</code>)</li><li>acc_copyin_readonly (<code>acc_copyin_readonly</code>)</li><li>acc_copy (<code>acc_copy</code>)</li><li>acc_copyout (<code>acc_copyout</code>)</li><li>acc_copyout_zero (<code>acc_copyout_zero</code>)</li><li>acc_present (<code>acc_present</code>)</li><li>acc_create (<code>acc_create</code>)</li><li>acc_create_zero (<code>acc_create_zero</code>)</li><li>acc_delete (<code>acc_delete</code>)</li><li>acc_attach (<code>acc_attach</code>)</li><li>acc_detach (<code>acc_detach</code>)</li><li>acc_no_create (<code>acc_no_create</code>)</li><li>acc_private (<code>acc_private</code>)</li><li>acc_firstprivate (<code>acc_firstprivate</code>)</li><li>acc_deviceptr (<code>acc_deviceptr</code>)</li><li>acc_getdeviceptr (<code>acc_getdeviceptr</code>)</li><li>acc_update_host (<code>acc_update_host</code>)</li><li>acc_update_self (<code>acc_update_self</code>)</li><li>acc_update_device (<code>acc_update_device</code>)</li><li>acc_use_device (<code>acc_use_device</code>)</li><li>acc_reduction (<code>acc_reduction</code>)</li><li>acc_declare_device_resident (<code>acc_declare_device_resident</code>)</li><li>acc_declare_link (<code>acc_declare_link</code>)</li><li>acc_cache (<code>acc_cache</code>)</li><li>acc_cache_readonly (<code>acc_cache_readonly</code>)</li></ul></details></td></tr><tr><td><code>structured</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>implicit</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-15>Operands:&nbsp;<a class=headline-hash href=#operands-15>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>accPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>varPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>bounds</code></td><td>variadic of Type for representing acc data clause bounds information</td></tr></tbody></table><h3 id=accdetach-accdetachop><code>acc.detach</code> (acc::DetachOp)&nbsp;<a class=headline-hash href=#accdetach-accdetachop>¶</a></h3><p><em>Represents acc detach semantics - reverse of attach.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `acc.detach` `accPtr` `(` $accPtr `:` type($accPtr) `)`
              oilist(
              `bounds` `(` $bounds `)`
              | `to` `varPtr` `(` $varPtr `:` type($varPtr) `)`
              ) attr-dict
</code></pre><ul><li><code>varPtr</code>: The address of variable to copy back to. This only applies to
<code>acc.copyout</code></li><li><code>accPtr</code>: The acc address of variable. This is the link from the data-entry
operation used.</li><li><code>bounds</code>: Used when copying just slice of array or array&rsquo;s bounds are not
encoded in type. They are in rank order where rank 0 is inner-most dimension.</li><li><code>dataClause</code>: Keeps track of the data clause the user used. This is because
the acc operations are decomposed. So a &lsquo;copy&rsquo; clause is decomposed to both
<code>acc.copyin</code> and <code>acc.copyout</code> operations, but both have dataClause that
specifies <code>acc_copy</code> in this field.</li><li><code>structured</code>: Flag to note whether this is associated with structured region
(parallel, kernels, data) or unstructured (enter data, exit data). This is
important due to spec specifically calling out structured and dynamic reference
counters (2.6.7).</li><li><code>implicit</code>: Whether this is an implicitly generated operation, such as copies
done to satisfy &ldquo;Variables with Implicitly Determined Data Attributes&rdquo; in 2.6.2.</li><li><code>name</code>: Holds the name of variable as specified in user clause (including bounds).</li></ul><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-11>Attributes:&nbsp;<a class=headline-hash href=#attributes-11>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dataClause</code></td><td>::mlir::acc::DataClauseAttr</td><td><details><summary>data clauses supported by OpenACC</summary><p>Enum cases:</p><ul><li>acc_copyin (<code>acc_copyin</code>)</li><li>acc_copyin_readonly (<code>acc_copyin_readonly</code>)</li><li>acc_copy (<code>acc_copy</code>)</li><li>acc_copyout (<code>acc_copyout</code>)</li><li>acc_copyout_zero (<code>acc_copyout_zero</code>)</li><li>acc_present (<code>acc_present</code>)</li><li>acc_create (<code>acc_create</code>)</li><li>acc_create_zero (<code>acc_create_zero</code>)</li><li>acc_delete (<code>acc_delete</code>)</li><li>acc_attach (<code>acc_attach</code>)</li><li>acc_detach (<code>acc_detach</code>)</li><li>acc_no_create (<code>acc_no_create</code>)</li><li>acc_private (<code>acc_private</code>)</li><li>acc_firstprivate (<code>acc_firstprivate</code>)</li><li>acc_deviceptr (<code>acc_deviceptr</code>)</li><li>acc_getdeviceptr (<code>acc_getdeviceptr</code>)</li><li>acc_update_host (<code>acc_update_host</code>)</li><li>acc_update_self (<code>acc_update_self</code>)</li><li>acc_update_device (<code>acc_update_device</code>)</li><li>acc_use_device (<code>acc_use_device</code>)</li><li>acc_reduction (<code>acc_reduction</code>)</li><li>acc_declare_device_resident (<code>acc_declare_device_resident</code>)</li><li>acc_declare_link (<code>acc_declare_link</code>)</li><li>acc_cache (<code>acc_cache</code>)</li><li>acc_cache_readonly (<code>acc_cache_readonly</code>)</li></ul></details></td></tr><tr><td><code>structured</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>implicit</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-16>Operands:&nbsp;<a class=headline-hash href=#operands-16>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>accPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>varPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>bounds</code></td><td>variadic of Type for representing acc data clause bounds information</td></tr></tbody></table><h3 id=accdeviceptr-accdeviceptrop><code>acc.deviceptr</code> (acc::DevicePtrOp)&nbsp;<a class=headline-hash href=#accdeviceptr-accdeviceptrop>¶</a></h3><p><em>Specifies that the variable pointer is a device pointer.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `acc.deviceptr` `varPtr` `(` $varPtr `:` type($varPtr) `)`
              oilist(
              `varPtrPtr` `(` $varPtrPtr `:` type($varPtrPtr) `)`
              | `bounds` `(` $bounds `)`
              ) `-&gt;` type($accPtr) attr-dict
</code></pre><p>Description of arguments:</p><ul><li><code>varPtr</code>: The address of variable to copy.</li><li><code>varPtrPtr</code>: Specifies the address of varPtr - only used when the variable
copied is a field in a struct. This is important for OpenACC due to implicit
attach semantics on data clauses (2.6.4).</li><li><code>bounds</code>: Used when copying just slice of array or array&rsquo;s bounds are not
encoded in type. They are in rank order where rank 0 is inner-most dimension.</li><li><code>dataClause</code>: Keeps track of the data clause the user used. This is because
the acc operations are decomposed. So a &lsquo;copy&rsquo; clause is decomposed to both
<code>acc.copyin</code> and <code>acc.copyout</code> operations, but both have dataClause that
specifies <code>acc_copy</code> in this field.</li><li><code>structured</code>: Flag to note whether this is associated with structured region
(parallel, kernels, data) or unstructured (enter data, exit data). This is
important due to spec specifically calling out structured and dynamic reference
counters (2.6.7).</li><li><code>implicit</code>: Whether this is an implicitly generated operation, such as copies
done to satisfy &ldquo;Variables with Implicitly Determined Data Attributes&rdquo; in 2.6.2.</li><li><code>name</code>: Holds the name of variable as specified in user clause (including bounds).</li></ul><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-12>Attributes:&nbsp;<a class=headline-hash href=#attributes-12>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dataClause</code></td><td>::mlir::acc::DataClauseAttr</td><td><details><summary>data clauses supported by OpenACC</summary><p>Enum cases:</p><ul><li>acc_copyin (<code>acc_copyin</code>)</li><li>acc_copyin_readonly (<code>acc_copyin_readonly</code>)</li><li>acc_copy (<code>acc_copy</code>)</li><li>acc_copyout (<code>acc_copyout</code>)</li><li>acc_copyout_zero (<code>acc_copyout_zero</code>)</li><li>acc_present (<code>acc_present</code>)</li><li>acc_create (<code>acc_create</code>)</li><li>acc_create_zero (<code>acc_create_zero</code>)</li><li>acc_delete (<code>acc_delete</code>)</li><li>acc_attach (<code>acc_attach</code>)</li><li>acc_detach (<code>acc_detach</code>)</li><li>acc_no_create (<code>acc_no_create</code>)</li><li>acc_private (<code>acc_private</code>)</li><li>acc_firstprivate (<code>acc_firstprivate</code>)</li><li>acc_deviceptr (<code>acc_deviceptr</code>)</li><li>acc_getdeviceptr (<code>acc_getdeviceptr</code>)</li><li>acc_update_host (<code>acc_update_host</code>)</li><li>acc_update_self (<code>acc_update_self</code>)</li><li>acc_update_device (<code>acc_update_device</code>)</li><li>acc_use_device (<code>acc_use_device</code>)</li><li>acc_reduction (<code>acc_reduction</code>)</li><li>acc_declare_device_resident (<code>acc_declare_device_resident</code>)</li><li>acc_declare_link (<code>acc_declare_link</code>)</li><li>acc_cache (<code>acc_cache</code>)</li><li>acc_cache_readonly (<code>acc_cache_readonly</code>)</li></ul></details></td></tr><tr><td><code>structured</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>implicit</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-17>Operands:&nbsp;<a class=headline-hash href=#operands-17>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>varPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>varPtrPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>bounds</code></td><td>variadic of Type for representing acc data clause bounds information</td></tr></tbody></table><h4 id=results-8>Results:&nbsp;<a class=headline-hash href=#results-8>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>accPtr</code></td><td>PointerLikeType instance</td></tr></tbody></table><h3 id=accenter_data-accenterdataop><code>acc.enter_data</code> (acc::EnterDataOp)&nbsp;<a class=headline-hash href=#accenter_data-accenterdataop>¶</a></h3><p><em>Enter data operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `acc.enter_data` oilist(
              `if` `(` $ifCond `)`
              | `async` `(` $asyncOperand `:` type($asyncOperand) `)`
              | `wait_devnum` `(` $waitDevnum `:` type($waitDevnum) `)`
              | `wait` `(` $waitOperands `:` type($waitOperands) `)`
              | `dataOperands` `(` $dataClauseOperands `:` type($dataClauseOperands) `)`
              )
              attr-dict-with-keyword
</code></pre><p>The &ldquo;acc.enter_data&rdquo; operation represents the OpenACC enter data directive.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>acc<span class=p>.</span>enter_data create<span class=p>(</span><span class=nv>%d1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>10x</span><span class=k>f32</span><span class=p>&gt;)</span> attributes <span class=p>{</span>async<span class=p>}</span>
</span></span></code></pre></div><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-13>Attributes:&nbsp;<a class=headline-hash href=#attributes-13>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>async</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>wait</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-18>Operands:&nbsp;<a class=headline-hash href=#operands-18>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ifCond</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>asyncOperand</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>waitDevnum</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>waitOperands</code></td><td>variadic of integer or index</td></tr><tr><td style=text-align:center><code>dataClauseOperands</code></td><td>variadic of PointerLikeType instance</td></tr></tbody></table><h3 id=accexit_data-accexitdataop><code>acc.exit_data</code> (acc::ExitDataOp)&nbsp;<a class=headline-hash href=#accexit_data-accexitdataop>¶</a></h3><p><em>Exit data operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `acc.exit_data` oilist(
              `if` `(` $ifCond `)`
              | `async` `(` $asyncOperand `:` type($asyncOperand) `)`
              | `wait_devnum` `(` $waitDevnum `:` type($waitDevnum) `)`
              | `wait` `(` $waitOperands `:` type($waitOperands) `)`
              | `dataOperands` `(` $dataClauseOperands `:` type($dataClauseOperands) `)`
              )
              attr-dict-with-keyword
</code></pre><p>The &ldquo;acc.exit_data&rdquo; operation represents the OpenACC exit data directive.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>acc<span class=p>.</span>exit_data delete<span class=p>(</span><span class=nv>%d1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>10x</span><span class=k>f32</span><span class=p>&gt;)</span> attributes <span class=p>{</span>async<span class=p>}</span>
</span></span></code></pre></div><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-14>Attributes:&nbsp;<a class=headline-hash href=#attributes-14>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>async</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>wait</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>finalize</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-19>Operands:&nbsp;<a class=headline-hash href=#operands-19>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ifCond</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>asyncOperand</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>waitDevnum</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>waitOperands</code></td><td>variadic of integer or index</td></tr><tr><td style=text-align:center><code>dataClauseOperands</code></td><td>variadic of PointerLikeType instance</td></tr></tbody></table><h3 id=accfirstprivate-accfirstprivateop><code>acc.firstprivate</code> (acc::FirstprivateOp)&nbsp;<a class=headline-hash href=#accfirstprivate-accfirstprivateop>¶</a></h3><p><em>Represents firstprivate semantic for the acc firstprivate clause.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `acc.firstprivate` `varPtr` `(` $varPtr `:` type($varPtr) `)`
              oilist(
              `varPtrPtr` `(` $varPtrPtr `:` type($varPtrPtr) `)`
              | `bounds` `(` $bounds `)`
              ) `-&gt;` type($accPtr) attr-dict
</code></pre><p>Description of arguments:</p><ul><li><code>varPtr</code>: The address of variable to copy.</li><li><code>varPtrPtr</code>: Specifies the address of varPtr - only used when the variable
copied is a field in a struct. This is important for OpenACC due to implicit
attach semantics on data clauses (2.6.4).</li><li><code>bounds</code>: Used when copying just slice of array or array&rsquo;s bounds are not
encoded in type. They are in rank order where rank 0 is inner-most dimension.</li><li><code>dataClause</code>: Keeps track of the data clause the user used. This is because
the acc operations are decomposed. So a &lsquo;copy&rsquo; clause is decomposed to both
<code>acc.copyin</code> and <code>acc.copyout</code> operations, but both have dataClause that
specifies <code>acc_copy</code> in this field.</li><li><code>structured</code>: Flag to note whether this is associated with structured region
(parallel, kernels, data) or unstructured (enter data, exit data). This is
important due to spec specifically calling out structured and dynamic reference
counters (2.6.7).</li><li><code>implicit</code>: Whether this is an implicitly generated operation, such as copies
done to satisfy &ldquo;Variables with Implicitly Determined Data Attributes&rdquo; in 2.6.2.</li><li><code>name</code>: Holds the name of variable as specified in user clause (including bounds).</li></ul><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-15>Attributes:&nbsp;<a class=headline-hash href=#attributes-15>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dataClause</code></td><td>::mlir::acc::DataClauseAttr</td><td><details><summary>data clauses supported by OpenACC</summary><p>Enum cases:</p><ul><li>acc_copyin (<code>acc_copyin</code>)</li><li>acc_copyin_readonly (<code>acc_copyin_readonly</code>)</li><li>acc_copy (<code>acc_copy</code>)</li><li>acc_copyout (<code>acc_copyout</code>)</li><li>acc_copyout_zero (<code>acc_copyout_zero</code>)</li><li>acc_present (<code>acc_present</code>)</li><li>acc_create (<code>acc_create</code>)</li><li>acc_create_zero (<code>acc_create_zero</code>)</li><li>acc_delete (<code>acc_delete</code>)</li><li>acc_attach (<code>acc_attach</code>)</li><li>acc_detach (<code>acc_detach</code>)</li><li>acc_no_create (<code>acc_no_create</code>)</li><li>acc_private (<code>acc_private</code>)</li><li>acc_firstprivate (<code>acc_firstprivate</code>)</li><li>acc_deviceptr (<code>acc_deviceptr</code>)</li><li>acc_getdeviceptr (<code>acc_getdeviceptr</code>)</li><li>acc_update_host (<code>acc_update_host</code>)</li><li>acc_update_self (<code>acc_update_self</code>)</li><li>acc_update_device (<code>acc_update_device</code>)</li><li>acc_use_device (<code>acc_use_device</code>)</li><li>acc_reduction (<code>acc_reduction</code>)</li><li>acc_declare_device_resident (<code>acc_declare_device_resident</code>)</li><li>acc_declare_link (<code>acc_declare_link</code>)</li><li>acc_cache (<code>acc_cache</code>)</li><li>acc_cache_readonly (<code>acc_cache_readonly</code>)</li></ul></details></td></tr><tr><td><code>structured</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>implicit</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-20>Operands:&nbsp;<a class=headline-hash href=#operands-20>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>varPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>varPtrPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>bounds</code></td><td>variadic of Type for representing acc data clause bounds information</td></tr></tbody></table><h4 id=results-9>Results:&nbsp;<a class=headline-hash href=#results-9>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>accPtr</code></td><td>PointerLikeType instance</td></tr></tbody></table><h3 id=accfirstprivaterecipe-accfirstprivaterecipeop><code>acc.firstprivate.recipe</code> (acc::FirstprivateRecipeOp)&nbsp;<a class=headline-hash href=#accfirstprivaterecipe-accfirstprivaterecipeop>¶</a></h3><p><em>Privatization recipe</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `acc.firstprivate.recipe` $sym_name `:` $type attr-dict-with-keyword `init` $initRegion
              `copy` $copyRegion
              (`destroy` $destroyRegion^)?
</code></pre><p>Declares an OpenACC privatization recipe with copy of the initial value.
The operation requires two mandatory regions and one optional.</p><ol><li>The initializer region specifies how to allocate and initialize a new
private value. For example in Fortran, a derived-type might have a
default initialization. The region has an argument that contains the
value that need to be privatized. This is useful if the type is not
known at compile time and the private value is needed to create its
copy.</li><li>The copy region specifies how to copy the initial value to the newly
created private value. It takes the initial value and the privatized
value as arguments.</li><li>The destroy region specifies how to destruct the value when it reaches
its end of life. It takes the privatized value as argument. It is
optional.</li></ol><p>A single privatization recipe can be used for multiple operand if they have
the same type and do not require a specific default initialization.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>acc<span class=p>.</span>firstprivate<span class=p>.</span>recipe <span class=nf>@privatization_f32</span> <span class=p>:</span> <span class=k>f32</span> init <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=nl>^bb0</span><span class=p>(</span><span class=nv>%0</span><span class=p>:</span> <span class=k>f32</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=c>// init region contains a sequence of operations to create and
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>// initialize the copy if needed. It yields the create copy.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=p>}</span> copy <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=nl>^bb0</span><span class=p>(</span><span class=nv>%0</span><span class=p>:</span> <span class=k>f32</span><span class=p>,</span> <span class=nv>%1</span><span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=c>// copy region contains a sequence of operations to copy the initial value
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>// of the firstprivate value to the newly created value.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=p>}</span> destroy <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=nl>^bb0</span><span class=p>(</span><span class=nv>%0</span><span class=p>:</span> <span class=k>f32</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=c>// destroy region contains a sequences of operations to destruct the
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>// created copy.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// The privatization symbol is then used in the corresponding operation.
</span></span></span><span class=line><span class=cl><span class=c></span>acc<span class=p>.</span>parallel firstprivate<span class=p>(</span><span class=nf>@privatization_f32</span> <span class=p>-&gt;</span> <span class=nv>%a</span> <span class=p>:</span> <span class=k>f32</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Traits: IsolatedFromAbove</p><p>Interfaces: RecipeInterface, Symbol</p><h4 id=attributes-16>Attributes:&nbsp;<a class=headline-hash href=#attributes-16>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>type</code></td><td>::mlir::TypeAttr</td><td>any type attribute</td></tr></table><h3 id=accgetdeviceptr-accgetdeviceptrop><code>acc.getdeviceptr</code> (acc::GetDevicePtrOp)&nbsp;<a class=headline-hash href=#accgetdeviceptr-accgetdeviceptrop>¶</a></h3><p><em>Gets device address if variable exists on device.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `acc.getdeviceptr` `varPtr` `(` $varPtr `:` type($varPtr) `)`
              oilist(
              `varPtrPtr` `(` $varPtrPtr `:` type($varPtrPtr) `)`
              | `bounds` `(` $bounds `)`
              ) `-&gt;` type($accPtr) attr-dict
</code></pre><p>This operation is used to get the <code>accPtr</code> for a variable. This is often
used in conjunction with data exit operations when the data entry
operation is not visible. This operation can have a <code>dataClause</code> argument
that is any of the valid <code>mlir::acc::DataClause</code> entries.
\</p><p>Description of arguments:</p><ul><li><code>varPtr</code>: The address of variable to copy.</li><li><code>varPtrPtr</code>: Specifies the address of varPtr - only used when the variable
copied is a field in a struct. This is important for OpenACC due to implicit
attach semantics on data clauses (2.6.4).</li><li><code>bounds</code>: Used when copying just slice of array or array&rsquo;s bounds are not
encoded in type. They are in rank order where rank 0 is inner-most dimension.</li><li><code>dataClause</code>: Keeps track of the data clause the user used. This is because
the acc operations are decomposed. So a &lsquo;copy&rsquo; clause is decomposed to both
<code>acc.copyin</code> and <code>acc.copyout</code> operations, but both have dataClause that
specifies <code>acc_copy</code> in this field.</li><li><code>structured</code>: Flag to note whether this is associated with structured region
(parallel, kernels, data) or unstructured (enter data, exit data). This is
important due to spec specifically calling out structured and dynamic reference
counters (2.6.7).</li><li><code>implicit</code>: Whether this is an implicitly generated operation, such as copies
done to satisfy &ldquo;Variables with Implicitly Determined Data Attributes&rdquo; in 2.6.2.</li><li><code>name</code>: Holds the name of variable as specified in user clause (including bounds).</li></ul><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-17>Attributes:&nbsp;<a class=headline-hash href=#attributes-17>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dataClause</code></td><td>::mlir::acc::DataClauseAttr</td><td><details><summary>data clauses supported by OpenACC</summary><p>Enum cases:</p><ul><li>acc_copyin (<code>acc_copyin</code>)</li><li>acc_copyin_readonly (<code>acc_copyin_readonly</code>)</li><li>acc_copy (<code>acc_copy</code>)</li><li>acc_copyout (<code>acc_copyout</code>)</li><li>acc_copyout_zero (<code>acc_copyout_zero</code>)</li><li>acc_present (<code>acc_present</code>)</li><li>acc_create (<code>acc_create</code>)</li><li>acc_create_zero (<code>acc_create_zero</code>)</li><li>acc_delete (<code>acc_delete</code>)</li><li>acc_attach (<code>acc_attach</code>)</li><li>acc_detach (<code>acc_detach</code>)</li><li>acc_no_create (<code>acc_no_create</code>)</li><li>acc_private (<code>acc_private</code>)</li><li>acc_firstprivate (<code>acc_firstprivate</code>)</li><li>acc_deviceptr (<code>acc_deviceptr</code>)</li><li>acc_getdeviceptr (<code>acc_getdeviceptr</code>)</li><li>acc_update_host (<code>acc_update_host</code>)</li><li>acc_update_self (<code>acc_update_self</code>)</li><li>acc_update_device (<code>acc_update_device</code>)</li><li>acc_use_device (<code>acc_use_device</code>)</li><li>acc_reduction (<code>acc_reduction</code>)</li><li>acc_declare_device_resident (<code>acc_declare_device_resident</code>)</li><li>acc_declare_link (<code>acc_declare_link</code>)</li><li>acc_cache (<code>acc_cache</code>)</li><li>acc_cache_readonly (<code>acc_cache_readonly</code>)</li></ul></details></td></tr><tr><td><code>structured</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>implicit</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-21>Operands:&nbsp;<a class=headline-hash href=#operands-21>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>varPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>varPtrPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>bounds</code></td><td>variadic of Type for representing acc data clause bounds information</td></tr></tbody></table><h4 id=results-10>Results:&nbsp;<a class=headline-hash href=#results-10>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>accPtr</code></td><td>PointerLikeType instance</td></tr></tbody></table><h3 id=accglobal_ctor-accglobalconstructorop><code>acc.global_ctor</code> (acc::GlobalConstructorOp)&nbsp;<a class=headline-hash href=#accglobal_ctor-accglobalconstructorop>¶</a></h3><p><em>Used to hold construction operations associated with globals such as declare</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `acc.global_ctor` $sym_name $region attr-dict-with-keyword
</code></pre><p>The &ldquo;acc.global_ctor&rdquo; operation is used to capture OpenACC actions to apply
on globals (such as <code>acc declare</code>) at the entry to the implicit data region.
This operation is isolated and intended to be used in a module.</p><p>Example showing <code>declare create</code> of global:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>llvm<span class=p>.</span>mlir<span class=p>.</span>global external <span class=nf>@globalvar</span><span class=p>()</span> <span class=p>:</span> <span class=k>i32</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span><span class=m>0</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  llvm<span class=p>.</span><span class=kt>return</span> <span class=nv>%0</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>acc<span class=p>.</span>global_ctor <span class=nf>@acc_constructor</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span>addressof <span class=nf>@globalvar</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr
</span></span><span class=line><span class=cl>  <span class=nv>%1</span> <span class=p>=</span> acc<span class=p>.</span>create varPtr<span class=p>(</span><span class=nv>%0</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>.</span>ptr
</span></span><span class=line><span class=cl>  acc<span class=p>.</span>declare_enter dataOperands<span class=p>(</span><span class=nv>%1</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Traits: IsolatedFromAbove</p><p>Interfaces: Symbol</p><h4 id=attributes-18>Attributes:&nbsp;<a class=headline-hash href=#attributes-18>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h3 id=accglobal_dtor-accglobaldestructorop><code>acc.global_dtor</code> (acc::GlobalDestructorOp)&nbsp;<a class=headline-hash href=#accglobal_dtor-accglobaldestructorop>¶</a></h3><p><em>Used to hold destruction operations associated with globals such as declare</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `acc.global_dtor` $sym_name $region attr-dict-with-keyword
</code></pre><p>The &ldquo;acc.global_dtor&rdquo; operation is used to capture OpenACC actions to apply
on globals (such as <code>acc declare</code>) at the exit from the implicit data
region. This operation is isolated and intended to be used in a module.</p><p>Example showing delete associated with <code>declare create</code> of global:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>llvm<span class=p>.</span>mlir<span class=p>.</span>global external <span class=nf>@globalvar</span><span class=p>()</span> <span class=p>:</span> <span class=k>i32</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span><span class=m>0</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  llvm<span class=p>.</span><span class=kt>return</span> <span class=nv>%0</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>acc<span class=p>.</span>global_dtor <span class=nf>@acc_destructor</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span>addressof <span class=nf>@globalvar</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr
</span></span><span class=line><span class=cl>  <span class=nv>%1</span> <span class=p>=</span> acc<span class=p>.</span>getdeviceptr varPtr<span class=p>(</span><span class=nv>%0</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>.</span>ptr <span class=p>{</span><span class=nl>dataClause =</span> <span class=nv>#acc</span><span class=p>&lt;</span>data_clause create<span class=p>&gt;}</span>
</span></span><span class=line><span class=cl>  acc<span class=p>.</span>declare_exit dataOperands<span class=p>(</span><span class=nv>%1</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>)</span>
</span></span><span class=line><span class=cl>  acc<span class=p>.</span>delete accPtr<span class=p>(</span><span class=nv>%1</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>)</span> <span class=p>{</span><span class=nl>dataClause =</span> <span class=nv>#acc</span><span class=p>&lt;</span>data_clause create<span class=p>&gt;}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Traits: IsolatedFromAbove</p><p>Interfaces: Symbol</p><h4 id=attributes-19>Attributes:&nbsp;<a class=headline-hash href=#attributes-19>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h3 id=acchost_data-acchostdataop><code>acc.host_data</code> (acc::HostDataOp)&nbsp;<a class=headline-hash href=#acchost_data-acchostdataop>¶</a></h3><p><em>Host_data construct</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `acc.host_data` oilist(
              `if` `(` $ifCond `)`
              | `dataOperands` `(` $dataClauseOperands `:` type($dataClauseOperands) `)`
              )
              $region attr-dict-with-keyword
</code></pre><p>The &ldquo;acc.host_data&rdquo; operation represents the OpenACC host_data construct.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> acc<span class=p>.</span>use_device varPtr<span class=p>(</span><span class=nv>%a</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>.</span>ptr
</span></span><span class=line><span class=cl>acc<span class=p>.</span>host_data dataOperands<span class=p>(</span><span class=nv>%0</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-20>Attributes:&nbsp;<a class=headline-hash href=#attributes-20>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>ifPresent</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-22>Operands:&nbsp;<a class=headline-hash href=#operands-22>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ifCond</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>dataClauseOperands</code></td><td>variadic of PointerLikeType instance</td></tr></tbody></table><h3 id=accinit-accinitop><code>acc.init</code> (acc::InitOp)&nbsp;<a class=headline-hash href=#accinit-accinitop>¶</a></h3><p><em>Init operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `acc.init` oilist(`device_num` `(` $deviceNumOperand `:` type($deviceNumOperand) `)`
              | `if` `(` $ifCond `)`
              ) attr-dict-with-keyword
</code></pre><p>The &ldquo;acc.init&rdquo; operation represents the OpenACC init executable
directive.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>acc<span class=p>.</span>init
</span></span><span class=line><span class=cl>acc<span class=p>.</span>init device_num<span class=p>(</span><span class=nv>%dev1</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span>
</span></span></code></pre></div><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-21>Attributes:&nbsp;<a class=headline-hash href=#attributes-21>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>device_types</code></td><td>::mlir::ArrayAttr</td><td>Device type attributes</td></tr></table><h4 id=operands-23>Operands:&nbsp;<a class=headline-hash href=#operands-23>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>deviceNumOperand</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>ifCond</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=acckernels-acckernelsop><code>acc.kernels</code> (acc::KernelsOp)&nbsp;<a class=headline-hash href=#acckernels-acckernelsop>¶</a></h3><p><em>Kernels construct</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `acc.kernels` oilist(
              `dataOperands` `(` $dataClauseOperands `:` type($dataClauseOperands) `)`
              | `async` `(` $async `:` type($async) `)`
              | `num_gangs` `(` $numGangs `:` type($numGangs) `)`
              | `num_workers` `(` $numWorkers `:` type($numWorkers) `)`
              | `vector_length` `(` $vectorLength `:` type($vectorLength) `)`
              | `wait` `(` $waitOperands `:` type($waitOperands) `)`
              | `self` `(` $selfCond `)`
              | `if` `(` $ifCond `)`
              )
              $region attr-dict-with-keyword
</code></pre><p>The &ldquo;acc.kernels&rdquo; operation represents a kernels construct block. It has
one region to be compiled into a sequence of kernels for execution on the
current device.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>acc<span class=p>.</span>kernels num_gangs<span class=p>(</span><span class=nv>%c10</span><span class=p>)</span> num_workers<span class=p>(</span><span class=nv>%c10</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    private<span class=p>(</span><span class=nv>%c</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>10x</span><span class=k>f32</span><span class=p>&gt;)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c>// kernels region
</span></span></span><span class=line><span class=cl><span class=c></span><span class=p>}</span>
</span></span></code></pre></div><p>Traits: AttrSizedOperandSegments, RecursiveMemoryEffects</p><h4 id=attributes-22>Attributes:&nbsp;<a class=headline-hash href=#attributes-22>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>asyncAttr</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>waitAttr</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>selfAttr</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>defaultAttr</code></td><td>::mlir::acc::ClauseDefaultValueAttr</td><td><details><summary>DefaultValue Clause</summary><p>Enum cases:</p><ul><li>present (<code>Present</code>)</li><li>none (<code>None</code>)</li></ul></details></td></tr></table><h4 id=operands-24>Operands:&nbsp;<a class=headline-hash href=#operands-24>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>async</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>waitOperands</code></td><td>variadic of integer or index</td></tr><tr><td style=text-align:center><code>numGangs</code></td><td>variadic of integer or index</td></tr><tr><td style=text-align:center><code>numWorkers</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>vectorLength</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>ifCond</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>selfCond</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>dataClauseOperands</code></td><td>variadic of PointerLikeType instance</td></tr></tbody></table><h3 id=accloop-accloopop><code>acc.loop</code> (acc::LoopOp)&nbsp;<a class=headline-hash href=#accloop-accloopop>¶</a></h3><p><em>Loop construct</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `acc.loop` oilist(
              `gang` `` custom&lt;GangClause&gt;($gangNum, type($gangNum), $gangDim, type($gangDim), $gangStatic, type($gangStatic), $hasGang)
              | `worker` `` custom&lt;WorkerClause&gt;($workerNum, type($workerNum), $hasWorker)
              | `vector` `` custom&lt;VectorClause&gt;($vectorLength, type($vectorLength), $hasVector)
              | `private` `(` custom&lt;SymOperandList&gt;(
              $privateOperands, type($privateOperands), $privatizations)
              `)`
              | `tile` `(` $tileOperands `:` type($tileOperands) `)`
              | `reduction` `(` custom&lt;SymOperandList&gt;(
              $reductionOperands, type($reductionOperands), $reductionRecipes)
              `)`
              | `cache` `(` $cacheOperands `:` type($cacheOperands) `)`
              )
              $region
              ( `(` type($results)^ `)` )?
              attr-dict-with-keyword
</code></pre><p>The &ldquo;acc.loop&rdquo; operation represents the OpenACC loop construct.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>acc<span class=p>.</span>loop gang <span class=kt>vector</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  scf<span class=p>.</span>for <span class=nv>%arg3</span> <span class=p>=</span> <span class=nv>%c0</span> to <span class=nv>%c10</span> step <span class=nv>%c1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    scf<span class=p>.</span>for <span class=nv>%arg4</span> <span class=p>=</span> <span class=nv>%c0</span> to <span class=nv>%c10</span> step <span class=nv>%c1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      scf<span class=p>.</span>for <span class=nv>%arg5</span> <span class=p>=</span> <span class=nv>%c0</span> to <span class=nv>%c10</span> step <span class=nv>%c1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c>// ... body
</span></span></span><span class=line><span class=cl><span class=c></span>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  acc<span class=p>.</span>yield
</span></span><span class=line><span class=cl><span class=p>}</span> attributes <span class=p>{</span> <span class=nl>collapse =</span> <span class=m>3</span> <span class=p>}</span>
</span></span></code></pre></div><p>Traits: AttrSizedOperandSegments, RecursiveMemoryEffects</p><h4 id=attributes-23>Attributes:&nbsp;<a class=headline-hash href=#attributes-23>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>collapse</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr><tr><td><code>seq</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>independent</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>auto_</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>hasGang</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>hasWorker</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>hasVector</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>privatizations</code></td><td>::mlir::ArrayAttr</td><td>symbol ref array attribute</td></tr><tr><td><code>reductionRecipes</code></td><td>::mlir::ArrayAttr</td><td>symbol ref array attribute</td></tr></table><h4 id=operands-25>Operands:&nbsp;<a class=headline-hash href=#operands-25>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>gangNum</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>gangDim</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>gangStatic</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>workerNum</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>vectorLength</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>tileOperands</code></td><td>variadic of integer or index</td></tr><tr><td style=text-align:center><code>cacheOperands</code></td><td>variadic of PointerLikeType instance</td></tr><tr><td style=text-align:center><code>privateOperands</code></td><td>variadic of PointerLikeType instance</td></tr><tr><td style=text-align:center><code>reductionOperands</code></td><td>variadic of any type</td></tr></tbody></table><h4 id=results-11>Results:&nbsp;<a class=headline-hash href=#results-11>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>results</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=accnocreate-accnocreateop><code>acc.nocreate</code> (acc::NoCreateOp)&nbsp;<a class=headline-hash href=#accnocreate-accnocreateop>¶</a></h3><p><em>Represents acc no_create semantics.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `acc.nocreate` `varPtr` `(` $varPtr `:` type($varPtr) `)`
              oilist(
              `varPtrPtr` `(` $varPtrPtr `:` type($varPtrPtr) `)`
              | `bounds` `(` $bounds `)`
              ) `-&gt;` type($accPtr) attr-dict
</code></pre><p>Description of arguments:</p><ul><li><code>varPtr</code>: The address of variable to copy.</li><li><code>varPtrPtr</code>: Specifies the address of varPtr - only used when the variable
copied is a field in a struct. This is important for OpenACC due to implicit
attach semantics on data clauses (2.6.4).</li><li><code>bounds</code>: Used when copying just slice of array or array&rsquo;s bounds are not
encoded in type. They are in rank order where rank 0 is inner-most dimension.</li><li><code>dataClause</code>: Keeps track of the data clause the user used. This is because
the acc operations are decomposed. So a &lsquo;copy&rsquo; clause is decomposed to both
<code>acc.copyin</code> and <code>acc.copyout</code> operations, but both have dataClause that
specifies <code>acc_copy</code> in this field.</li><li><code>structured</code>: Flag to note whether this is associated with structured region
(parallel, kernels, data) or unstructured (enter data, exit data). This is
important due to spec specifically calling out structured and dynamic reference
counters (2.6.7).</li><li><code>implicit</code>: Whether this is an implicitly generated operation, such as copies
done to satisfy &ldquo;Variables with Implicitly Determined Data Attributes&rdquo; in 2.6.2.</li><li><code>name</code>: Holds the name of variable as specified in user clause (including bounds).</li></ul><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-24>Attributes:&nbsp;<a class=headline-hash href=#attributes-24>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dataClause</code></td><td>::mlir::acc::DataClauseAttr</td><td><details><summary>data clauses supported by OpenACC</summary><p>Enum cases:</p><ul><li>acc_copyin (<code>acc_copyin</code>)</li><li>acc_copyin_readonly (<code>acc_copyin_readonly</code>)</li><li>acc_copy (<code>acc_copy</code>)</li><li>acc_copyout (<code>acc_copyout</code>)</li><li>acc_copyout_zero (<code>acc_copyout_zero</code>)</li><li>acc_present (<code>acc_present</code>)</li><li>acc_create (<code>acc_create</code>)</li><li>acc_create_zero (<code>acc_create_zero</code>)</li><li>acc_delete (<code>acc_delete</code>)</li><li>acc_attach (<code>acc_attach</code>)</li><li>acc_detach (<code>acc_detach</code>)</li><li>acc_no_create (<code>acc_no_create</code>)</li><li>acc_private (<code>acc_private</code>)</li><li>acc_firstprivate (<code>acc_firstprivate</code>)</li><li>acc_deviceptr (<code>acc_deviceptr</code>)</li><li>acc_getdeviceptr (<code>acc_getdeviceptr</code>)</li><li>acc_update_host (<code>acc_update_host</code>)</li><li>acc_update_self (<code>acc_update_self</code>)</li><li>acc_update_device (<code>acc_update_device</code>)</li><li>acc_use_device (<code>acc_use_device</code>)</li><li>acc_reduction (<code>acc_reduction</code>)</li><li>acc_declare_device_resident (<code>acc_declare_device_resident</code>)</li><li>acc_declare_link (<code>acc_declare_link</code>)</li><li>acc_cache (<code>acc_cache</code>)</li><li>acc_cache_readonly (<code>acc_cache_readonly</code>)</li></ul></details></td></tr><tr><td><code>structured</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>implicit</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-26>Operands:&nbsp;<a class=headline-hash href=#operands-26>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>varPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>varPtrPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>bounds</code></td><td>variadic of Type for representing acc data clause bounds information</td></tr></tbody></table><h4 id=results-12>Results:&nbsp;<a class=headline-hash href=#results-12>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>accPtr</code></td><td>PointerLikeType instance</td></tr></tbody></table><h3 id=accparallel-accparallelop><code>acc.parallel</code> (acc::ParallelOp)&nbsp;<a class=headline-hash href=#accparallel-accparallelop>¶</a></h3><p><em>Parallel construct</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `acc.parallel` oilist(
              `dataOperands` `(` $dataClauseOperands `:` type($dataClauseOperands) `)`
              | `async` `(` $async `:` type($async) `)`
              | `firstprivate` `(` custom&lt;SymOperandList&gt;($gangFirstPrivateOperands,
              type($gangFirstPrivateOperands), $firstprivatizations)
              `)`
              | `num_gangs` `(` $numGangs `:` type($numGangs) `)`
              | `num_workers` `(` $numWorkers `:` type($numWorkers) `)`
              | `private` `(` custom&lt;SymOperandList&gt;(
              $gangPrivateOperands, type($gangPrivateOperands), $privatizations)
              `)`
              | `vector_length` `(` $vectorLength `:` type($vectorLength) `)`
              | `wait` `(` $waitOperands `:` type($waitOperands) `)`
              | `self` `(` $selfCond `)`
              | `if` `(` $ifCond `)`
              | `reduction` `(` custom&lt;SymOperandList&gt;(
              $reductionOperands, type($reductionOperands), $reductionRecipes)
              `)`
              )
              $region attr-dict-with-keyword
</code></pre><p>The &ldquo;acc.parallel&rdquo; operation represents a parallel construct block. It has
one region to be executed in parallel on the current device.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>acc<span class=p>.</span>parallel num_gangs<span class=p>(</span><span class=nv>%c10</span><span class=p>)</span> num_workers<span class=p>(</span><span class=nv>%c10</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    private<span class=p>(</span><span class=nv>%c</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>10x</span><span class=k>f32</span><span class=p>&gt;)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c>// parallel region
</span></span></span><span class=line><span class=cl><span class=c></span><span class=p>}</span>
</span></span></code></pre></div><p>Traits: AttrSizedOperandSegments, RecursiveMemoryEffects</p><h4 id=attributes-25>Attributes:&nbsp;<a class=headline-hash href=#attributes-25>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>asyncAttr</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>waitAttr</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>selfAttr</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>reductionRecipes</code></td><td>::mlir::ArrayAttr</td><td>symbol ref array attribute</td></tr><tr><td><code>privatizations</code></td><td>::mlir::ArrayAttr</td><td>symbol ref array attribute</td></tr><tr><td><code>firstprivatizations</code></td><td>::mlir::ArrayAttr</td><td>symbol ref array attribute</td></tr><tr><td><code>defaultAttr</code></td><td>::mlir::acc::ClauseDefaultValueAttr</td><td><details><summary>DefaultValue Clause</summary><p>Enum cases:</p><ul><li>present (<code>Present</code>)</li><li>none (<code>None</code>)</li></ul></details></td></tr></table><h4 id=operands-27>Operands:&nbsp;<a class=headline-hash href=#operands-27>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>async</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>waitOperands</code></td><td>variadic of integer or index</td></tr><tr><td style=text-align:center><code>numGangs</code></td><td>variadic of integer or index</td></tr><tr><td style=text-align:center><code>numWorkers</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>vectorLength</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>ifCond</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>selfCond</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>reductionOperands</code></td><td>variadic of any type</td></tr><tr><td style=text-align:center><code>gangPrivateOperands</code></td><td>variadic of PointerLikeType instance</td></tr><tr><td style=text-align:center><code>gangFirstPrivateOperands</code></td><td>variadic of PointerLikeType instance</td></tr><tr><td style=text-align:center><code>dataClauseOperands</code></td><td>variadic of PointerLikeType instance</td></tr></tbody></table><h3 id=accpresent-accpresentop><code>acc.present</code> (acc::PresentOp)&nbsp;<a class=headline-hash href=#accpresent-accpresentop>¶</a></h3><p><em>Specifies that the variable is already present on device.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `acc.present` `varPtr` `(` $varPtr `:` type($varPtr) `)`
              oilist(
              `varPtrPtr` `(` $varPtrPtr `:` type($varPtrPtr) `)`
              | `bounds` `(` $bounds `)`
              ) `-&gt;` type($accPtr) attr-dict
</code></pre><p>Description of arguments:</p><ul><li><code>varPtr</code>: The address of variable to copy.</li><li><code>varPtrPtr</code>: Specifies the address of varPtr - only used when the variable
copied is a field in a struct. This is important for OpenACC due to implicit
attach semantics on data clauses (2.6.4).</li><li><code>bounds</code>: Used when copying just slice of array or array&rsquo;s bounds are not
encoded in type. They are in rank order where rank 0 is inner-most dimension.</li><li><code>dataClause</code>: Keeps track of the data clause the user used. This is because
the acc operations are decomposed. So a &lsquo;copy&rsquo; clause is decomposed to both
<code>acc.copyin</code> and <code>acc.copyout</code> operations, but both have dataClause that
specifies <code>acc_copy</code> in this field.</li><li><code>structured</code>: Flag to note whether this is associated with structured region
(parallel, kernels, data) or unstructured (enter data, exit data). This is
important due to spec specifically calling out structured and dynamic reference
counters (2.6.7).</li><li><code>implicit</code>: Whether this is an implicitly generated operation, such as copies
done to satisfy &ldquo;Variables with Implicitly Determined Data Attributes&rdquo; in 2.6.2.</li><li><code>name</code>: Holds the name of variable as specified in user clause (including bounds).</li></ul><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-26>Attributes:&nbsp;<a class=headline-hash href=#attributes-26>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dataClause</code></td><td>::mlir::acc::DataClauseAttr</td><td><details><summary>data clauses supported by OpenACC</summary><p>Enum cases:</p><ul><li>acc_copyin (<code>acc_copyin</code>)</li><li>acc_copyin_readonly (<code>acc_copyin_readonly</code>)</li><li>acc_copy (<code>acc_copy</code>)</li><li>acc_copyout (<code>acc_copyout</code>)</li><li>acc_copyout_zero (<code>acc_copyout_zero</code>)</li><li>acc_present (<code>acc_present</code>)</li><li>acc_create (<code>acc_create</code>)</li><li>acc_create_zero (<code>acc_create_zero</code>)</li><li>acc_delete (<code>acc_delete</code>)</li><li>acc_attach (<code>acc_attach</code>)</li><li>acc_detach (<code>acc_detach</code>)</li><li>acc_no_create (<code>acc_no_create</code>)</li><li>acc_private (<code>acc_private</code>)</li><li>acc_firstprivate (<code>acc_firstprivate</code>)</li><li>acc_deviceptr (<code>acc_deviceptr</code>)</li><li>acc_getdeviceptr (<code>acc_getdeviceptr</code>)</li><li>acc_update_host (<code>acc_update_host</code>)</li><li>acc_update_self (<code>acc_update_self</code>)</li><li>acc_update_device (<code>acc_update_device</code>)</li><li>acc_use_device (<code>acc_use_device</code>)</li><li>acc_reduction (<code>acc_reduction</code>)</li><li>acc_declare_device_resident (<code>acc_declare_device_resident</code>)</li><li>acc_declare_link (<code>acc_declare_link</code>)</li><li>acc_cache (<code>acc_cache</code>)</li><li>acc_cache_readonly (<code>acc_cache_readonly</code>)</li></ul></details></td></tr><tr><td><code>structured</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>implicit</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-28>Operands:&nbsp;<a class=headline-hash href=#operands-28>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>varPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>varPtrPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>bounds</code></td><td>variadic of Type for representing acc data clause bounds information</td></tr></tbody></table><h4 id=results-13>Results:&nbsp;<a class=headline-hash href=#results-13>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>accPtr</code></td><td>PointerLikeType instance</td></tr></tbody></table><h3 id=accprivate-accprivateop><code>acc.private</code> (acc::PrivateOp)&nbsp;<a class=headline-hash href=#accprivate-accprivateop>¶</a></h3><p><em>Represents private semantics for acc private clause.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `acc.private` `varPtr` `(` $varPtr `:` type($varPtr) `)`
              oilist(
              `varPtrPtr` `(` $varPtrPtr `:` type($varPtrPtr) `)`
              | `bounds` `(` $bounds `)`
              ) `-&gt;` type($accPtr) attr-dict
</code></pre><p>Description of arguments:</p><ul><li><code>varPtr</code>: The address of variable to copy.</li><li><code>varPtrPtr</code>: Specifies the address of varPtr - only used when the variable
copied is a field in a struct. This is important for OpenACC due to implicit
attach semantics on data clauses (2.6.4).</li><li><code>bounds</code>: Used when copying just slice of array or array&rsquo;s bounds are not
encoded in type. They are in rank order where rank 0 is inner-most dimension.</li><li><code>dataClause</code>: Keeps track of the data clause the user used. This is because
the acc operations are decomposed. So a &lsquo;copy&rsquo; clause is decomposed to both
<code>acc.copyin</code> and <code>acc.copyout</code> operations, but both have dataClause that
specifies <code>acc_copy</code> in this field.</li><li><code>structured</code>: Flag to note whether this is associated with structured region
(parallel, kernels, data) or unstructured (enter data, exit data). This is
important due to spec specifically calling out structured and dynamic reference
counters (2.6.7).</li><li><code>implicit</code>: Whether this is an implicitly generated operation, such as copies
done to satisfy &ldquo;Variables with Implicitly Determined Data Attributes&rdquo; in 2.6.2.</li><li><code>name</code>: Holds the name of variable as specified in user clause (including bounds).</li></ul><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-27>Attributes:&nbsp;<a class=headline-hash href=#attributes-27>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dataClause</code></td><td>::mlir::acc::DataClauseAttr</td><td><details><summary>data clauses supported by OpenACC</summary><p>Enum cases:</p><ul><li>acc_copyin (<code>acc_copyin</code>)</li><li>acc_copyin_readonly (<code>acc_copyin_readonly</code>)</li><li>acc_copy (<code>acc_copy</code>)</li><li>acc_copyout (<code>acc_copyout</code>)</li><li>acc_copyout_zero (<code>acc_copyout_zero</code>)</li><li>acc_present (<code>acc_present</code>)</li><li>acc_create (<code>acc_create</code>)</li><li>acc_create_zero (<code>acc_create_zero</code>)</li><li>acc_delete (<code>acc_delete</code>)</li><li>acc_attach (<code>acc_attach</code>)</li><li>acc_detach (<code>acc_detach</code>)</li><li>acc_no_create (<code>acc_no_create</code>)</li><li>acc_private (<code>acc_private</code>)</li><li>acc_firstprivate (<code>acc_firstprivate</code>)</li><li>acc_deviceptr (<code>acc_deviceptr</code>)</li><li>acc_getdeviceptr (<code>acc_getdeviceptr</code>)</li><li>acc_update_host (<code>acc_update_host</code>)</li><li>acc_update_self (<code>acc_update_self</code>)</li><li>acc_update_device (<code>acc_update_device</code>)</li><li>acc_use_device (<code>acc_use_device</code>)</li><li>acc_reduction (<code>acc_reduction</code>)</li><li>acc_declare_device_resident (<code>acc_declare_device_resident</code>)</li><li>acc_declare_link (<code>acc_declare_link</code>)</li><li>acc_cache (<code>acc_cache</code>)</li><li>acc_cache_readonly (<code>acc_cache_readonly</code>)</li></ul></details></td></tr><tr><td><code>structured</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>implicit</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-29>Operands:&nbsp;<a class=headline-hash href=#operands-29>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>varPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>varPtrPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>bounds</code></td><td>variadic of Type for representing acc data clause bounds information</td></tr></tbody></table><h4 id=results-14>Results:&nbsp;<a class=headline-hash href=#results-14>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>accPtr</code></td><td>PointerLikeType instance</td></tr></tbody></table><h3 id=accprivaterecipe-accprivaterecipeop><code>acc.private.recipe</code> (acc::PrivateRecipeOp)&nbsp;<a class=headline-hash href=#accprivaterecipe-accprivaterecipeop>¶</a></h3><p><em>Privatization recipe</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `acc.private.recipe` $sym_name `:` $type attr-dict-with-keyword `init` $initRegion
              (`destroy` $destroyRegion^)?
</code></pre><p>Declares an OpenACC privatization recipe. The operation requires one
mandatory and one optional region.</p><ol><li>The initializer region specifies how to allocate and initialize a new
private value. For example in Fortran, a derived-type might have a
default initialization. The region has an argument that contains the
value that need to be privatized. This is useful if the type is not
known at compile time and the private value is needed to create its
copy.</li><li>The destroy region specifies how to destruct the value when it reaches
its end of life. It takes the privatized value as argument.</li></ol><p>A single privatization recipe can be used for multiple operand if they have
the same type and do not require a specific default initialization.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>acc<span class=p>.</span>private<span class=p>.</span>recipe <span class=nf>@privatization_f32</span> <span class=p>:</span> <span class=k>f32</span> init <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=nl>^bb0</span><span class=p>(</span><span class=nv>%0</span><span class=p>:</span> <span class=k>f32</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=c>// init region contains a sequence of operations to create and
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>// initialize the copy if needed. It yields the create copy.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=p>}</span> destroy <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=nl>^bb0</span><span class=p>(</span><span class=nv>%0</span><span class=p>:</span> <span class=k>f32</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=c>// destroy region contains a sequences of operations to destruct the
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>// created copy.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// The privatization symbol is then used in the corresponding operation.
</span></span></span><span class=line><span class=cl><span class=c></span>acc<span class=p>.</span>parallel private<span class=p>(</span><span class=nf>@privatization_f32</span> <span class=p>-&gt;</span> <span class=nv>%a</span> <span class=p>:</span> <span class=k>f32</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Traits: IsolatedFromAbove</p><p>Interfaces: RecipeInterface, Symbol</p><h4 id=attributes-28>Attributes:&nbsp;<a class=headline-hash href=#attributes-28>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>type</code></td><td>::mlir::TypeAttr</td><td>any type attribute</td></tr></table><h3 id=accreduction-accreductionop><code>acc.reduction</code> (acc::ReductionOp)&nbsp;<a class=headline-hash href=#accreduction-accreductionop>¶</a></h3><p><em>Represents reduction semantics for acc reduction clause.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `acc.reduction` `varPtr` `(` $varPtr `:` type($varPtr) `)`
              oilist(
              `varPtrPtr` `(` $varPtrPtr `:` type($varPtrPtr) `)`
              | `bounds` `(` $bounds `)`
              ) `-&gt;` type($accPtr) attr-dict
</code></pre><p>Description of arguments:</p><ul><li><code>varPtr</code>: The address of variable to copy.</li><li><code>varPtrPtr</code>: Specifies the address of varPtr - only used when the variable
copied is a field in a struct. This is important for OpenACC due to implicit
attach semantics on data clauses (2.6.4).</li><li><code>bounds</code>: Used when copying just slice of array or array&rsquo;s bounds are not
encoded in type. They are in rank order where rank 0 is inner-most dimension.</li><li><code>dataClause</code>: Keeps track of the data clause the user used. This is because
the acc operations are decomposed. So a &lsquo;copy&rsquo; clause is decomposed to both
<code>acc.copyin</code> and <code>acc.copyout</code> operations, but both have dataClause that
specifies <code>acc_copy</code> in this field.</li><li><code>structured</code>: Flag to note whether this is associated with structured region
(parallel, kernels, data) or unstructured (enter data, exit data). This is
important due to spec specifically calling out structured and dynamic reference
counters (2.6.7).</li><li><code>implicit</code>: Whether this is an implicitly generated operation, such as copies
done to satisfy &ldquo;Variables with Implicitly Determined Data Attributes&rdquo; in 2.6.2.</li><li><code>name</code>: Holds the name of variable as specified in user clause (including bounds).</li></ul><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-29>Attributes:&nbsp;<a class=headline-hash href=#attributes-29>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dataClause</code></td><td>::mlir::acc::DataClauseAttr</td><td><details><summary>data clauses supported by OpenACC</summary><p>Enum cases:</p><ul><li>acc_copyin (<code>acc_copyin</code>)</li><li>acc_copyin_readonly (<code>acc_copyin_readonly</code>)</li><li>acc_copy (<code>acc_copy</code>)</li><li>acc_copyout (<code>acc_copyout</code>)</li><li>acc_copyout_zero (<code>acc_copyout_zero</code>)</li><li>acc_present (<code>acc_present</code>)</li><li>acc_create (<code>acc_create</code>)</li><li>acc_create_zero (<code>acc_create_zero</code>)</li><li>acc_delete (<code>acc_delete</code>)</li><li>acc_attach (<code>acc_attach</code>)</li><li>acc_detach (<code>acc_detach</code>)</li><li>acc_no_create (<code>acc_no_create</code>)</li><li>acc_private (<code>acc_private</code>)</li><li>acc_firstprivate (<code>acc_firstprivate</code>)</li><li>acc_deviceptr (<code>acc_deviceptr</code>)</li><li>acc_getdeviceptr (<code>acc_getdeviceptr</code>)</li><li>acc_update_host (<code>acc_update_host</code>)</li><li>acc_update_self (<code>acc_update_self</code>)</li><li>acc_update_device (<code>acc_update_device</code>)</li><li>acc_use_device (<code>acc_use_device</code>)</li><li>acc_reduction (<code>acc_reduction</code>)</li><li>acc_declare_device_resident (<code>acc_declare_device_resident</code>)</li><li>acc_declare_link (<code>acc_declare_link</code>)</li><li>acc_cache (<code>acc_cache</code>)</li><li>acc_cache_readonly (<code>acc_cache_readonly</code>)</li></ul></details></td></tr><tr><td><code>structured</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>implicit</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-30>Operands:&nbsp;<a class=headline-hash href=#operands-30>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>varPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>varPtrPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>bounds</code></td><td>variadic of Type for representing acc data clause bounds information</td></tr></tbody></table><h4 id=results-15>Results:&nbsp;<a class=headline-hash href=#results-15>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>accPtr</code></td><td>PointerLikeType instance</td></tr></tbody></table><h3 id=accreductionrecipe-accreductionrecipeop><code>acc.reduction.recipe</code> (acc::ReductionRecipeOp)&nbsp;<a class=headline-hash href=#accreductionrecipe-accreductionrecipeop>¶</a></h3><p><em>Reduction recipe</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `acc.reduction.recipe` $sym_name `:` $type attr-dict-with-keyword
              `reduction_operator` $reductionOperator
              `init` $initRegion `combiner` $combinerRegion
</code></pre><p>Declares an OpenACC reduction recipe. The operation requires two
mandatory regions.</p><ol><li>The initializer region specifies how to initialize the local reduction
value. The region has a first argument that contains the value of the
reduction accumulator at the start of the reduction. It is expected to
<code>acc.yield</code> the new value. Extra arguments can be added to deal with
dynamic arrays.</li><li>The reduction region contains a sequences of operations to combine two
values of the reduction type into one. It has at least two arguments
and it is expected to <code>acc.yield</code> the combined value. Extra arguments
can be added to deal with dynamic arrays.</li></ol><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>acc<span class=p>.</span>reduction<span class=p>.</span>recipe <span class=nf>@reduction_add_i64</span> <span class=p>:</span> <span class=k>i64</span> reduction_operator<span class=p>&lt;</span>add<span class=p>&gt;</span> init <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=nl>^bb0</span><span class=p>(</span><span class=nv>%0</span><span class=p>:</span> <span class=k>i64</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=c>// init region contains a sequence of operations to initialize the local
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>// reduction value as specified in 2.5.15
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=nv>%c0</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>0</span> <span class=p>:</span> <span class=k>i64</span>
</span></span><span class=line><span class=cl>  acc<span class=p>.</span>yield <span class=nv>%c0</span> <span class=p>:</span> <span class=k>i64</span>
</span></span><span class=line><span class=cl><span class=p>}</span> combiner <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=nl>^bb0</span><span class=p>(</span><span class=nv>%0</span><span class=p>:</span> <span class=k>i64</span><span class=p>,</span> <span class=nv>%1</span><span class=p>:</span> <span class=k>i64</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=c>// combiner region contains a sequence of operations to combine
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>// two values into one.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=nv>%2</span> <span class=p>=</span> arith<span class=p>.</span>addi <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>i64</span>
</span></span><span class=line><span class=cl>  acc<span class=p>.</span>yield <span class=nv>%2</span> <span class=p>:</span> <span class=k>i64</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// The reduction symbol is then used in the corresponding operation.
</span></span></span><span class=line><span class=cl><span class=c></span>acc<span class=p>.</span>parallel reduction<span class=p>(</span><span class=nf>@reduction_add_i64</span> <span class=p>-&gt;</span> <span class=nv>%a</span> <span class=p>:</span> <span class=k>i64</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The following table lists the valid operators and the initialization values
according to OpenACC 3.3:</p><p>|&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;|</p><table><thead><tr><th>C/C++</th><th>Fortran</th></tr></thead><tbody><tr><td>operator</td><td>init value</td></tr><tr><td>+</td><td>0</td></tr><tr><td>*</td><td>1</td></tr><tr><td>max</td><td>least</td></tr><tr><td>min</td><td>largest</td></tr><tr><td>&</td><td>~0</td></tr><tr><td></td><td></td></tr><tr><td>^</td><td>0</td></tr><tr><td>&&</td><td>1</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</td><td></td></tr></tbody></table><p>Traits: IsolatedFromAbove</p><p>Interfaces: RecipeInterface, Symbol</p><h4 id=attributes-30>Attributes:&nbsp;<a class=headline-hash href=#attributes-30>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>type</code></td><td>::mlir::TypeAttr</td><td>any type attribute</td></tr><tr><td><code>reductionOperator</code></td><td>::mlir::acc::ReductionOperatorAttr</td><td><details><summary>built-in reduction operations supported by OpenACC</summary><p>Enum cases:</p><ul><li>add (<code>AccAdd</code>)</li><li>mul (<code>AccMul</code>)</li><li>max (<code>AccMax</code>)</li><li>min (<code>AccMin</code>)</li><li>iand (<code>AccIand</code>)</li><li>ior (<code>AccIor</code>)</li><li>xor (<code>AccXor</code>)</li><li>eqv (<code>AccEqv</code>)</li><li>neqv (<code>AccNeqv</code>)</li><li>land (<code>AccLand</code>)</li><li>lor (<code>AccLor</code>)</li></ul></details></td></tr></table><h3 id=accroutine-accroutineop><code>acc.routine</code> (acc::RoutineOp)&nbsp;<a class=headline-hash href=#accroutine-accroutineop>¶</a></h3><p><em>Acc routine operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `acc.routine` $sym_name `func` `(` $func_name `)`
              oilist (
              `bind` `(` $bind_name `)`
              | `gang` `` custom&lt;RoutineGangClause&gt;($gang, $gangDim)
              | `worker` $worker
              | `vector` $vector
              | `seq` $seq
              | `nohost` $nohost
              | `implicit` $implicit
              ) attr-dict-with-keyword
</code></pre><p>The <code>acc.routine</code> operation is used to capture the clauses of acc
routine directive, including the associated function name. The associated
function keeps track of its corresponding routine declaration through
the <code>RoutineInfoAttr</code>.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=kt>func</span><span class=p>.</span><span class=kt>func</span> <span class=nf>@acc_func</span><span class=p>(</span><span class=nv>%a</span> <span class=p>:</span> <span class=k>i64</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span> attributes <span class=p>{</span><span class=nl>acc.routine_info =</span> <span class=nv>#acc.routine_info</span><span class=p>&lt;[</span><span class=nf>@acc_func_rout1</span><span class=p>]&gt;}</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>return</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>acc<span class=p>.</span>routine <span class=nf>@acc_func_rout1</span> <span class=kt>func</span><span class=p>(</span><span class=nf>@acc_func</span><span class=p>)</span> gang
</span></span></code></pre></div><p>Traits: IsolatedFromAbove</p><h4 id=attributes-31>Attributes:&nbsp;<a class=headline-hash href=#attributes-31>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>func_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>bind_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>gang</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>worker</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>vector</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>seq</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>nohost</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>implicit</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>gangDim</code></td><td>::mlir::IntegerAttr</td><td>arbitrary integer attribute</td></tr></table><h3 id=accserial-accserialop><code>acc.serial</code> (acc::SerialOp)&nbsp;<a class=headline-hash href=#accserial-accserialop>¶</a></h3><p><em>Serial construct</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `acc.serial` oilist(
              `dataOperands` `(` $dataClauseOperands `:` type($dataClauseOperands) `)`
              | `async` `(` $async `:` type($async) `)`
              | `firstprivate` `(` custom&lt;SymOperandList&gt;($gangFirstPrivateOperands,
              type($gangFirstPrivateOperands), $firstprivatizations)
              `)`
              | `private` `(` custom&lt;SymOperandList&gt;(
              $gangPrivateOperands, type($gangPrivateOperands), $privatizations)
              `)`
              | `wait` `(` $waitOperands `:` type($waitOperands) `)`
              | `self` `(` $selfCond `)`
              | `if` `(` $ifCond `)`
              | `reduction` `(` custom&lt;SymOperandList&gt;(
              $reductionOperands, type($reductionOperands), $reductionRecipes)
              `)`
              )
              $region attr-dict-with-keyword
</code></pre><p>The &ldquo;acc.serial&rdquo; operation represents a serial construct block. It has
one region to be executed in serial on the current device.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>acc<span class=p>.</span>serial private<span class=p>(</span><span class=nv>%c</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>10x</span><span class=k>f32</span><span class=p>&gt;)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c>// serial region
</span></span></span><span class=line><span class=cl><span class=c></span><span class=p>}</span>
</span></span></code></pre></div><p>Traits: AttrSizedOperandSegments, RecursiveMemoryEffects</p><h4 id=attributes-32>Attributes:&nbsp;<a class=headline-hash href=#attributes-32>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>asyncAttr</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>waitAttr</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>selfAttr</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>reductionRecipes</code></td><td>::mlir::ArrayAttr</td><td>symbol ref array attribute</td></tr><tr><td><code>privatizations</code></td><td>::mlir::ArrayAttr</td><td>symbol ref array attribute</td></tr><tr><td><code>firstprivatizations</code></td><td>::mlir::ArrayAttr</td><td>symbol ref array attribute</td></tr><tr><td><code>defaultAttr</code></td><td>::mlir::acc::ClauseDefaultValueAttr</td><td><details><summary>DefaultValue Clause</summary><p>Enum cases:</p><ul><li>present (<code>Present</code>)</li><li>none (<code>None</code>)</li></ul></details></td></tr></table><h4 id=operands-31>Operands:&nbsp;<a class=headline-hash href=#operands-31>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>async</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>waitOperands</code></td><td>variadic of integer or index</td></tr><tr><td style=text-align:center><code>ifCond</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>selfCond</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>reductionOperands</code></td><td>variadic of any type</td></tr><tr><td style=text-align:center><code>gangPrivateOperands</code></td><td>variadic of PointerLikeType instance</td></tr><tr><td style=text-align:center><code>gangFirstPrivateOperands</code></td><td>variadic of PointerLikeType instance</td></tr><tr><td style=text-align:center><code>dataClauseOperands</code></td><td>variadic of PointerLikeType instance</td></tr></tbody></table><h3 id=accset-accsetop><code>acc.set</code> (acc::SetOp)&nbsp;<a class=headline-hash href=#accset-accsetop>¶</a></h3><p><em>Set operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `acc.set` oilist(`default_async` `(` $defaultAsync `:` type($defaultAsync) `)`
              | `device_num` `(` $deviceNum `:` type($deviceNum) `)`
              | `if` `(` $ifCond `)`
              ) attr-dict-with-keyword
</code></pre><p>The &ldquo;acc.set&rdquo; operation represents the OpenACC set directive.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>acc<span class=p>.</span>set device_num<span class=p>(</span><span class=nv>%dev1</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span>
</span></span></code></pre></div><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-33>Attributes:&nbsp;<a class=headline-hash href=#attributes-33>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>device_type</code></td><td>::mlir::acc::DeviceTypeAttr</td><td><details><summary>built-in device type supported by OpenACC</summary><p>Enum cases:</p><ul><li>star (<code>Star</code>)</li><li>default (<code>Default</code>)</li><li>host (<code>Host</code>)</li><li>multicore (<code>Multicore</code>)</li><li>nvidia (<code>Nvidia</code>)</li><li>radeon (<code>Radeon</code>)</li></ul></details></td></tr></table><h4 id=operands-32>Operands:&nbsp;<a class=headline-hash href=#operands-32>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>defaultAsync</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>deviceNum</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>ifCond</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=accshutdown-accshutdownop><code>acc.shutdown</code> (acc::ShutdownOp)&nbsp;<a class=headline-hash href=#accshutdown-accshutdownop>¶</a></h3><p><em>Shutdown operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `acc.shutdown` oilist(`device_num` `(` $deviceNumOperand `:` type($deviceNumOperand) `)`
              |`if` `(` $ifCond `)`
              ) attr-dict-with-keyword
</code></pre><p>The &ldquo;acc.shutdown&rdquo; operation represents the OpenACC shutdown executable
directive.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>acc<span class=p>.</span>shutdown
</span></span><span class=line><span class=cl>acc<span class=p>.</span>shutdown device_num<span class=p>(</span><span class=nv>%dev1</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span>
</span></span></code></pre></div><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-34>Attributes:&nbsp;<a class=headline-hash href=#attributes-34>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>device_types</code></td><td>::mlir::ArrayAttr</td><td>Device type attributes</td></tr></table><h4 id=operands-33>Operands:&nbsp;<a class=headline-hash href=#operands-33>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>deviceNumOperand</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>ifCond</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=accterminator-accterminatorop><code>acc.terminator</code> (acc::TerminatorOp)&nbsp;<a class=headline-hash href=#accterminator-accterminatorop>¶</a></h3><p><em>Generic terminator for OpenACC regions</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `acc.terminator` attr-dict
</code></pre><p>A terminator operation for regions that appear in the body of OpenACC
operation. Generic OpenACC construct regions are not expected to return any
value so the terminator takes no operands. The terminator op returns control
to the enclosing op.</p><p>Traits: Terminator</p><h3 id=accupdate-accupdateop><code>acc.update</code> (acc::UpdateOp)&nbsp;<a class=headline-hash href=#accupdate-accupdateop>¶</a></h3><p><em>Update operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `acc.update` oilist(
              `if` `(` $ifCond `)`
              | `async` `(` $asyncOperand `:` type($asyncOperand) `)`
              | `wait_devnum` `(` $waitDevnum `:` type($waitDevnum) `)`
              | `wait` `(` $waitOperands `:` type($waitOperands) `)`
              | `dataOperands` `(` $dataClauseOperands `:` type($dataClauseOperands) `)`
              )
              attr-dict-with-keyword
</code></pre><p>The &ldquo;acc.udpate&rdquo; operation represents the OpenACC update executable
directive.
As host and self clauses are synonyms, any operands for host and self are
add to $hostOperands.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>acc<span class=p>.</span>update device<span class=p>(</span><span class=nv>%d1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>10x</span><span class=k>f32</span><span class=p>&gt;)</span> attributes <span class=p>{</span>async<span class=p>}</span>
</span></span></code></pre></div><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-35>Attributes:&nbsp;<a class=headline-hash href=#attributes-35>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>async</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>wait</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>device_types</code></td><td>::mlir::ArrayAttr</td><td>Device type attributes</td></tr><tr><td><code>ifPresent</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-34>Operands:&nbsp;<a class=headline-hash href=#operands-34>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ifCond</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>asyncOperand</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>waitDevnum</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>waitOperands</code></td><td>variadic of integer or index</td></tr><tr><td style=text-align:center><code>dataClauseOperands</code></td><td>variadic of PointerLikeType instance</td></tr></tbody></table><h3 id=accupdate_device-accupdatedeviceop><code>acc.update_device</code> (acc::UpdateDeviceOp)&nbsp;<a class=headline-hash href=#accupdate_device-accupdatedeviceop>¶</a></h3><p><em>Represents acc update device semantics.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `acc.update_device` `varPtr` `(` $varPtr `:` type($varPtr) `)`
              oilist(
              `varPtrPtr` `(` $varPtrPtr `:` type($varPtrPtr) `)`
              | `bounds` `(` $bounds `)`
              ) `-&gt;` type($accPtr) attr-dict
</code></pre><p>Description of arguments:</p><ul><li><code>varPtr</code>: The address of variable to copy.</li><li><code>varPtrPtr</code>: Specifies the address of varPtr - only used when the variable
copied is a field in a struct. This is important for OpenACC due to implicit
attach semantics on data clauses (2.6.4).</li><li><code>bounds</code>: Used when copying just slice of array or array&rsquo;s bounds are not
encoded in type. They are in rank order where rank 0 is inner-most dimension.</li><li><code>dataClause</code>: Keeps track of the data clause the user used. This is because
the acc operations are decomposed. So a &lsquo;copy&rsquo; clause is decomposed to both
<code>acc.copyin</code> and <code>acc.copyout</code> operations, but both have dataClause that
specifies <code>acc_copy</code> in this field.</li><li><code>structured</code>: Flag to note whether this is associated with structured region
(parallel, kernels, data) or unstructured (enter data, exit data). This is
important due to spec specifically calling out structured and dynamic reference
counters (2.6.7).</li><li><code>implicit</code>: Whether this is an implicitly generated operation, such as copies
done to satisfy &ldquo;Variables with Implicitly Determined Data Attributes&rdquo; in 2.6.2.</li><li><code>name</code>: Holds the name of variable as specified in user clause (including bounds).</li></ul><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-36>Attributes:&nbsp;<a class=headline-hash href=#attributes-36>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dataClause</code></td><td>::mlir::acc::DataClauseAttr</td><td><details><summary>data clauses supported by OpenACC</summary><p>Enum cases:</p><ul><li>acc_copyin (<code>acc_copyin</code>)</li><li>acc_copyin_readonly (<code>acc_copyin_readonly</code>)</li><li>acc_copy (<code>acc_copy</code>)</li><li>acc_copyout (<code>acc_copyout</code>)</li><li>acc_copyout_zero (<code>acc_copyout_zero</code>)</li><li>acc_present (<code>acc_present</code>)</li><li>acc_create (<code>acc_create</code>)</li><li>acc_create_zero (<code>acc_create_zero</code>)</li><li>acc_delete (<code>acc_delete</code>)</li><li>acc_attach (<code>acc_attach</code>)</li><li>acc_detach (<code>acc_detach</code>)</li><li>acc_no_create (<code>acc_no_create</code>)</li><li>acc_private (<code>acc_private</code>)</li><li>acc_firstprivate (<code>acc_firstprivate</code>)</li><li>acc_deviceptr (<code>acc_deviceptr</code>)</li><li>acc_getdeviceptr (<code>acc_getdeviceptr</code>)</li><li>acc_update_host (<code>acc_update_host</code>)</li><li>acc_update_self (<code>acc_update_self</code>)</li><li>acc_update_device (<code>acc_update_device</code>)</li><li>acc_use_device (<code>acc_use_device</code>)</li><li>acc_reduction (<code>acc_reduction</code>)</li><li>acc_declare_device_resident (<code>acc_declare_device_resident</code>)</li><li>acc_declare_link (<code>acc_declare_link</code>)</li><li>acc_cache (<code>acc_cache</code>)</li><li>acc_cache_readonly (<code>acc_cache_readonly</code>)</li></ul></details></td></tr><tr><td><code>structured</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>implicit</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-35>Operands:&nbsp;<a class=headline-hash href=#operands-35>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>varPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>varPtrPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>bounds</code></td><td>variadic of Type for representing acc data clause bounds information</td></tr></tbody></table><h4 id=results-16>Results:&nbsp;<a class=headline-hash href=#results-16>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>accPtr</code></td><td>PointerLikeType instance</td></tr></tbody></table><h3 id=accupdate_host-accupdatehostop><code>acc.update_host</code> (acc::UpdateHostOp)&nbsp;<a class=headline-hash href=#accupdate_host-accupdatehostop>¶</a></h3><p><em>Represents acc update host semantics.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `acc.update_host` `accPtr` `(` $accPtr `:` type($accPtr) `)`
              oilist(
              `bounds` `(` $bounds `)`
              | `to` `varPtr` `(` $varPtr `:` type($varPtr) `)`
              ) attr-dict
</code></pre><ul><li><code>varPtr</code>: The address of variable to copy back to. This only applies to
<code>acc.copyout</code></li><li><code>accPtr</code>: The acc address of variable. This is the link from the data-entry
operation used.</li><li><code>bounds</code>: Used when copying just slice of array or array&rsquo;s bounds are not
encoded in type. They are in rank order where rank 0 is inner-most dimension.</li><li><code>dataClause</code>: Keeps track of the data clause the user used. This is because
the acc operations are decomposed. So a &lsquo;copy&rsquo; clause is decomposed to both
<code>acc.copyin</code> and <code>acc.copyout</code> operations, but both have dataClause that
specifies <code>acc_copy</code> in this field.</li><li><code>structured</code>: Flag to note whether this is associated with structured region
(parallel, kernels, data) or unstructured (enter data, exit data). This is
important due to spec specifically calling out structured and dynamic reference
counters (2.6.7).</li><li><code>implicit</code>: Whether this is an implicitly generated operation, such as copies
done to satisfy &ldquo;Variables with Implicitly Determined Data Attributes&rdquo; in 2.6.2.</li><li><code>name</code>: Holds the name of variable as specified in user clause (including bounds).</li></ul><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-37>Attributes:&nbsp;<a class=headline-hash href=#attributes-37>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dataClause</code></td><td>::mlir::acc::DataClauseAttr</td><td><details><summary>data clauses supported by OpenACC</summary><p>Enum cases:</p><ul><li>acc_copyin (<code>acc_copyin</code>)</li><li>acc_copyin_readonly (<code>acc_copyin_readonly</code>)</li><li>acc_copy (<code>acc_copy</code>)</li><li>acc_copyout (<code>acc_copyout</code>)</li><li>acc_copyout_zero (<code>acc_copyout_zero</code>)</li><li>acc_present (<code>acc_present</code>)</li><li>acc_create (<code>acc_create</code>)</li><li>acc_create_zero (<code>acc_create_zero</code>)</li><li>acc_delete (<code>acc_delete</code>)</li><li>acc_attach (<code>acc_attach</code>)</li><li>acc_detach (<code>acc_detach</code>)</li><li>acc_no_create (<code>acc_no_create</code>)</li><li>acc_private (<code>acc_private</code>)</li><li>acc_firstprivate (<code>acc_firstprivate</code>)</li><li>acc_deviceptr (<code>acc_deviceptr</code>)</li><li>acc_getdeviceptr (<code>acc_getdeviceptr</code>)</li><li>acc_update_host (<code>acc_update_host</code>)</li><li>acc_update_self (<code>acc_update_self</code>)</li><li>acc_update_device (<code>acc_update_device</code>)</li><li>acc_use_device (<code>acc_use_device</code>)</li><li>acc_reduction (<code>acc_reduction</code>)</li><li>acc_declare_device_resident (<code>acc_declare_device_resident</code>)</li><li>acc_declare_link (<code>acc_declare_link</code>)</li><li>acc_cache (<code>acc_cache</code>)</li><li>acc_cache_readonly (<code>acc_cache_readonly</code>)</li></ul></details></td></tr><tr><td><code>structured</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>implicit</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-36>Operands:&nbsp;<a class=headline-hash href=#operands-36>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>accPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>varPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>bounds</code></td><td>variadic of Type for representing acc data clause bounds information</td></tr></tbody></table><h3 id=accuse_device-accusedeviceop><code>acc.use_device</code> (acc::UseDeviceOp)&nbsp;<a class=headline-hash href=#accuse_device-accusedeviceop>¶</a></h3><p><em>Represents acc use_device semantics.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `acc.use_device` `varPtr` `(` $varPtr `:` type($varPtr) `)`
              oilist(
              `varPtrPtr` `(` $varPtrPtr `:` type($varPtrPtr) `)`
              | `bounds` `(` $bounds `)`
              ) `-&gt;` type($accPtr) attr-dict
</code></pre><p>Description of arguments:</p><ul><li><code>varPtr</code>: The address of variable to copy.</li><li><code>varPtrPtr</code>: Specifies the address of varPtr - only used when the variable
copied is a field in a struct. This is important for OpenACC due to implicit
attach semantics on data clauses (2.6.4).</li><li><code>bounds</code>: Used when copying just slice of array or array&rsquo;s bounds are not
encoded in type. They are in rank order where rank 0 is inner-most dimension.</li><li><code>dataClause</code>: Keeps track of the data clause the user used. This is because
the acc operations are decomposed. So a &lsquo;copy&rsquo; clause is decomposed to both
<code>acc.copyin</code> and <code>acc.copyout</code> operations, but both have dataClause that
specifies <code>acc_copy</code> in this field.</li><li><code>structured</code>: Flag to note whether this is associated with structured region
(parallel, kernels, data) or unstructured (enter data, exit data). This is
important due to spec specifically calling out structured and dynamic reference
counters (2.6.7).</li><li><code>implicit</code>: Whether this is an implicitly generated operation, such as copies
done to satisfy &ldquo;Variables with Implicitly Determined Data Attributes&rdquo; in 2.6.2.</li><li><code>name</code>: Holds the name of variable as specified in user clause (including bounds).</li></ul><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-38>Attributes:&nbsp;<a class=headline-hash href=#attributes-38>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dataClause</code></td><td>::mlir::acc::DataClauseAttr</td><td><details><summary>data clauses supported by OpenACC</summary><p>Enum cases:</p><ul><li>acc_copyin (<code>acc_copyin</code>)</li><li>acc_copyin_readonly (<code>acc_copyin_readonly</code>)</li><li>acc_copy (<code>acc_copy</code>)</li><li>acc_copyout (<code>acc_copyout</code>)</li><li>acc_copyout_zero (<code>acc_copyout_zero</code>)</li><li>acc_present (<code>acc_present</code>)</li><li>acc_create (<code>acc_create</code>)</li><li>acc_create_zero (<code>acc_create_zero</code>)</li><li>acc_delete (<code>acc_delete</code>)</li><li>acc_attach (<code>acc_attach</code>)</li><li>acc_detach (<code>acc_detach</code>)</li><li>acc_no_create (<code>acc_no_create</code>)</li><li>acc_private (<code>acc_private</code>)</li><li>acc_firstprivate (<code>acc_firstprivate</code>)</li><li>acc_deviceptr (<code>acc_deviceptr</code>)</li><li>acc_getdeviceptr (<code>acc_getdeviceptr</code>)</li><li>acc_update_host (<code>acc_update_host</code>)</li><li>acc_update_self (<code>acc_update_self</code>)</li><li>acc_update_device (<code>acc_update_device</code>)</li><li>acc_use_device (<code>acc_use_device</code>)</li><li>acc_reduction (<code>acc_reduction</code>)</li><li>acc_declare_device_resident (<code>acc_declare_device_resident</code>)</li><li>acc_declare_link (<code>acc_declare_link</code>)</li><li>acc_cache (<code>acc_cache</code>)</li><li>acc_cache_readonly (<code>acc_cache_readonly</code>)</li></ul></details></td></tr><tr><td><code>structured</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>implicit</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-37>Operands:&nbsp;<a class=headline-hash href=#operands-37>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>varPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>varPtrPtr</code></td><td>PointerLikeType instance</td></tr><tr><td style=text-align:center><code>bounds</code></td><td>variadic of Type for representing acc data clause bounds information</td></tr></tbody></table><h4 id=results-17>Results:&nbsp;<a class=headline-hash href=#results-17>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>accPtr</code></td><td>PointerLikeType instance</td></tr></tbody></table><h3 id=accwait-accwaitop><code>acc.wait</code> (acc::WaitOp)&nbsp;<a class=headline-hash href=#accwait-accwaitop>¶</a></h3><p><em>Wait operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `acc.wait` ( `(` $waitOperands^ `:` type($waitOperands) `)` )?
              oilist(`async` `(` $asyncOperand `:` type($asyncOperand) `)`
              |`wait_devnum` `(` $waitDevnum `:` type($waitDevnum) `)`
              |`if` `(` $ifCond `)`
              ) attr-dict-with-keyword
</code></pre><p>The &ldquo;acc.wait&rdquo; operation represents the OpenACC wait executable
directive.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>acc<span class=p>.</span>wait<span class=p>(</span><span class=nv>%value1</span><span class=p>:</span> <span class=k>index</span><span class=p>)</span>
</span></span><span class=line><span class=cl>acc<span class=p>.</span>wait<span class=p>()</span> async<span class=p>(</span><span class=nv>%async1</span><span class=p>:</span> <span class=k>i32</span><span class=p>)</span>
</span></span></code></pre></div><p>Traits: AttrSizedOperandSegments</p><h4 id=attributes-39>Attributes:&nbsp;<a class=headline-hash href=#attributes-39>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>async</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-38>Operands:&nbsp;<a class=headline-hash href=#operands-38>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>waitOperands</code></td><td>variadic of integer or index</td></tr><tr><td style=text-align:center><code>asyncOperand</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>waitDevnum</code></td><td>integer or index</td></tr><tr><td style=text-align:center><code>ifCond</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=accyield-accyieldop><code>acc.yield</code> (acc::YieldOp)&nbsp;<a class=headline-hash href=#accyield-accyieldop>¶</a></h3><p><em>Acc yield and termination operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `acc.yield` attr-dict ($operands^ `:` type($operands))?
</code></pre><p><code>acc.yield</code> is a special terminator operation for block inside regions in
various acc ops (including parallel, loop, atomic.update). It returns values
to the immediately enclosing acc op.</p><p>Traits: HasParent&lt;FirstprivateRecipeOp, LoopOp, ParallelOp, PrivateRecipeOp,ReductionRecipeOp, SerialOp, AtomicUpdateOp>, ReturnLike, Terminator</p><p>Interfaces: RegionBranchTerminatorOpInterface</p><h4 id=operands-39>Operands:&nbsp;<a class=headline-hash href=#operands-39>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operands</code></td><td>variadic of any type</td></tr></tbody></table><h2 id=attributes-40>Attributes&nbsp;<a class=headline-hash href=#attributes-40>¶</a></h2><h3 id=declareactionattr>DeclareActionAttr&nbsp;<a class=headline-hash href=#declareactionattr>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>#acc.declare_action&lt;
  SymbolRefAttr,   # preAlloc
  SymbolRefAttr,   # postAlloc
  SymbolRefAttr,   # preDealloc
  SymbolRefAttr   # postDealloc
&gt;
</code></pre><h4 id=parameters>Parameters:&nbsp;<a class=headline-hash href=#parameters>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>preAlloc</td><td style=text-align:center><code>SymbolRefAttr</code></td><td></td></tr><tr><td style=text-align:center>postAlloc</td><td style=text-align:center><code>SymbolRefAttr</code></td><td></td></tr><tr><td style=text-align:center>preDealloc</td><td style=text-align:center><code>SymbolRefAttr</code></td><td></td></tr><tr><td style=text-align:center>postDealloc</td><td style=text-align:center><code>SymbolRefAttr</code></td><td></td></tr></tbody></table><h3 id=declareattr>DeclareAttr&nbsp;<a class=headline-hash href=#declareattr>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>#acc.declare&lt;
  DataClauseAttr,   # dataClause
  bool   # implicit
&gt;
</code></pre><h4 id=parameters-1>Parameters:&nbsp;<a class=headline-hash href=#parameters-1>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>dataClause</td><td style=text-align:center><code>DataClauseAttr</code></td><td></td></tr><tr><td style=text-align:center>implicit</td><td style=text-align:center><code>bool</code></td><td></td></tr></tbody></table><h3 id=clausedefaultvalueattr>ClauseDefaultValueAttr&nbsp;<a class=headline-hash href=#clausedefaultvalueattr>¶</a></h3><p>DefaultValue Clause</p><p>Syntax:</p><pre tabindex=0><code>#acc.defaultvalue&lt;
  ::mlir::acc::ClauseDefaultValue   # value
&gt;
</code></pre><p>Enum cases:</p><ul><li>present (<code>Present</code>)</li><li>none (<code>None</code>)</li></ul><h4 id=parameters-2>Parameters:&nbsp;<a class=headline-hash href=#parameters-2>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::acc::ClauseDefaultValue</code></td><td>an enum of type ClauseDefaultValue</td></tr></tbody></table><h3 id=dataclauseattr>DataClauseAttr&nbsp;<a class=headline-hash href=#dataclauseattr>¶</a></h3><p>data clauses supported by OpenACC</p><p>Syntax:</p><pre tabindex=0><code>#acc.data_clause&lt;
  ::mlir::acc::DataClause   # value
&gt;
</code></pre><p>Enum cases:</p><ul><li>acc_copyin (<code>acc_copyin</code>)</li><li>acc_copyin_readonly (<code>acc_copyin_readonly</code>)</li><li>acc_copy (<code>acc_copy</code>)</li><li>acc_copyout (<code>acc_copyout</code>)</li><li>acc_copyout_zero (<code>acc_copyout_zero</code>)</li><li>acc_present (<code>acc_present</code>)</li><li>acc_create (<code>acc_create</code>)</li><li>acc_create_zero (<code>acc_create_zero</code>)</li><li>acc_delete (<code>acc_delete</code>)</li><li>acc_attach (<code>acc_attach</code>)</li><li>acc_detach (<code>acc_detach</code>)</li><li>acc_no_create (<code>acc_no_create</code>)</li><li>acc_private (<code>acc_private</code>)</li><li>acc_firstprivate (<code>acc_firstprivate</code>)</li><li>acc_deviceptr (<code>acc_deviceptr</code>)</li><li>acc_getdeviceptr (<code>acc_getdeviceptr</code>)</li><li>acc_update_host (<code>acc_update_host</code>)</li><li>acc_update_self (<code>acc_update_self</code>)</li><li>acc_update_device (<code>acc_update_device</code>)</li><li>acc_use_device (<code>acc_use_device</code>)</li><li>acc_reduction (<code>acc_reduction</code>)</li><li>acc_declare_device_resident (<code>acc_declare_device_resident</code>)</li><li>acc_declare_link (<code>acc_declare_link</code>)</li><li>acc_cache (<code>acc_cache</code>)</li><li>acc_cache_readonly (<code>acc_cache_readonly</code>)</li></ul><h4 id=parameters-3>Parameters:&nbsp;<a class=headline-hash href=#parameters-3>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::acc::DataClause</code></td><td>an enum of type DataClause</td></tr></tbody></table><h3 id=devicetypeattr>DeviceTypeAttr&nbsp;<a class=headline-hash href=#devicetypeattr>¶</a></h3><p>built-in device type supported by OpenACC</p><p>Syntax:</p><pre tabindex=0><code>#acc.device_type&lt;
  ::mlir::acc::DeviceType   # value
&gt;
</code></pre><p>Enum cases:</p><ul><li>star (<code>Star</code>)</li><li>default (<code>Default</code>)</li><li>host (<code>Host</code>)</li><li>multicore (<code>Multicore</code>)</li><li>nvidia (<code>Nvidia</code>)</li><li>radeon (<code>Radeon</code>)</li></ul><h4 id=parameters-4>Parameters:&nbsp;<a class=headline-hash href=#parameters-4>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::acc::DeviceType</code></td><td>an enum of type DeviceType</td></tr></tbody></table><h3 id=reductionoperatorattr>ReductionOperatorAttr&nbsp;<a class=headline-hash href=#reductionoperatorattr>¶</a></h3><p>built-in reduction operations supported by OpenACC</p><p>Syntax:</p><pre tabindex=0><code>#acc.reduction_operator&lt;
  ::mlir::acc::ReductionOperator   # value
&gt;
</code></pre><p>Enum cases:</p><ul><li>add (<code>AccAdd</code>)</li><li>mul (<code>AccMul</code>)</li><li>max (<code>AccMax</code>)</li><li>min (<code>AccMin</code>)</li><li>iand (<code>AccIand</code>)</li><li>ior (<code>AccIor</code>)</li><li>xor (<code>AccXor</code>)</li><li>eqv (<code>AccEqv</code>)</li><li>neqv (<code>AccNeqv</code>)</li><li>land (<code>AccLand</code>)</li><li>lor (<code>AccLor</code>)</li></ul><h4 id=parameters-5>Parameters:&nbsp;<a class=headline-hash href=#parameters-5>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::acc::ReductionOperator</code></td><td>an enum of type ReductionOperator</td></tr></tbody></table><h3 id=routineinfoattr>RoutineInfoAttr&nbsp;<a class=headline-hash href=#routineinfoattr>¶</a></h3><p>Keeps track of associated acc routine information</p><p>Syntax:</p><pre tabindex=0><code>#acc.routine_info&lt;
  ::llvm::ArrayRef&lt;SymbolRefAttr&gt;   # accRoutines
&gt;
</code></pre><p>This attribute is used to create the association between a function and
its <code>acc.routine</code> operation. A <code>func.func</code> uses this if its name
was referenced in an <code>acc routine</code> directive.</p><h4 id=parameters-6>Parameters:&nbsp;<a class=headline-hash href=#parameters-6>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>accRoutines</td><td style=text-align:center><code>::llvm::ArrayRef&lt;SymbolRefAttr></code></td><td></td></tr></tbody></table><h2 id=types>Types&nbsp;<a class=headline-hash href=#types>¶</a></h2><h3 id=databoundstype>DataBoundsType&nbsp;<a class=headline-hash href=#databoundstype>¶</a></h3><p>Type for representing acc data clause bounds information</p><p>Syntax: <code>!acc.data_bounds_ty</code></p><h3 id=declaretokentype>DeclareTokenType&nbsp;<a class=headline-hash href=#declaretokentype>¶</a></h3><p>declare token type</p><p>Syntax: <code>!acc.declare_token</code></p><p><code>acc.declare_token</code> is a type returned by a <code>declare_enter</code> operation and
can be passed to a <code>declare_exit</code> operation to represent an implicit
data region.</p><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://mlir.llvm.org/docs/Dialects/ title=Dialects><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - Dialects</a>
<a class="nav nav-next" href=https://mlir.llvm.org/docs/Dialects/Affine/ title="'affine' Dialect">Next - 'affine' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=https://mlir.llvm.org/users/>Users of MLIR</a></li><li><a href=https://mlir.llvm.org/pubs/>MLIR Related Publications</a></li><li><a href=https://mlir.llvm.org/talks/>Talks</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/deprecation/>Deprecations & Current Refactoring<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/deprecation/TestingGuide/>Testing Guide haha</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/getting_started/ReportingIssues/>Reporting Issues</a></li><li><a href=https://mlir.llvm.org/getting_started/Debugging/>Debugging Tips</a></li><li><a href=https://mlir.llvm.org/getting_started/Faq/>FAQ</a></li><li><a href=https://mlir.llvm.org/getting_started/Contributing/>How to Contribute</a></li><li><a href=https://mlir.llvm.org/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=https://mlir.llvm.org/getting_started/openprojects/>Open Projects</a></li><li><a href=https://mlir.llvm.org/getting_started/Glossary/>Glossary</a></li><li><a href=https://mlir.llvm.org/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-reduce/>MLIR Reduce</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/ActionTracing/>Action: Tracing and Debugging MLIR-based Compilers</a></li><li><a href=https://mlir.llvm.org/docs/BufferDeallocationInternals/>Buffer Deallocation - Internals</a></li><li><a href=https://mlir.llvm.org/docs/Bufferization/>Bufferization</a></li><li><a href=https://mlir.llvm.org/docs/DataLayout/>Data Layout Modeling</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/DefiningDialects/>Defining Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/DefiningDialects/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Operations/>Operation Definition Specification (ODS)</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/DialectConversion/>Dialect Conversion</a></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li class=active><a href=https://mlir.llvm.org/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMDGPU/>'amdgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArithOps/>'arith' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSME/>'ArmSME' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IndexOps/>'index' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IRDL/>'irdl' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Mesh/>'mesh' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/>'omp' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/UBOps/>'ub' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MatchOpInterfaces/>OpInterface definitions</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Interfaces/>Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=https://mlir.llvm.org/docs/BytecodeFormat/>MLIR Bytecode Format</a></li><li><a href=https://mlir.llvm.org/docs/CAPI/>MLIR C API</a></li><li><a href=https://mlir.llvm.org/docs/LangRef/>MLIR Language Reference</a></li><li><a href=https://mlir.llvm.org/docs/ReleaseNotes/>MLIR Release Notes</a></li><li><a href=https://mlir.llvm.org/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=https://mlir.llvm.org/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/Passes/>Passes</a></li><li><a href=https://mlir.llvm.org/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=https://mlir.llvm.org/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=https://mlir.llvm.org/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/SideEffectsAndSpeculation/>Side Effects & Speculation</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/ShapeInference/>Shape Inference</a></li><li><a href=https://mlir.llvm.org/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=https://mlir.llvm.org/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=https://mlir.llvm.org/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Traits/>Traits<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Traits/Broadcastable/>The `Broadcastable` Trait</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/transform/>Transform Dialect Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch0/>Chapter 0: A Primer on “Structured” Linalg Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch1/>Chapter 1: Combining Existing Transformations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch2/>Chapter 2: Adding a Simple New Transformation Operation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch3/>Chapter 3: More than Simple Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/ChH/>Chapter H: Reproducing Halide Schedule</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>