<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'gpu' Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.119.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/GPU/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://mlir.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li></ul></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&amp;list_id=177877&amp;order=changeddate%20DESC%2Cpriority%2Cbug_severity&amp;product=MLIR&amp;query_format=specific">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>'gpu' Dialect</h1><p>Note: this dialect is more likely to change than others in the near future; use
with caution.</p><p>This dialect provides middle-level abstractions for launching GPU kernels
following a programming model similar to that of CUDA or OpenCL. It provides
abstractions for kernel invocations (and may eventually provide those for device
management) that are not present at the lower level (e.g., as LLVM IR intrinsics
for GPUs). Its goal is to abstract away device- and driver-specific
manipulations to launch a GPU kernel and provide a simple path towards GPU
execution from MLIR. It may be targeted, for example, by DSLs using MLIR. The
dialect uses <code>gpu</code> as its canonical prefix.</p><p><nav id=TableOfContents><ul><li><a href=#memory-attribution>Memory attribution</a></li><li><a href=#gpu-compilation>GPU Compilation</a><ul><li><a href=#deprecation-notice>Deprecation notice</a></li><li><a href=#compilation-overview>Compilation overview</a></li><li><a href=#module-serialization>Module serialization</a></li><li><a href=#offloading-llvm-translation>Offloading LLVM translation</a></li><li><a href=#the-binary-operation>The binary operation</a></li></ul></li><li><a href=#operations>Operations</a><ul><li><a href=#gpuall_reduce-gpuallreduceop><code>gpu.all_reduce</code> (gpu::AllReduceOp)</a></li><li><a href=#gpualloc-gpuallocop><code>gpu.alloc</code> (gpu::AllocOp)</a></li><li><a href=#gpubarrier-gpubarrierop><code>gpu.barrier</code> (gpu::BarrierOp)</a></li><li><a href=#gpubinary-gpubinaryop><code>gpu.binary</code> (gpu::BinaryOp)</a></li><li><a href=#gpublock_dim-gpublockdimop><code>gpu.block_dim</code> (gpu::BlockDimOp)</a></li><li><a href=#gpublock_id-gpublockidop><code>gpu.block_id</code> (gpu::BlockIdOp)</a></li><li><a href=#gpucluster_dim-gpuclusterdimop><code>gpu.cluster_dim</code> (gpu::ClusterDimOp)</a></li><li><a href=#gpucluster_id-gpuclusteridop><code>gpu.cluster_id</code> (gpu::ClusterIdOp)</a></li><li><a href=#gpucreate_2to4_spmat-gpucreate2to4spmatop><code>gpu.create_2to4_spmat</code> (gpu::Create2To4SpMatOp)</a></li><li><a href=#gpucreate_bsr-gpucreatebsrop><code>gpu.create_bsr</code> (gpu::CreateBsrOp)</a></li><li><a href=#gpucreate_coo_aos-gpucreatecooaosop><code>gpu.create_coo_aos</code> (gpu::CreateCooAoSOp)</a></li><li><a href=#gpucreate_coo-gpucreatecooop><code>gpu.create_coo</code> (gpu::CreateCooOp)</a></li><li><a href=#gpucreate_csc-gpucreatecscop><code>gpu.create_csc</code> (gpu::CreateCscOp)</a></li><li><a href=#gpucreate_csr-gpucreatecsrop><code>gpu.create_csr</code> (gpu::CreateCsrOp)</a></li><li><a href=#gpucreate_dn_tensor-gpucreatedntensorop><code>gpu.create_dn_tensor</code> (gpu::CreateDnTensorOp)</a></li><li><a href=#gpudealloc-gpudeallocop><code>gpu.dealloc</code> (gpu::DeallocOp)</a></li><li><a href=#gpudestroy_dn_tensor-gpudestroydntensorop><code>gpu.destroy_dn_tensor</code> (gpu::DestroyDnTensorOp)</a></li><li><a href=#gpudestroy_sp_mat-gpudestroyspmatop><code>gpu.destroy_sp_mat</code> (gpu::DestroySpMatOp)</a></li><li><a href=#gpudynamic_shared_memory-gpudynamicsharedmemoryop><code>gpu.dynamic_shared_memory</code> (gpu::DynamicSharedMemoryOp)</a></li><li><a href=#gpufunc-gpugpufuncop><code>gpu.func</code> (gpu::GPUFuncOp)</a></li><li><a href=#gpumodule-gpugpumoduleop><code>gpu.module</code> (gpu::GPUModuleOp)</a></li><li><a href=#gpuglobal_id-gpuglobalidop><code>gpu.global_id</code> (gpu::GlobalIdOp)</a></li><li><a href=#gpugrid_dim-gpugriddimop><code>gpu.grid_dim</code> (gpu::GridDimOp)</a></li><li><a href=#gpuhost_register-gpuhostregisterop><code>gpu.host_register</code> (gpu::HostRegisterOp)</a></li><li><a href=#gpuhost_unregister-gpuhostunregisterop><code>gpu.host_unregister</code> (gpu::HostUnregisterOp)</a></li><li><a href=#gpulane_id-gpulaneidop><code>gpu.lane_id</code> (gpu::LaneIdOp)</a></li><li><a href=#gpulaunch_func-gpulaunchfuncop><code>gpu.launch_func</code> (gpu::LaunchFuncOp)</a></li><li><a href=#gpulaunch-gpulaunchop><code>gpu.launch</code> (gpu::LaunchOp)</a></li><li><a href=#gpumemcpy-gpumemcpyop><code>gpu.memcpy</code> (gpu::MemcpyOp)</a></li><li><a href=#gpumemset-gpumemsetop><code>gpu.memset</code> (gpu::MemsetOp)</a></li><li><a href=#gpumodule_end-gpumoduleendop><code>gpu.module_end</code> (gpu::ModuleEndOp)</a></li><li><a href=#gpunum_subgroups-gpunumsubgroupsop><code>gpu.num_subgroups</code> (gpu::NumSubgroupsOp)</a></li><li><a href=#gpuprintf-gpuprintfop><code>gpu.printf</code> (gpu::PrintfOp)</a></li><li><a href=#gpureturn-gpureturnop><code>gpu.return</code> (gpu::ReturnOp)</a></li><li><a href=#gpusddmm_buffer_size-gpusddmmbuffersizeop><code>gpu.sddmm_buffer_size</code> (gpu::SDDMMBufferSizeOp)</a></li><li><a href=#gpusddmm-gpusddmmop><code>gpu.sddmm</code> (gpu::SDDMMOp)</a></li><li><a href=#gpuset_csr_pointers-gpusetcsrpointersop><code>gpu.set_csr_pointers</code> (gpu::SetCsrPointersOp)</a></li><li><a href=#gpuset_default_device-gpusetdefaultdeviceop><code>gpu.set_default_device</code> (gpu::SetDefaultDeviceOp)</a></li><li><a href=#gpushuffle-gpushuffleop><code>gpu.shuffle</code> (gpu::ShuffleOp)</a></li><li><a href=#gpuspgemm_copy-gpuspgemmcopyop><code>gpu.spgemm_copy</code> (gpu::SpGEMMCopyOp)</a></li><li><a href=#gpuspgemm_create_descr-gpuspgemmcreatedescrop><code>gpu.spgemm_create_descr</code> (gpu::SpGEMMCreateDescrOp)</a></li><li><a href=#gpuspgemm_destroy_descr-gpuspgemmdestroydescrop><code>gpu.spgemm_destroy_descr</code> (gpu::SpGEMMDestroyDescrOp)</a></li><li><a href=#gpuspgemm_work_estimation_or_compute-gpuspgemmworkestimationorcomputeop><code>gpu.spgemm_work_estimation_or_compute</code> (gpu::SpGEMMWorkEstimationOrComputeOp)</a></li><li><a href=#gpuspmm_buffer_size-gpuspmmbuffersizeop><code>gpu.spmm_buffer_size</code> (gpu::SpMMBufferSizeOp)</a></li><li><a href=#gpuspmm-gpuspmmop><code>gpu.spmm</code> (gpu::SpMMOp)</a></li><li><a href=#gpuspmv_buffer_size-gpuspmvbuffersizeop><code>gpu.spmv_buffer_size</code> (gpu::SpMVBufferSizeOp)</a></li><li><a href=#gpuspmv-gpuspmvop><code>gpu.spmv</code> (gpu::SpMVOp)</a></li><li><a href=#gpuspmat_get_size-gpuspmatgetsizeop><code>gpu.spmat_get_size</code> (gpu::SpMatGetSizeOp)</a></li><li><a href=#gpusubgroup_id-gpusubgroupidop><code>gpu.subgroup_id</code> (gpu::SubgroupIdOp)</a></li><li><a href=#gpusubgroup_mma_compute-gpusubgroupmmacomputeop><code>gpu.subgroup_mma_compute</code> (gpu::SubgroupMmaComputeOp)</a></li><li><a href=#gpusubgroup_mma_constant_matrix-gpusubgroupmmaconstantmatrixop><code>gpu.subgroup_mma_constant_matrix</code> (gpu::SubgroupMmaConstantMatrixOp)</a></li><li><a href=#gpusubgroup_mma_elementwise-gpusubgroupmmaelementwiseop><code>gpu.subgroup_mma_elementwise</code> (gpu::SubgroupMmaElementwiseOp)</a></li><li><a href=#gpusubgroup_mma_load_matrix-gpusubgroupmmaloadmatrixop><code>gpu.subgroup_mma_load_matrix</code> (gpu::SubgroupMmaLoadMatrixOp)</a></li><li><a href=#gpusubgroup_mma_store_matrix-gpusubgroupmmastorematrixop><code>gpu.subgroup_mma_store_matrix</code> (gpu::SubgroupMmaStoreMatrixOp)</a></li><li><a href=#gpusubgroup_reduce-gpusubgroupreduceop><code>gpu.subgroup_reduce</code> (gpu::SubgroupReduceOp)</a></li><li><a href=#gpusubgroup_size-gpusubgroupsizeop><code>gpu.subgroup_size</code> (gpu::SubgroupSizeOp)</a></li><li><a href=#gputerminator-gputerminatorop><code>gpu.terminator</code> (gpu::TerminatorOp)</a></li><li><a href=#gputhread_id-gputhreadidop><code>gpu.thread_id</code> (gpu::ThreadIdOp)</a></li><li><a href=#gpuwait-gpuwaitop><code>gpu.wait</code> (gpu::WaitOp)</a></li><li><a href=#gpuyield-gpuyieldop><code>gpu.yield</code> (gpu::YieldOp)</a></li></ul></li></ul></nav><h2 id=memory-attribution>Memory attribution&nbsp;<a class=headline-hash href=#memory-attribution>¶</a></h2><p>Memory buffers are defined at the function level, either in &ldquo;gpu.launch&rdquo; or in
&ldquo;gpu.func&rdquo; ops. This encoding makes it clear where the memory belongs and makes
the lifetime of the memory visible. The memory is only accessible while the
kernel is launched/the function is currently invoked. The latter is more strict
than actual GPU implementations but using static memory at the function level is
just for convenience. It is also always possible to pass pointers to the
workgroup memory into other functions, provided they expect the correct memory
space.</p><p>The buffers are considered live throughout the execution of the GPU function
body. The absence of memory attribution syntax means that the function does not
require special buffers. Rationale: although the underlying models declare
memory buffers at the module level, we chose to do it at the function level to
provide some structuring for the lifetime of those buffers; this avoids the
incentive to use the buffers for communicating between different kernels or
launches of the same kernel, which should be done through function arguments
instead; we chose not to use <code>alloca</code>-style approach that would require more
complex lifetime analysis following the principles of MLIR that promote
structure and representing analysis results in the IR.</p><h2 id=gpu-compilation>GPU Compilation&nbsp;<a class=headline-hash href=#gpu-compilation>¶</a></h2><h3 id=deprecation-notice>Deprecation notice&nbsp;<a class=headline-hash href=#deprecation-notice>¶</a></h3><p>The <code>--gpu-to-(cubin|hsaco)</code> passes will be deprecated in a future release.</p><h3 id=compilation-overview>Compilation overview&nbsp;<a class=headline-hash href=#compilation-overview>¶</a></h3><p>The compilation process in the GPU dialect has two main stages: GPU module
serialization and offloading operations translation. Together these stages can
produce GPU binaries and the necessary code to execute them.</p><p>An example of how the compilation workflow look is:</p><pre tabindex=0><code>mlir-opt example.mlir                   \
  --pass-pipeline=&#34;builtin.module(      \
    nvvm-attach-target{chip=sm_90 O=3}, \ # Attach an NVVM target to a gpu.module op.
    gpu.module(convert-gpu-to-nvvm),    \ # Convert GPU to NVVM.
    gpu-to-llvm,                        \ # Convert GPU to LLVM.
    gpu-module-to-binary                \ # Serialize GPU modules to binaries.
  )&#34; -o example-nvvm.mlir
mlir-translate example-nvvm.mlir        \
  --mlir-to-llvmir                      \ # Obtain the translated LLVM IR.
  -o example.ll
</code></pre><h3 id=module-serialization>Module serialization&nbsp;<a class=headline-hash href=#module-serialization>¶</a></h3><p>Attributes implementing the GPU Target Attribute Interface handle the
serialization process and are called Target attributes. These attributes can be
attached to GPU Modules indicating the serialization scheme to compile the
module into a binary string.</p><p>The <code>gpu-module-to-binary</code> pass searches for all nested GPU modules and
serializes the module using the target attributes attached to the module,
producing a binary with an object for every target.</p><p>Example:</p><pre tabindex=0><code>// Input:
gpu.module @kernels [#nvvm.target&lt;chip = &#34;sm_90&#34;&gt;, #nvvm.target&lt;chip = &#34;sm_60&#34;&gt;] {
  ...
}
// mlir-opt --gpu-module-to-binary:
gpu.binary @kernels [
  #gpu.object&lt;#nvvm.target&lt;chip = &#34;sm_90&#34;&gt;, &#34;sm_90 cubin&#34;&gt;,
  #gpu.object&lt;#nvvm.target&lt;chip = &#34;sm_60&#34;&gt;, &#34;sm_60 cubin&#34;&gt;
]
</code></pre><h3 id=offloading-llvm-translation>Offloading LLVM translation&nbsp;<a class=headline-hash href=#offloading-llvm-translation>¶</a></h3><p>Attributes implementing the GPU Offloading LLVM Translation Attribute Interface
handle the translation of GPU binaries and kernel launches into LLVM
instructions and are called Offloading attributes. These attributes are
attached to GPU binary operations.</p><p>During the LLVM translation process, GPU binaries get translated using the
scheme provided by the Offloading attribute, translating the GPU binary into
LLVM instructions. Meanwhile, Kernel launches are translated by searching the
appropriate binary and invoking the procedure provided by the Offloading
attribute in the binary for translating kernel launches into LLVM instructions.</p><p>Example:</p><pre tabindex=0><code>// Input:
// Binary with multiple objects but selecting the second one for embedding.
gpu.binary @binary &lt;#gpu.select_object&lt;#rocdl.target&lt;chip = &#34;gfx90a&#34;&gt;&gt;&gt; [
    #gpu.object&lt;#nvvm.target, &#34;NVPTX&#34;&gt;,
    #gpu.object&lt;#rocdl.target&lt;chip = &#34;gfx90a&#34;&gt;, &#34;AMDGPU&#34;&gt;
  ]
llvm.func @foo() {
  ...
  // Launching a kernel inside the binary.
  gpu.launch_func @binary::@func blocks in (%0, %0, %0)
                                 threads in (%0, %0, %0) : i64
                                 dynamic_shared_memory_size %2
                                 args(%1 : i32, %1 : i32)
  ...
}
// mlir-translate --mlir-to-llvmir:
@binary_bin_cst = internal constant [6 x i8] c&#34;AMDGPU&#34;, align 8
@binary_func_kernel_name = private unnamed_addr constant [7 x i8] c&#34;func\00&#34;, align 1
...
define void @foo() {
  ...
  %module = call ptr @mgpuModuleLoad(ptr @binary_bin_cst)
  %kernel = call ptr @mgpuModuleGetFunction(ptr %module, ptr @binary_func_kernel_name)
  call void @mgpuLaunchKernel(ptr %kernel, ...) ; Launch the kernel
  ...
  call void @mgpuModuleUnload(ptr %module)
  ...
}
...
</code></pre><h3 id=the-binary-operation>The binary operation&nbsp;<a class=headline-hash href=#the-binary-operation>¶</a></h3><p>From a semantic point of view, GPU binaries allow the implementation of many
concepts, from simple object files to fat binaries. By default, the binary
operation uses the <code>#gpu.select_object</code> offloading attribute; this attribute
embeds a single object in the binary as a global string, see the attribute docs
for more information.</p><h2 id=operations>Operations&nbsp;<a class=headline-hash href=#operations>¶</a></h2><p><a href=https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/GPU/IR/GPUOps.td>source</a></p><h3 id=gpuall_reduce-gpuallreduceop><code>gpu.all_reduce</code> (gpu::AllReduceOp)&nbsp;<a class=headline-hash href=#gpuall_reduce-gpuallreduceop>¶</a></h3><p><em>Reduce values among workgroup.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.all_reduce` custom&lt;AllReduceOperation&gt;($op) $value
              (`uniform` $uniform^)? $body attr-dict
              `:` functional-type(operands, results)
</code></pre><p>The <code>all_reduce</code> op reduces the value of every work item across a local
workgroup. The result is equal for all work items of a workgroup.</p><p>For example, both</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> gpu<span class=p>.</span>all_reduce add <span class=nv>%0</span> <span class=p>{}</span> <span class=p>:</span> <span class=p>(</span><span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>f32</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> gpu<span class=p>.</span>all_reduce <span class=nv>%0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=nl>^bb</span><span class=p>(</span><span class=nv>%lhs</span> <span class=p>:</span> <span class=k>f32</span><span class=p>,</span> <span class=nv>%rhs</span> <span class=p>:</span> <span class=k>f32</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=nv>%sum</span> <span class=p>=</span> arith<span class=p>.</span>addf <span class=nv>%lhs</span><span class=p>,</span> <span class=nv>%rhs</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl>  <span class=s>&#34;gpu.yield&#34;</span><span class=p>(</span><span class=nv>%sum</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=p>:</span> <span class=p>(</span><span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>f32</span><span class=p>)</span>
</span></span></code></pre></div><p>compute the sum of each work item&rsquo;s %0 value. The first version specifies
the accumulation as operation, whereas the second version specifies the
accumulation as code region. The reduction operation must be one of:</p><ul><li>Integer types: <code>add</code>, <code>mul</code>, <code>minui</code>, <code>minsi</code>, <code>maxui</code>, <code>maxsi</code>, <code>and</code>,
<code>or</code>, <code>xor</code></li><li>Floating point types: <code>add</code>, <code>mul</code>, <code>minf</code>, <code>maxf</code>, <code>minimumf</code>,
<code>maximumf</code></li></ul><p>If <code>uniform</code> flag is set either none or all work items of a workgroup
need to execute this op in convergence.</p><p>Traits: IsolatedFromAbove, SameOperandsAndResultType</p><p>Interfaces: InferTypeOpInterface</p><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>op</code></td><td>::mlir::gpu::AllReduceOperationAttr</td><td><details><summary>built-in reduction operations supported by gpu.allreduce.</summary><p>Enum cases:</p><ul><li>add (<code>ADD</code>)</li><li>mul (<code>MUL</code>)</li><li>minui (<code>MINUI</code>)</li><li>minsi (<code>MINSI</code>)</li><li>minf (<code>MINF</code>)</li><li>maxui (<code>MAXUI</code>)</li><li>maxsi (<code>MAXSI</code>)</li><li>maxf (<code>MAXF</code>)</li><li>and (<code>AND</code>)</li><li>or (<code>OR</code>)</li><li>xor (<code>XOR</code>)</li><li>minimumf (<code>MINIMUMF</code>)</li><li>maximumf (<code>MAXIMUMF</code>)</li></ul></details></td></tr><tr><td><code>uniform</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>Integer or Float</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>Integer or Float</td></tr></tbody></table><h3 id=gpualloc-gpuallocop><code>gpu.alloc</code> (gpu::AllocOp)&nbsp;<a class=headline-hash href=#gpualloc-gpuallocop>¶</a></h3><p><em>GPU memory allocation operation.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.alloc` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies) (` ` `host_shared` $hostShared^)? ` `
              `(` $dynamicSizes `)` (`` `[` $symbolOperands^ `]`)? attr-dict `:` type($memref)
</code></pre><p>The <code>gpu.alloc</code> operation allocates a region of memory on the GPU. It is
similar to the <code>memref.alloc</code> op, but supports asynchronous GPU execution.</p><p>The op does not execute before all async dependencies have finished
executing.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it also returns a !gpu.async.token.</p><p>If the <code>host_shared</code> keyword is present, the memory will be allocated in a
memory accessible both on host and on device.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%memref</span><span class=p>,</span> <span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>alloc async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span> host_shared <span class=p>(</span><span class=nv>%width</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>64x?x</span><span class=k>f32</span><span class=p>,</span> <span class=m>1</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: AttrSizedOperandSegments</p><p>Interfaces: GPU_AsyncOpInterface</p><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>hostShared</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>dynamicSizes</code></td><td>variadic of index</td></tr><tr><td style=text-align:center><code>symbolOperands</code></td><td>variadic of index</td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>memref</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpubarrier-gpubarrierop><code>gpu.barrier</code> (gpu::BarrierOp)&nbsp;<a class=headline-hash href=#gpubarrier-gpubarrierop>¶</a></h3><p><em>Synchronizes all work items of a workgroup.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.barrier` attr-dict
</code></pre><p>The &ldquo;barrier&rdquo; op synchronizes all work items of a workgroup. It is used
to coordinate communication between the work items of the workgroup.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>gpu<span class=p>.</span>barrier
</span></span></code></pre></div><p>waits until all work items in the workgroup have reached this point
and all memory accesses made by these work items prior to the op are
visible to all work items in the workgroup. Data hazards between work items
accessing the same memory can be avoided by synchronizing work items
in-between these accesses.</p><p>Either none or all work items of a workgroup need to execute this op
in convergence.</p><h3 id=gpubinary-gpubinaryop><code>gpu.binary</code> (gpu::BinaryOp)&nbsp;<a class=headline-hash href=#gpubinary-gpubinaryop>¶</a></h3><p><em>An Op for storing serialized GPU binary objects.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.binary` $sym_name custom&lt;OffloadingHandler&gt;($offloadingHandler) attr-dict $objects
</code></pre><p>GPU binaries provide a semantic mechanism for storing GPU objects,
e.g. the result of compiling a GPU module to an object file.</p><p>This operation has 3 arguments:</p><ul><li>The name of the binary.</li><li>An optional attribute implementing the offloading LLVM translation interface.</li><li>An array of GPU object attributes.</li></ul><p>During translation, the offloading attribute will be called for translating
GPU <code>binary</code> and <code>launch_func</code> operations. The default offloading handler is:
<code>#gpu.select_object</code>, this handler selects the first object from the array
and embeds it as a string.</p><p>Examples:</p><pre tabindex=0><code>  // Selects the first object.
  gpu.binary @myobject [#gpu.object&lt;...&gt;, #gpu.object&lt;...&gt;]
  // Uses the `#foo.my_handler` for handling the binary during translation.
  gpu.binary @myobject &lt;#foo.my_handler&gt; [#gpu.object&lt;...&gt;, #gpu.object&lt;...&gt;]
  // Selects the object with the `#rocdl.target` target attribute.
  gpu.binary @myobject &lt;#gpu.select_object&lt;#rocdl.target&gt;&gt; [#gpu.object&lt;...&gt;, #gpu.object&lt;#rocdl.target, ...&gt;]
</code></pre><p>Interfaces: Symbol</p><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>offloadingHandler</code></td><td>::mlir::Attribute</td><td>any attribute with the `OffloadingTranslationAttrTrait` trait.</td></tr><tr><td><code>objects</code></td><td>::mlir::ArrayAttr</td><td>an array of GPU object attributes with at least 1 elements</td></tr></table><h3 id=gpublock_dim-gpublockdimop><code>gpu.block_dim</code> (gpu::BlockDimOp)&nbsp;<a class=headline-hash href=#gpublock_dim-gpublockdimop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.block_dim` $dimension attr-dict
</code></pre><p>Returns the number of threads in the thread block (aka the block size) along
the x, y, or z <code>dimension</code>.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%bDimX</span> <span class=p>=</span> gpu<span class=p>.</span>block_dim <span class=p>x</span>
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, InferIntRangeInterface, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-3>Attributes:&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dimension</code></td><td>::mlir::gpu::DimensionAttr</td><td><details><summary>a dimension, either 'x', 'y', or 'z'</summary><p>Enum cases:</p><ul><li>x (<code>x</code>)</li><li>y (<code>y</code>)</li><li>z (<code>z</code>)</li></ul></details></td></tr></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>index</td></tr></tbody></table><h3 id=gpublock_id-gpublockidop><code>gpu.block_id</code> (gpu::BlockIdOp)&nbsp;<a class=headline-hash href=#gpublock_id-gpublockidop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.block_id` $dimension attr-dict
</code></pre><p>Returns the block id, i.e. the index of the current block within the grid
along the x, y, or z <code>dimension</code>.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%bIdY</span> <span class=p>=</span> gpu<span class=p>.</span>block_id y
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, InferIntRangeInterface, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-4>Attributes:&nbsp;<a class=headline-hash href=#attributes-4>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dimension</code></td><td>::mlir::gpu::DimensionAttr</td><td><details><summary>a dimension, either 'x', 'y', or 'z'</summary><p>Enum cases:</p><ul><li>x (<code>x</code>)</li><li>y (<code>y</code>)</li><li>z (<code>z</code>)</li></ul></details></td></tr></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>index</td></tr></tbody></table><h3 id=gpucluster_dim-gpuclusterdimop><code>gpu.cluster_dim</code> (gpu::ClusterDimOp)&nbsp;<a class=headline-hash href=#gpucluster_dim-gpuclusterdimop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.cluster_dim` $dimension attr-dict
</code></pre><p>Returns the number of thread blocks in the cluster along
the x, y, or z <code>dimension</code>.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%cDimX</span> <span class=p>=</span> gpu<span class=p>.</span>cluster_dim <span class=p>x</span>
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, InferIntRangeInterface, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-5>Attributes:&nbsp;<a class=headline-hash href=#attributes-5>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dimension</code></td><td>::mlir::gpu::DimensionAttr</td><td><details><summary>a dimension, either 'x', 'y', or 'z'</summary><p>Enum cases:</p><ul><li>x (<code>x</code>)</li><li>y (<code>y</code>)</li><li>z (<code>z</code>)</li></ul></details></td></tr></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>index</td></tr></tbody></table><h3 id=gpucluster_id-gpuclusteridop><code>gpu.cluster_id</code> (gpu::ClusterIdOp)&nbsp;<a class=headline-hash href=#gpucluster_id-gpuclusteridop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.cluster_id` $dimension attr-dict
</code></pre><p>Returns the cluster id, i.e. the index of the current cluster within the
grid along the x, y, or z <code>dimension</code>.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%cIdY</span> <span class=p>=</span> gpu<span class=p>.</span>cluster_id y
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, InferIntRangeInterface, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-6>Attributes:&nbsp;<a class=headline-hash href=#attributes-6>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dimension</code></td><td>::mlir::gpu::DimensionAttr</td><td><details><summary>a dimension, either 'x', 'y', or 'z'</summary><p>Enum cases:</p><ul><li>x (<code>x</code>)</li><li>y (<code>y</code>)</li><li>z (<code>z</code>)</li></ul></details></td></tr></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>index</td></tr></tbody></table><h3 id=gpucreate_2to4_spmat-gpucreate2to4spmatop><code>gpu.create_2to4_spmat</code> (gpu::Create2To4SpMatOp)&nbsp;<a class=headline-hash href=#gpucreate_2to4_spmat-gpucreate2to4spmatop>¶</a></h3><p><em>Create sparse matrix with 2:4 sparsity operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.create_2to4_spmat` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              `{` $pruneFlag `}` $rows `,` $cols `,` $memref attr-dict `:` type($memref)
</code></pre><p>The <code>gpu.create_2to4_spmat</code> operation initializes a sparse matrix in dense
format with 2:4 sparsity.
The buffers must already be copied from the host to the device prior to
using this operation. The operation returns a handle to the sparse
matrix descriptor.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a !gpu.async.token in addition to the environment.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%spmat</span><span class=p>,</span> <span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>create_2to4_spmat async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span> <span class=p>{</span>PRUNE_AND_CHECK<span class=p>}</span> <span class=nv>%rows</span><span class=p>,</span> <span class=nv>%cols</span><span class=p>,</span> <span class=nv>%mem</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f64</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: GPU_AsyncOpInterface</p><h4 id=attributes-7>Attributes:&nbsp;<a class=headline-hash href=#attributes-7>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>pruneFlag</code></td><td>::mlir::gpu::Prune2To4SpMatFlagAttr</td><td><details><summary>pruning strategy for 2:4 sparse matrix</summary><p>Enum cases:</p><ul><li>NONE (<code>NONE</code>)</li><li>PRUNE_ONLY (<code>PRUNE_ONLY</code>)</li><li>PRUNE_AND_CHECK (<code>PRUNE_AND_CHECK</code>)</li></ul></details></td></tr></table><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>rows</code></td><td>index</td></tr><tr><td style=text-align:center><code>cols</code></td><td>index</td></tr><tr><td style=text-align:center><code>memref</code></td><td>memref of any type values</td></tr></tbody></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>spMat</code></td><td>sparse matrix handle type</td></tr><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpucreate_bsr-gpucreatebsrop><code>gpu.create_bsr</code> (gpu::CreateBsrOp)&nbsp;<a class=headline-hash href=#gpucreate_bsr-gpucreatebsrop>¶</a></h3><p><em>Create sparse matrix in BSR format operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.create_bsr` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              $brows `,` $bcols `,` $bnnz `,` $rBlockSize `,` $cBlockSize `,`
              $bRowPos `,` $bColIdxs `,` $values attr-dict
              `:` type($bRowPos) `,` type($bColIdxs) `,` type($values)
</code></pre><p>The <code>gpu.create_bsr</code> operation initializes a sparse matrix in BSR format
with the given sizes for the matrix and blocks from the given position,
index, and values buffers. The buffers must already be copied from the
host to the device prior to using this operation. The operation returns
a handle to the sparse matrix descriptor.</p><p>The BSR format is similar to CSR, where the column indices represent
two-dimensional blocks instead of a single matrix entry. Note that this
operation (currently) only supports storage with <strong>square</strong> blocks,
i.e., <code>rBlockSize == cBlockSize</code>.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a !gpu.async.token in addition to the environment.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%spmat</span><span class=p>,</span> <span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>create_bsr async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span>
</span></span><span class=line><span class=cl>   <span class=nv>%brows</span><span class=p>,</span> <span class=nv>%bcols</span><span class=p>,</span> <span class=nv>%bnnz</span><span class=p>,</span> <span class=nv>%rBlockSize</span><span class=p>,</span> <span class=nv>%cBlockSize</span><span class=p>,</span>
</span></span><span class=line><span class=cl>   <span class=nv>%bRowPos</span><span class=p>,</span> <span class=nv>%bColIdxs</span><span class=p>,</span> <span class=nv>%values</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>index</span><span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>index</span><span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f64</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: GPU_AsyncOpInterface</p><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>brows</code></td><td>index</td></tr><tr><td style=text-align:center><code>bcols</code></td><td>index</td></tr><tr><td style=text-align:center><code>bnnz</code></td><td>index</td></tr><tr><td style=text-align:center><code>rBlockSize</code></td><td>index</td></tr><tr><td style=text-align:center><code>cBlockSize</code></td><td>index</td></tr><tr><td style=text-align:center><code>bRowPos</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>bColIdxs</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>values</code></td><td>memref of any type values</td></tr></tbody></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>spmat</code></td><td>sparse matrix handle type</td></tr><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpucreate_coo_aos-gpucreatecooaosop><code>gpu.create_coo_aos</code> (gpu::CreateCooAoSOp)&nbsp;<a class=headline-hash href=#gpucreate_coo_aos-gpucreatecooaosop>¶</a></h3><p><em>Create sparse matrix in COO format operation (AoS)</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.create_coo_aos` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              $rows `,` $cols `,` $nnz `,` $idxs `,` $values attr-dict
              `:` type($idxs) `,` type($values)
</code></pre><p>The <code>gpu.create_coo_aos</code> operation initializes a sparse matrix in COO format
with the given sizes from the given index and values buffers. The buffers
must already be copied from the host to the device prior to using this
operation. The operation returns a handle to the sparse matrix descriptor.
Unlike the default <code>gpu.create_coo</code> operation, this operation builds the
COO format from a single index buffer in AoS format (note that this
feature has been deprecated in cuSparse 11.2).</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a !gpu.async.token in addition to the environment.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%spmat</span><span class=p>,</span> <span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>create_coo_aos async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span> <span class=nv>%rows</span><span class=p>,</span> <span class=nv>%cols</span><span class=p>,</span> <span class=nv>%nnz</span><span class=p>,</span> <span class=nv>%idxs</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nv>%values</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>index</span><span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f64</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: GPU_AsyncOpInterface</p><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>rows</code></td><td>index</td></tr><tr><td style=text-align:center><code>cols</code></td><td>index</td></tr><tr><td style=text-align:center><code>nnz</code></td><td>index</td></tr><tr><td style=text-align:center><code>idxs</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>values</code></td><td>memref of any type values</td></tr></tbody></table><h4 id=results-8>Results:&nbsp;<a class=headline-hash href=#results-8>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>spmat</code></td><td>sparse matrix handle type</td></tr><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpucreate_coo-gpucreatecooop><code>gpu.create_coo</code> (gpu::CreateCooOp)&nbsp;<a class=headline-hash href=#gpucreate_coo-gpucreatecooop>¶</a></h3><p><em>Create sparse matrix in COO format operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.create_coo` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              $rows `,` $cols `,` $nnz `,` $rowIdxs `,` $colIdxs `,` $values attr-dict
              `:` type($rowIdxs) `,` type($colIdxs) `,` type($values)
</code></pre><p>The <code>gpu.create_coo</code> operation initializes a sparse matrix in COO format
with the given sizes from the given index and values buffers. The buffers
must already be copied from the host to the device prior to using this
operation. The operation returns a handle to the sparse matrix descriptor.
Note that this operation builds the COO in SoA format.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a !gpu.async.token in addition to the environment.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%spmat</span><span class=p>,</span> <span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>create_coo async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span> <span class=nv>%rows</span><span class=p>,</span> <span class=nv>%cols</span><span class=p>,</span> <span class=nv>%nnz</span><span class=p>,</span> <span class=nv>%rowIdx</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nv>%colIdx</span><span class=p>,</span> <span class=nv>%values</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>index</span><span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>index</span><span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f64</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: GPU_AsyncOpInterface</p><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>rows</code></td><td>index</td></tr><tr><td style=text-align:center><code>cols</code></td><td>index</td></tr><tr><td style=text-align:center><code>nnz</code></td><td>index</td></tr><tr><td style=text-align:center><code>rowIdxs</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>colIdxs</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>values</code></td><td>memref of any type values</td></tr></tbody></table><h4 id=results-9>Results:&nbsp;<a class=headline-hash href=#results-9>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>spmat</code></td><td>sparse matrix handle type</td></tr><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpucreate_csc-gpucreatecscop><code>gpu.create_csc</code> (gpu::CreateCscOp)&nbsp;<a class=headline-hash href=#gpucreate_csc-gpucreatecscop>¶</a></h3><p><em>Create sparse matrix in CSC format operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.create_csc` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              $rows `,` $cols `,` $nnz `,` $colPos `,` $rowIdxs `,` $values attr-dict
              `:` type($colPos) `,` type($rowIdxs) `,` type($values)
</code></pre><p>The <code>gpu.create_csc</code> operation initializes a sparse matrix in CSC format
with the given sizes from the given position, index, and values buffers.
The buffers must already be copied from the host to the device prior to
using this operation. The operation returns a handle to the sparse
matrix descriptor.</p><p>The CSC format has exactly the same memory layout as its transpose
in CSR format (and vice versa).</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a !gpu.async.token in addition to the environment.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%spmat</span><span class=p>,</span> <span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>create_csc async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span> <span class=nv>%rows</span><span class=p>,</span> <span class=nv>%cols</span><span class=p>,</span> <span class=nv>%nnz</span><span class=p>,</span> <span class=nv>%colPos</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nv>%rowIdx</span><span class=p>,</span> <span class=nv>%values</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>index</span><span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>index</span><span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f64</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: GPU_AsyncOpInterface</p><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>rows</code></td><td>index</td></tr><tr><td style=text-align:center><code>cols</code></td><td>index</td></tr><tr><td style=text-align:center><code>nnz</code></td><td>index</td></tr><tr><td style=text-align:center><code>colPos</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>rowIdxs</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>values</code></td><td>memref of any type values</td></tr></tbody></table><h4 id=results-10>Results:&nbsp;<a class=headline-hash href=#results-10>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>spmat</code></td><td>sparse matrix handle type</td></tr><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpucreate_csr-gpucreatecsrop><code>gpu.create_csr</code> (gpu::CreateCsrOp)&nbsp;<a class=headline-hash href=#gpucreate_csr-gpucreatecsrop>¶</a></h3><p><em>Create sparse matrix in CSR format operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.create_csr` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              $rows `,` $cols `,` $nnz `,` $rowPos `,` $colIdxs `,` $values attr-dict
              `:` type($rowPos) `,` type($colIdxs) `,` type($values)
</code></pre><p>The <code>gpu.create_csr</code> operation initializes a sparse matrix in CSR format
with the given sizes from the given position, index, and values buffers.
The buffers must already be copied from the host to the device prior to
using this operation. The operation returns a handle to the sparse
matrix descriptor.</p><p>The CSR format has exactly the same memory layout as its transpose
in CSC format (and vice versa).</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a !gpu.async.token in addition to the environment.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%spmat</span><span class=p>,</span> <span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>create_csr async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span> <span class=nv>%rows</span><span class=p>,</span> <span class=nv>%cols</span><span class=p>,</span> <span class=nv>%nnz</span><span class=p>,</span> <span class=nv>%rowPos</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nv>%colIdx</span><span class=p>,</span> <span class=nv>%values</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>index</span><span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>index</span><span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f64</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: GPU_AsyncOpInterface</p><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>rows</code></td><td>index</td></tr><tr><td style=text-align:center><code>cols</code></td><td>index</td></tr><tr><td style=text-align:center><code>nnz</code></td><td>index</td></tr><tr><td style=text-align:center><code>rowPos</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>colIdxs</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>values</code></td><td>memref of any type values</td></tr></tbody></table><h4 id=results-11>Results:&nbsp;<a class=headline-hash href=#results-11>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>spmat</code></td><td>sparse matrix handle type</td></tr><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpucreate_dn_tensor-gpucreatedntensorop><code>gpu.create_dn_tensor</code> (gpu::CreateDnTensorOp)&nbsp;<a class=headline-hash href=#gpucreate_dn_tensor-gpucreatedntensorop>¶</a></h3><p><em>Create dense tensor operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.create_dn_tensor` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              $memref `,` $dims attr-dict `:` type($dims) `into` type($memref)
</code></pre><p>The <code>gpu.create_dn_tensor</code> operation initializes a dense tensor from
the given values buffer and sizes. The buffer must already be copied
from the host to the device prior to using this operation. The
operation returns a handle to the dense tensor descriptor.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a !gpu.async.token in addition to the environment.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%dmat</span><span class=p>,</span> <span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>create_dn_tensor async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span> <span class=nv>%mem</span><span class=p>,</span> <span class=nv>%dims</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span> <span class=k>index</span> into <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f64</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: AttrSizedOperandSegments</p><p>Interfaces: GPU_AsyncOpInterface</p><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>memref</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>dims</code></td><td>variadic of index</td></tr></tbody></table><h4 id=results-12>Results:&nbsp;<a class=headline-hash href=#results-12>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dnTensor</code></td><td>dense tensor handle type</td></tr><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpudealloc-gpudeallocop><code>gpu.dealloc</code> (gpu::DeallocOp)&nbsp;<a class=headline-hash href=#gpudealloc-gpudeallocop>¶</a></h3><p><em>GPU memory deallocation operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.dealloc` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              $memref attr-dict `:` type($memref)
</code></pre><p>The <code>gpu.dealloc</code> operation frees the region of memory referenced by a
memref which was originally created by the <code>gpu.alloc</code> operation. It is
similar to the <code>memref.dealloc</code> op, but supports asynchronous GPU execution.</p><p>The op does not execute before all async dependencies have finished
executing.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a !gpu.async.token.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>dealloc async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span> <span class=nv>%memref</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>8x64x</span><span class=k>f32</span><span class=p>,</span> <span class=m>1</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: GPU_AsyncOpInterface</p><h4 id=operands-9>Operands:&nbsp;<a class=headline-hash href=#operands-9>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>memref</code></td><td>memref of any type values</td></tr></tbody></table><h4 id=results-13>Results:&nbsp;<a class=headline-hash href=#results-13>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpudestroy_dn_tensor-gpudestroydntensorop><code>gpu.destroy_dn_tensor</code> (gpu::DestroyDnTensorOp)&nbsp;<a class=headline-hash href=#gpudestroy_dn_tensor-gpudestroydntensorop>¶</a></h3><p><em>Destroy dense tensor operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.destroy_dn_tensor` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              $dnTensor attr-dict
</code></pre><p>The <code>gpu.destroy_dn_tensor</code> operation releases all resources of a dense
tensor represented by a handle that was previously created by a
<code>gpu.create_dn_tensor</code> operation.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a !gpu.async.token in addition to the environment.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>destroy_dn_tensor async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span> <span class=nv>%dnTensor</span>
</span></span></code></pre></div><p>Interfaces: GPU_AsyncOpInterface</p><h4 id=operands-10>Operands:&nbsp;<a class=headline-hash href=#operands-10>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>dnTensor</code></td><td>dense tensor handle type</td></tr></tbody></table><h4 id=results-14>Results:&nbsp;<a class=headline-hash href=#results-14>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpudestroy_sp_mat-gpudestroyspmatop><code>gpu.destroy_sp_mat</code> (gpu::DestroySpMatOp)&nbsp;<a class=headline-hash href=#gpudestroy_sp_mat-gpudestroyspmatop>¶</a></h3><p><em>Destroy sparse matrix operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.destroy_sp_mat` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies) $spmat attr-dict
</code></pre><p>The <code>gpu.destroy_sp_mat</code> operation releases all resources of a sparse
matrix represented by a handle that was previously created by a
one of the sparse matrix creation operations.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a !gpu.async.token in addition to the environment.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>destroy_sp_mat async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span> <span class=nv>%spmat</span>
</span></span></code></pre></div><p>Interfaces: GPU_AsyncOpInterface</p><h4 id=operands-11>Operands:&nbsp;<a class=headline-hash href=#operands-11>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>spmat</code></td><td>sparse matrix handle type</td></tr></tbody></table><h4 id=results-15>Results:&nbsp;<a class=headline-hash href=#results-15>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpudynamic_shared_memory-gpudynamicsharedmemoryop><code>gpu.dynamic_shared_memory</code> (gpu::DynamicSharedMemoryOp)&nbsp;<a class=headline-hash href=#gpudynamic_shared_memory-gpudynamicsharedmemoryop>¶</a></h3><p><em>Get the memref for dynamic shared memory</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.dynamic_shared_memory` attr-dict `:` type($resultMemref)
</code></pre><p>This operation provides a memref pointer to the start of dynamic shared
memory, often referred to as workgroup memory. It&rsquo;s important to note that
this dynamic shared memory needs to be allocated at kernel launch. One can
conveniently utilize <code>the dynamic_shared_memory_size</code> parameter of
<code>gpu.launch</code> for this purpose.</p><p>Examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> gpu<span class=p>.</span>dynamic<span class=p>.</span>shared<span class=p>.</span>memory <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>i8</span><span class=p>,</span> <span class=nv>#gpu.address_space</span><span class=p>&lt;</span>workgroup<span class=p>&gt;&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>view <span class=nv>%0</span><span class=p>[</span><span class=nv>%c8192</span><span class=p>][]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>i8</span><span class=p>,</span> <span class=nv>#gpu.address_space</span><span class=p>&lt;</span>workgroup<span class=p>&gt;&gt;</span> 
</span></span><span class=line><span class=cl>                        to <span class=kt>memref</span><span class=p>&lt;</span><span class=m>32x64x</span><span class=k>f32</span><span class=p>,</span> <span class=nv>#gpu.address_space</span><span class=p>&lt;</span>workgroup<span class=p>&gt;&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>view <span class=nv>%0</span><span class=p>[</span><span class=nv>%c16384</span><span class=p>][]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>i8</span><span class=p>,</span> <span class=nv>#gpu.address_space</span><span class=p>&lt;</span>workgroup<span class=p>&gt;&gt;</span> 
</span></span><span class=line><span class=cl>                        to <span class=kt>memref</span><span class=p>&lt;</span><span class=m>32x64x</span><span class=k>f32</span><span class=p>,</span> <span class=nv>#gpu.address_space</span><span class=p>&lt;</span>workgroup<span class=p>&gt;&gt;</span>
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=results-16>Results:&nbsp;<a class=headline-hash href=#results-16>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>resultMemref</code></td><td>1D memref of 8-bit signless integer values</td></tr></tbody></table><h3 id=gpufunc-gpugpufuncop><code>gpu.func</code> (gpu::GPUFuncOp)&nbsp;<a class=headline-hash href=#gpufunc-gpugpufuncop>¶</a></h3><p><em>Function executable on a GPU</em></p><p>Defines a function that can be executed on a GPU. This supports memory
attribution and its body has a particular execution model.</p><p>GPU functions are either kernels (as indicated by the <code>kernel</code> attribute) or
regular functions. The former can be launched from the host side, while the
latter are device side only.</p><p>The memory attribution defines SSA values that correspond to memory buffers
allocated in the memory hierarchy of the GPU (see below).</p><p>The operation has one attached region that corresponds to the body of the
function. The region arguments consist of the function arguments without
modification, followed by buffers defined in memory annotations. The body of
a GPU function, when launched, is executed by multiple work items. There are
no guarantees on the order in which work items execute, or on the connection
between them. In particular, work items are not necessarily executed in
lock-step. Synchronization ops such as &ldquo;gpu.barrier&rdquo; should be used to
coordinate work items. Declarations of GPU functions, i.e. not having the
body region, are not supported.</p><p>A function may optionally be annotated with the block and/or grid sizes
that will be used when it is launched using the <code>gpu.known_block_size</code> and
<code>gpu.known_grid_size</code> attributes, respectively. If set, these attributes must
be arrays of three 32-bit integers giving the x, y, and z launch dimensions.
Launching a kernel that has these annotations, or that calls a function with
these annotations, using a block size or grid size other than what is specified
is undefined behavior.</p><p>Syntax:</p><pre tabindex=0><code>op ::= `gpu.func` symbol-ref-id `(` argument-list `)` (`-&gt;`
function-result-list)?
       memory-attribution `kernel`? function-attributes? region

memory-attribution ::= (`workgroup` `(` ssa-id-and-type-list `)`)?
                       (`private` `(` ssa-id-and-type-list `)`)?
</code></pre><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>gpu<span class=p>.</span><span class=kt>func</span> <span class=nf>@foo</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=k>index</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    workgroup<span class=p>(</span><span class=nv>%workgroup</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>32x</span><span class=k>f32</span><span class=p>,</span> <span class=m>3</span><span class=p>&gt;)</span>
</span></span><span class=line><span class=cl>    private<span class=p>(</span><span class=nv>%private</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>1x</span><span class=k>f32</span><span class=p>,</span> <span class=m>5</span><span class=p>&gt;)</span>
</span></span><span class=line><span class=cl>    kernel
</span></span><span class=line><span class=cl>    attributes <span class=p>{</span>qux<span class=p>:</span> <span class=s>&#34;quux&#34;</span><span class=p>}</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  gpu<span class=p>.</span><span class=kt>return</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The generic form illustrates the concept</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=s>&#34;gpu.func&#34;</span><span class=p>(</span><span class=nv>%arg</span><span class=p>:</span> <span class=k>index</span><span class=p>)</span> <span class=p>{</span>sym_name<span class=p>:</span> <span class=s>&#34;foo&#34;</span><span class=p>,</span> kernel<span class=p>,</span> qux<span class=p>:</span> <span class=s>&#34;quux&#34;</span><span class=p>}</span> <span class=p>({</span>
</span></span><span class=line><span class=cl><span class=nl>^bb0</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=k>index</span><span class=p>,</span> <span class=nv>%workgroup</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>32x</span><span class=k>f32</span><span class=p>,</span> <span class=m>3</span><span class=p>&gt;,</span>
</span></span><span class=line><span class=cl>     <span class=nv>%private</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>1x</span><span class=k>f32</span><span class=p>,</span> <span class=m>5</span><span class=p>&gt;):</span>
</span></span><span class=line><span class=cl>  <span class=s>&#34;gpu.return&#34;</span><span class=p>()</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>})</span> <span class=p>:</span> <span class=p>(</span><span class=k>index</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span>
</span></span></code></pre></div><p>Note the non-default memory spaces used in memref types in memory
attribution.</p><p>Traits: AutomaticAllocationScope, HasParent<gpumoduleop>, IsolatedFromAbove</p><p>Interfaces: CallableOpInterface, FunctionOpInterface, Symbol</p><h4 id=attributes-8>Attributes:&nbsp;<a class=headline-hash href=#attributes-8>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>function_type</code></td><td>::mlir::TypeAttr</td><td>type attribute of function type</td></tr><tr><td><code>arg_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr><tr><td><code>res_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr><tr><td><code>workgroup_attrib_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr><tr><td><code>private_attrib_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr></table><h3 id=gpumodule-gpugpumoduleop><code>gpu.module</code> (gpu::GPUModuleOp)&nbsp;<a class=headline-hash href=#gpumodule-gpugpumoduleop>¶</a></h3><p><em>A top level compilation unit containing code to be run on a GPU.</em></p><p>GPU module contains code that is intended to be run on a GPU. A host device
can launch this code through a gpu.launc_func that creates a fully
qualified symbol through the gpu.module&rsquo;s symbol and a gpu.func symbol
contained in the gpu.module.</p><p>The module&rsquo;s top-level scope is modeled by a single region with a single
block. GPU modules are required to have a name that is used for symbol
resolution by the gpu.launch_func operation.</p><p>Using an op with a region to define a GPU module enables &ldquo;embedding&rdquo; GPU
modules with SIMT execution models in other dialects in a clean manner and
allows filtering of code regions to execute passes on only code intended to
or not intended to be run on the separate device.</p><p>Modules can contain zero or more target attributes. These attributes encode
how to transform modules into binary strings and are used by the
<code>gpu-module-to-binary</code> pass to transform modules into GPU binaries.</p><pre tabindex=0><code>gpu.module @symbol_name {
  gpu.func {}
    ...
  gpu.module_end
}
gpu.module @symbol_name2 [#nvvm.target, #rocdl.target&lt;chip = &#34;gfx90a&#34;&gt;] {
  gpu.func {}
    ...
  gpu.module_end
}
</code></pre><p>Traits: HasDefaultDLTIDataLayout, IsolatedFromAbove, SingleBlock, SingleBlockImplicitTerminator<moduleendop>, SymbolTable</p><p>Interfaces: DataLayoutOpInterface, Symbol</p><h4 id=attributes-9>Attributes:&nbsp;<a class=headline-hash href=#attributes-9>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>targets</code></td><td>::mlir::ArrayAttr</td><td>array of GPU target attributes with at least 1 elements</td></tr></table><h3 id=gpuglobal_id-gpuglobalidop><code>gpu.global_id</code> (gpu::GlobalIdOp)&nbsp;<a class=headline-hash href=#gpuglobal_id-gpuglobalidop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.global_id` $dimension attr-dict
</code></pre><p>Returns the unique global workitem/thread id, i.e., the unique index of the
current workitem/thread within all workgroups / grid along the x, y, or z
<code>dimension</code>.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%gidX</span> <span class=p>=</span> gpu<span class=p>.</span>global_id <span class=p>x</span>
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, InferIntRangeInterface, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-10>Attributes:&nbsp;<a class=headline-hash href=#attributes-10>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dimension</code></td><td>::mlir::gpu::DimensionAttr</td><td><details><summary>a dimension, either 'x', 'y', or 'z'</summary><p>Enum cases:</p><ul><li>x (<code>x</code>)</li><li>y (<code>y</code>)</li><li>z (<code>z</code>)</li></ul></details></td></tr></table><h4 id=results-17>Results:&nbsp;<a class=headline-hash href=#results-17>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>index</td></tr></tbody></table><h3 id=gpugrid_dim-gpugriddimop><code>gpu.grid_dim</code> (gpu::GridDimOp)&nbsp;<a class=headline-hash href=#gpugrid_dim-gpugriddimop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.grid_dim` $dimension attr-dict
</code></pre><p>Returns the number of thread blocks in the grid along the x, y, or z
<code>dimension</code>.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%gDimZ</span> <span class=p>=</span> gpu<span class=p>.</span>grid_dim z
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, InferIntRangeInterface, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-11>Attributes:&nbsp;<a class=headline-hash href=#attributes-11>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dimension</code></td><td>::mlir::gpu::DimensionAttr</td><td><details><summary>a dimension, either 'x', 'y', or 'z'</summary><p>Enum cases:</p><ul><li>x (<code>x</code>)</li><li>y (<code>y</code>)</li><li>z (<code>z</code>)</li></ul></details></td></tr></table><h4 id=results-18>Results:&nbsp;<a class=headline-hash href=#results-18>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>index</td></tr></tbody></table><h3 id=gpuhost_register-gpuhostregisterop><code>gpu.host_register</code> (gpu::HostRegisterOp)&nbsp;<a class=headline-hash href=#gpuhost_register-gpuhostregisterop>¶</a></h3><p><em>Registers a memref for access from device.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.host_register` $value attr-dict `:` type($value)
</code></pre><p>This op maps the provided host buffer into the device address space.</p><p>This operation may not be supported in every environment, there is not yet a
way to check at runtime whether this feature is supported.</p><p>Writes from the host are guaranteed to be visible to device kernels that are
launched afterwards. Writes from the device are guaranteed to be visible on
the host after synchronizing with the device kernel completion.</p><h4 id=operands-12>Operands:&nbsp;<a class=headline-hash href=#operands-12>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>unranked.memref of any type values</td></tr></tbody></table><h3 id=gpuhost_unregister-gpuhostunregisterop><code>gpu.host_unregister</code> (gpu::HostUnregisterOp)&nbsp;<a class=headline-hash href=#gpuhost_unregister-gpuhostunregisterop>¶</a></h3><p><em>Unregisters a memref for access from device.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.host_unregister` $value attr-dict `:` type($value)
</code></pre><p>This op unmaps the provided host buffer from the device address space.</p><p>This operation may not be supported in every environment, there is not yet a
way to check at runtime whether this feature is supported.</p><h4 id=operands-13>Operands:&nbsp;<a class=headline-hash href=#operands-13>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>unranked.memref of any type values</td></tr></tbody></table><h3 id=gpulane_id-gpulaneidop><code>gpu.lane_id</code> (gpu::LaneIdOp)&nbsp;<a class=headline-hash href=#gpulane_id-gpulaneidop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.lane_id` attr-dict
</code></pre><p>Returns the lane id within the subgroup (warp/wave).</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%laneId</span> <span class=p>=</span> gpu<span class=p>.</span>lane_id
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, InferIntRangeInterface, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=results-19>Results:&nbsp;<a class=headline-hash href=#results-19>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>index</td></tr></tbody></table><h3 id=gpulaunch_func-gpulaunchfuncop><code>gpu.launch_func</code> (gpu::LaunchFuncOp)&nbsp;<a class=headline-hash href=#gpulaunch_func-gpulaunchfuncop>¶</a></h3><p><em>Launches a function as a GPU kernel</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.launch_func` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              (`&lt;` $asyncObject^ `:` type($asyncObject) `&gt;`)?
              $kernel
              ( `clusters` `in` ` ` `(` $clusterSizeX^ `,` $clusterSizeY `,` $clusterSizeZ `)` )?
              `blocks` `in` ` ` `(` $gridSizeX `,` $gridSizeY `,` $gridSizeZ `)`
              `threads` `in` ` ` `(` $blockSizeX `,` $blockSizeY `,` $blockSizeZ `)`
              custom&lt;LaunchDimType&gt;(type($gridSizeX), ref($clusterSizeX), type($clusterSizeX), type($clusterSizeY), type($clusterSizeZ))
              (`dynamic_shared_memory_size` $dynamicSharedMemorySize^)?
              custom&lt;LaunchFuncOperands&gt;($kernelOperands, type($kernelOperands)) attr-dict
</code></pre><p>Launch a kernel function on the specified grid of thread blocks.
<code>gpu.launch</code> operations are lowered to <code>gpu.launch_func</code> operations by
outlining the kernel body into a function in a dedicated module, which
reflects the separate compilation process. The kernel function is required
to have the <code>gpu.kernel</code> attribute. The module containing the kernel
function is required to be a gpu.module. And finally, the module containing
the kernel module (which thus cannot be the top-level module) is required
to have the <code>gpu.container_module</code> attribute. The <code>gpu.launch_func</code>
operation has a symbol attribute named <code>kernel</code> to identify the fully
specified kernel function to launch (both the gpu.module and func).</p><p>The <code>gpu.launch_func</code> supports async dependencies: the kernel does not start
executing until the ops producing those async dependencies have completed.</p><p>By the default, the host implicitly blocks until kernel execution has
completed. If the <code>async</code> keyword is present, the host does not block but
instead a <code>!gpu.async.token</code> is returned. Other async GPU ops can take this
token as dependency.</p><p>The operation requires at least the grid and block sizes along the x,y,z
dimensions as arguments. When a lower-dimensional kernel is required,
unused sizes must be explicitly set to <code>1</code>.</p><p>The remaining operands are optional. The first optional operand corresponds
to the amount of dynamic shared memory a kernel&rsquo;s workgroup should be
allocated; when this operand is not present, a zero size is assumed.</p><p>The remaining operands if present are passed as arguments to the kernel
function.</p><p>The <code>gpu.launch_func</code> also supports kernel launching with clusters if
supported by the target architecture. The cluster size can be set by
<code>clusterSizeX</code>, <code>clusterSizeY</code>, and <code>clusterSizeZ</code> arguments. When these
arguments are present, the Op launches a kernel that clusters the given
thread blocks. This feature is exclusive to certain architectures.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>module attributes <span class=p>{</span>gpu<span class=p>.</span>container_module<span class=p>}</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c>// This module creates a separate compilation unit for the GPU compiler.
</span></span></span><span class=line><span class=cl><span class=c></span>  gpu<span class=p>.</span>module <span class=nf>@kernels</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>func</span><span class=p>.</span><span class=kt>func</span> <span class=nf>@kernel_1</span><span class=p>(</span><span class=nv>%arg0</span> <span class=p>:</span> <span class=k>f32</span><span class=p>,</span> <span class=nv>%arg1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>,</span> <span class=m>1</span><span class=p>&gt;)</span>
</span></span><span class=line><span class=cl>        attributes <span class=p>{</span> <span class=nl>nvvm.kernel =</span> true <span class=p>}</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=c>// Operations that produce block/thread IDs and dimensions are
</span></span></span><span class=line><span class=cl><span class=c></span>      <span class=c>// injected when outlining the `gpu.launch` body to a function called
</span></span></span><span class=line><span class=cl><span class=c></span>      <span class=c>// by `gpu.launch_func`.
</span></span></span><span class=line><span class=cl><span class=c></span>      <span class=nv>%tIdX</span> <span class=p>=</span> gpu<span class=p>.</span>thread_id <span class=p>x</span>
</span></span><span class=line><span class=cl>      <span class=nv>%tIdY</span> <span class=p>=</span> gpu<span class=p>.</span>thread_id y
</span></span><span class=line><span class=cl>      <span class=nv>%tIdZ</span> <span class=p>=</span> gpu<span class=p>.</span>thread_id z
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=nv>%bDimX</span> <span class=p>=</span> gpu<span class=p>.</span>block_dim <span class=p>x</span>
</span></span><span class=line><span class=cl>      <span class=nv>%bDimY</span> <span class=p>=</span> gpu<span class=p>.</span>block_dim y
</span></span><span class=line><span class=cl>      <span class=nv>%bDimZ</span> <span class=p>=</span> gpu<span class=p>.</span>block_dim z
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=nv>%bIdX</span> <span class=p>=</span> gpu<span class=p>.</span>block_id <span class=p>x</span>
</span></span><span class=line><span class=cl>      <span class=nv>%bIdY</span> <span class=p>=</span> gpu<span class=p>.</span>block_id y
</span></span><span class=line><span class=cl>      <span class=nv>%bIdZ</span> <span class=p>=</span> gpu<span class=p>.</span>block_id z
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=nv>%gDimX</span> <span class=p>=</span> gpu<span class=p>.</span>grid_dim <span class=p>x</span>
</span></span><span class=line><span class=cl>      <span class=nv>%gDimY</span> <span class=p>=</span> gpu<span class=p>.</span>grid_dim y
</span></span><span class=line><span class=cl>      <span class=nv>%gDimZ</span> <span class=p>=</span> gpu<span class=p>.</span>grid_dim z
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=c>// (Optional)  Cluster size only for support architectures
</span></span></span><span class=line><span class=cl><span class=c></span>      <span class=nv>%cIdX</span> <span class=p>=</span> gpu<span class=p>.</span>cluster_id <span class=p>x</span>
</span></span><span class=line><span class=cl>      <span class=nv>%cIdY</span> <span class=p>=</span> gpu<span class=p>.</span>cluster_id y
</span></span><span class=line><span class=cl>      <span class=nv>%cIdZ</span> <span class=p>=</span> gpu<span class=p>.</span>cluster_id z
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=nv>%cDimX</span> <span class=p>=</span> gpu<span class=p>.</span>cluster_dim <span class=p>x</span>
</span></span><span class=line><span class=cl>      <span class=nv>%cDimY</span> <span class=p>=</span> gpu<span class=p>.</span>cluster_dim y
</span></span><span class=line><span class=cl>      <span class=nv>%cDimZ</span> <span class=p>=</span> gpu<span class=p>.</span>cluster_dim z
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=s>&#34;some_op&#34;</span><span class=p>(</span><span class=nv>%bx</span><span class=p>,</span> <span class=nv>%tx</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>index</span><span class=p>,</span> <span class=k>index</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>      <span class=nv>%42</span> <span class=p>=</span> load <span class=nv>%arg1</span><span class=p>[</span><span class=nv>%bx</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>,</span> <span class=m>1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nv>%t0</span> <span class=p>=</span> gpu<span class=p>.</span>wait async
</span></span><span class=line><span class=cl>  gpu<span class=p>.</span>launch_func
</span></span><span class=line><span class=cl>      async                           <span class=c>// (Optional) Don&#39;t block host, return token.
</span></span></span><span class=line><span class=cl><span class=c></span>      <span class=p>[</span><span class=nv>%t0</span><span class=p>]</span>                           <span class=c>// (Optional) Execute only after %t0 has completed.
</span></span></span><span class=line><span class=cl><span class=c></span>      <span class=nf>@kernels</span><span class=p>::</span><span class=nf>@kernel_1</span>             <span class=c>// Kernel function.
</span></span></span><span class=line><span class=cl><span class=c></span>      clusters in <span class=p>(</span><span class=nv>%cst</span><span class=p>,</span> <span class=nv>%cst</span><span class=p>,</span> <span class=nv>%cst</span><span class=p>)</span>  <span class=c>// (Optional) Cluster size only for support architectures. 
</span></span></span><span class=line><span class=cl><span class=c></span>      blocks in <span class=p>(</span><span class=nv>%cst</span><span class=p>,</span> <span class=nv>%cst</span><span class=p>,</span> <span class=nv>%cst</span><span class=p>)</span>    <span class=c>// Grid size.
</span></span></span><span class=line><span class=cl><span class=c></span>      threads in <span class=p>(</span><span class=nv>%cst</span><span class=p>,</span> <span class=nv>%cst</span><span class=p>,</span> <span class=nv>%cst</span><span class=p>)</span>   <span class=c>// Block size.
</span></span></span><span class=line><span class=cl><span class=c></span>      dynamic_shared_memory_size <span class=nv>%s</span>   <span class=c>// (Optional) Amount of dynamic shared
</span></span></span><span class=line><span class=cl><span class=c></span>                                      <span class=c>// memory to allocate for a workgroup.
</span></span></span><span class=line><span class=cl><span class=c></span>      args<span class=p>(</span><span class=nv>%arg0</span> <span class=p>:</span> <span class=k>f32</span><span class=p>,</span>               <span class=c>// (Optional) Kernel arguments.
</span></span></span><span class=line><span class=cl><span class=c></span>           <span class=nv>%arg1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>,</span> <span class=m>1</span><span class=p>&gt;)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Traits: AttrSizedOperandSegments</p><p>Interfaces: GPU_AsyncOpInterface</p><h4 id=attributes-12>Attributes:&nbsp;<a class=headline-hash href=#attributes-12>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>kernel</code></td><td>::mlir::SymbolRefAttr</td><td>symbol reference attribute</td></tr></table><h4 id=operands-14>Operands:&nbsp;<a class=headline-hash href=#operands-14>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>gridSizeX</code></td><td>index or 32-bit signless integer or 64-bit signless integer</td></tr><tr><td style=text-align:center><code>gridSizeY</code></td><td>index or 32-bit signless integer or 64-bit signless integer</td></tr><tr><td style=text-align:center><code>gridSizeZ</code></td><td>index or 32-bit signless integer or 64-bit signless integer</td></tr><tr><td style=text-align:center><code>blockSizeX</code></td><td>index or 32-bit signless integer or 64-bit signless integer</td></tr><tr><td style=text-align:center><code>blockSizeY</code></td><td>index or 32-bit signless integer or 64-bit signless integer</td></tr><tr><td style=text-align:center><code>blockSizeZ</code></td><td>index or 32-bit signless integer or 64-bit signless integer</td></tr><tr><td style=text-align:center><code>clusterSizeX</code></td><td>index or 32-bit signless integer or 64-bit signless integer</td></tr><tr><td style=text-align:center><code>clusterSizeY</code></td><td>index or 32-bit signless integer or 64-bit signless integer</td></tr><tr><td style=text-align:center><code>clusterSizeZ</code></td><td>index or 32-bit signless integer or 64-bit signless integer</td></tr><tr><td style=text-align:center><code>dynamicSharedMemorySize</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>kernelOperands</code></td><td>variadic of any type</td></tr><tr><td style=text-align:center><code>asyncObject</code></td><td>any type</td></tr></tbody></table><h4 id=results-20>Results:&nbsp;<a class=headline-hash href=#results-20>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpulaunch-gpulaunchop><code>gpu.launch</code> (gpu::LaunchOp)&nbsp;<a class=headline-hash href=#gpulaunch-gpulaunchop>¶</a></h3><p><em>GPU kernel launch operation</em></p><p>Launch a kernel on the specified grid of thread blocks. The body of the
kernel is defined by the single region that this operation contains. The
operation takes an optional list of async dependencies followed by six
operands and an optional operand.</p><p>The <code>async</code> keyword indicates the kernel should be launched asynchronously;
the operation returns a new !gpu.async.token when the keyword is specified.
The kernel launched does not start executing until the ops producing its
async dependencies (optional operands) have completed.</p><p>The first three operands (following any async dependencies) are grid sizes
along the x,y,z dimensions and the following three are block sizes along the
x,y,z dimensions. When a lower-dimensional kernel is required, unused sizes
must be explicitly set to <code>1</code>. The last operand is optional and corresponds
to the amount of dynamic shared memory a kernel&rsquo;s workgroup should be
allocated; when this operand is not present, a zero size is assumed.</p><p>The body region has at least <em>twelve</em> arguments, grouped as follows:</p><ul><li>three arguments that contain block identifiers along x,y,z dimensions;</li><li>three arguments that contain thread identifiers along x,y,z dimensions;</li><li>operands of the <code>gpu.launch</code> operation as is (i.e. the operands for
grid and block sizes).</li><li>a variadic number of Workgroup memory attributions.</li><li>a variadic number of Private memory attributions.</li></ul><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.launch` (`async` (`[` ssa-id-list `]`)? )?
                         `block` `(` ssa-id-list `)` `in` ssa-reassignment
                         `threads` `(` ssa-id-list `)` `in` ssa-reassignment
                         (dynamic_shared_memory_size ssa-use)?
                         memory-attribution
                         region attr-dict?
ssa-reassignment ::= `(` ssa-id `=` ssa-use (`,` ssa-id `=` ssa-use)* `)`
memory-attribution ::= (`workgroup` `(` ssa-id-and-type-list `)`)?
                       (`private` `(` ssa-id-and-type-list `)`)?
</code></pre><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>gpu<span class=p>.</span>launch blocks<span class=p>(</span><span class=nv>%bx</span><span class=p>,</span> <span class=nv>%by</span><span class=p>,</span> <span class=nv>%bz</span><span class=p>)</span> in <span class=p>(</span><span class=nv>%sz_bx</span> <span class=p>=</span> <span class=nv>%0</span><span class=p>,</span> <span class=nv>%sz_by</span> <span class=p>=</span> <span class=nv>%1</span><span class=p>,</span> <span class=nv>%sz_bz</span> <span class=p>=</span> <span class=nv>%2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>           threads<span class=p>(</span><span class=nv>%tx</span><span class=p>,</span> <span class=nv>%ty</span><span class=p>,</span> <span class=nv>%tz</span><span class=p>)</span> in <span class=p>(</span><span class=nv>%sz_tx</span> <span class=p>=</span> <span class=nv>%3</span><span class=p>,</span> <span class=nv>%sz_ty</span> <span class=p>=</span> <span class=nv>%4</span><span class=p>,</span> <span class=nv>%sz_tz</span> <span class=p>=</span> <span class=nv>%5</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c>// Block and thread identifiers, as well as block/grid sizes are
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>// immediately usable inside body region.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=s>&#34;some_op&#34;</span><span class=p>(</span><span class=nv>%bx</span><span class=p>,</span> <span class=nv>%tx</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>index</span><span class=p>,</span> <span class=k>index</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=c>// Assuming %val1 is defined outside the gpu.launch region.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=nv>%42</span> <span class=p>=</span> load <span class=nv>%val1</span><span class=p>[</span><span class=nv>%bx</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>,</span> <span class=m>1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Generic syntax explains how the pretty syntax maps to the IR structure.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=s>&#34;gpu.launch&#34;</span><span class=p>(</span><span class=nv>%cst</span><span class=p>,</span> <span class=nv>%cst</span><span class=p>,</span> <span class=nv>%c1</span><span class=p>,</span>  <span class=c>// Grid sizes.
</span></span></span><span class=line><span class=cl><span class=c></span>             <span class=nv>%cst</span><span class=p>,</span> <span class=nv>%c1</span><span class=p>,</span> <span class=nv>%c1</span><span class=p>)</span>   <span class=c>// Block sizes.
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl>    <span class=p>{</span><span class=err>/</span><span class=p>*</span>attributes<span class=p>*</span><span class=err>/</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c>// All sizes and identifiers have &#34;index&#34; size.
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=p>:</span> <span class=p>(</span><span class=k>index</span><span class=p>,</span> <span class=k>index</span><span class=p>,</span> <span class=k>index</span><span class=p>,</span> <span class=k>index</span><span class=p>,</span> <span class=k>index</span><span class=p>,</span> <span class=k>index</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=c>// The operation passes block and thread identifiers, followed by grid and
</span></span></span><span class=line><span class=cl><span class=c>// block sizes.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nl>^bb0</span><span class=p>(</span><span class=nv>%bx</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span> <span class=nv>%by</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span> <span class=nv>%bz</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span>
</span></span><span class=line><span class=cl>     <span class=nv>%tx</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span> <span class=nv>%ty</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span> <span class=nv>%tz</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span>
</span></span><span class=line><span class=cl>     <span class=nv>%num_bx</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span> <span class=nv>%num_by</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span> <span class=nv>%num_bz</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span>
</span></span><span class=line><span class=cl>     <span class=nv>%num_tx</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span> <span class=nv>%num_ty</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span> <span class=nv>%num_tz</span> <span class=p>:</span> <span class=k>index</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=s>&#34;some_op&#34;</span><span class=p>(</span><span class=nv>%bx</span><span class=p>,</span> <span class=nv>%tx</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>index</span><span class=p>,</span> <span class=k>index</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=nv>%3</span> <span class=p>=</span> <span class=s>&#34;memref.load&#34;</span><span class=p>(</span><span class=nv>%val1</span><span class=p>,</span> <span class=nv>%bx</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>,</span> <span class=m>1</span><span class=p>&gt;,</span> <span class=k>index</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Launch with memory attributions.
</span></span></span><span class=line><span class=cl><span class=c></span>gpu<span class=p>.</span>launch blocks<span class=p>(</span><span class=nv>%bx</span><span class=p>,</span> <span class=nv>%by</span><span class=p>,</span> <span class=nv>%bz</span><span class=p>)</span> in <span class=p>(</span><span class=nv>%sz_bx</span> <span class=p>=</span> <span class=nv>%0</span><span class=p>,</span> <span class=nv>%sz_by</span> <span class=p>=</span> <span class=nv>%1</span><span class=p>,</span> <span class=nv>%sz_bz</span> <span class=p>=</span> <span class=nv>%2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>           threads<span class=p>(</span><span class=nv>%tx</span><span class=p>,</span> <span class=nv>%ty</span><span class=p>,</span> <span class=nv>%tz</span><span class=p>)</span> in <span class=p>(</span><span class=nv>%sz_tx</span> <span class=p>=</span> <span class=nv>%3</span><span class=p>,</span> <span class=nv>%sz_ty</span> <span class=p>=</span> <span class=nv>%4</span><span class=p>,</span> <span class=nv>%sz_tz</span> <span class=p>=</span> <span class=nv>%5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>           workgroup<span class=p>(</span><span class=nv>%workgroup</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>32x</span><span class=k>f32</span><span class=p>,</span> <span class=m>3</span><span class=p>&gt;)</span>
</span></span><span class=line><span class=cl>           private<span class=p>(</span><span class=nv>%private</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>1x</span><span class=k>f32</span><span class=p>,</span> <span class=m>5</span><span class=p>&gt;)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c>// Block and thread identifiers, as well as block/grid sizes are
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>// immediately usable inside body region.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=s>&#34;some_op&#34;</span><span class=p>(</span><span class=nv>%bx</span><span class=p>,</span> <span class=nv>%tx</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>index</span><span class=p>,</span> <span class=k>index</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=c>// Assuming %val1 is defined outside the gpu.launch region.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=nv>%42</span> <span class=p>=</span> load <span class=nv>%workgroup</span><span class=p>[</span><span class=nv>%bx</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>32x</span><span class=k>f32</span><span class=p>,</span> <span class=m>3</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Rationale: using operation/block arguments gives analyses a clear way of
understanding that a value has additional semantics (e.g., we will need to
know what value corresponds to threadIdx.x for coalescing). We can recover
these properties by analyzing the operations producing values, but it is
easier just to have that information by construction.</p><p>Traits: AttrSizedOperandSegments, AutomaticAllocationScope</p><p>Interfaces: GPU_AsyncOpInterface, InferIntRangeInterface</p><h4 id=operands-15>Operands:&nbsp;<a class=headline-hash href=#operands-15>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>gridSizeX</code></td><td>index</td></tr><tr><td style=text-align:center><code>gridSizeY</code></td><td>index</td></tr><tr><td style=text-align:center><code>gridSizeZ</code></td><td>index</td></tr><tr><td style=text-align:center><code>blockSizeX</code></td><td>index</td></tr><tr><td style=text-align:center><code>blockSizeY</code></td><td>index</td></tr><tr><td style=text-align:center><code>blockSizeZ</code></td><td>index</td></tr><tr><td style=text-align:center><code>dynamicSharedMemorySize</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-21>Results:&nbsp;<a class=headline-hash href=#results-21>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpumemcpy-gpumemcpyop><code>gpu.memcpy</code> (gpu::MemcpyOp)&nbsp;<a class=headline-hash href=#gpumemcpy-gpumemcpyop>¶</a></h3><p><em>GPU memcpy operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.memcpy` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              $dst`,` $src `:` type($dst)`,` type($src) attr-dict
</code></pre><p>The <code>gpu.memcpy</code> operation copies the content of one memref to another.</p><p>The op does not execute before all async dependencies have finished
executing.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a !gpu.async.token.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>memcpy async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span> <span class=nv>%dst</span><span class=p>,</span> <span class=nv>%src</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>,</span> <span class=m>1</span><span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: GPU_AsyncOpInterface</p><h4 id=operands-16>Operands:&nbsp;<a class=headline-hash href=#operands-16>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>dst</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>src</code></td><td>memref of any type values</td></tr></tbody></table><h4 id=results-22>Results:&nbsp;<a class=headline-hash href=#results-22>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpumemset-gpumemsetop><code>gpu.memset</code> (gpu::MemsetOp)&nbsp;<a class=headline-hash href=#gpumemset-gpumemsetop>¶</a></h3><p><em>GPU memset operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.memset` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              $dst`,` $value `:` type($dst)`,` type($value) attr-dict
</code></pre><p>The <code>gpu.memset</code> operation sets the content of memref to a scalar value.</p><p>The op does not execute before all async dependencies have finished
executing.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a !gpu.async.token.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>memset async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span> <span class=nv>%dst</span><span class=p>,</span> <span class=nv>%value</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>,</span> <span class=m>1</span><span class=p>&gt;,</span> <span class=k>f32</span>
</span></span></code></pre></div><p>Interfaces: GPU_AsyncOpInterface</p><h4 id=operands-17>Operands:&nbsp;<a class=headline-hash href=#operands-17>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>dst</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>value</code></td><td>any type</td></tr></tbody></table><h4 id=results-23>Results:&nbsp;<a class=headline-hash href=#results-23>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpumodule_end-gpumoduleendop><code>gpu.module_end</code> (gpu::ModuleEndOp)&nbsp;<a class=headline-hash href=#gpumodule_end-gpumoduleendop>¶</a></h3><p><em>A pseudo op that marks the end of a gpu.module.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.module_end` attr-dict
</code></pre><p>This op terminates the only block inside the only region of a <code>gpu.module</code>.</p><p>Traits: HasParent<gpumoduleop>, Terminator</p><h3 id=gpunum_subgroups-gpunumsubgroupsop><code>gpu.num_subgroups</code> (gpu::NumSubgroupsOp)&nbsp;<a class=headline-hash href=#gpunum_subgroups-gpunumsubgroupsop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.num_subgroups` attr-dict `:` type($result)
</code></pre><p>Returns the number of subgroups within a workgroup.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%numSg</span> <span class=p>=</span> gpu<span class=p>.</span>num_subgroups <span class=p>:</span> <span class=k>index</span>
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, InferIntRangeInterface, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=results-24>Results:&nbsp;<a class=headline-hash href=#results-24>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>index</td></tr></tbody></table><h3 id=gpuprintf-gpuprintfop><code>gpu.printf</code> (gpu::PrintfOp)&nbsp;<a class=headline-hash href=#gpuprintf-gpuprintfop>¶</a></h3><p><em>Device-side printf, as in CUDA or OpenCL, for debugging</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.printf` $format attr-dict ($args^ `:` type($args))?
</code></pre><p><code>gpu.printf</code> takes a literal format string <code>format</code> and an arbitrary number of
scalar arguments that should be printed.</p><p>The format string is a C-style printf string, subject to any restrictions
imposed by one&rsquo;s target platform.</p><p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</p><h4 id=attributes-13>Attributes:&nbsp;<a class=headline-hash href=#attributes-13>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>format</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-18>Operands:&nbsp;<a class=headline-hash href=#operands-18>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of integer or index or floating-point</td></tr></tbody></table><h3 id=gpureturn-gpureturnop><code>gpu.return</code> (gpu::ReturnOp)&nbsp;<a class=headline-hash href=#gpureturn-gpureturnop>¶</a></h3><p><em>Terminator for GPU functions.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.return` attr-dict ($operands^ `:` type($operands))?
</code></pre><p>A terminator operation for regions that appear in the body of <code>gpu.func</code>
functions. The operands to the <code>gpu.return</code> are the result values returned
by an invocation of the <code>gpu.func</code>.</p><p>Traits: AlwaysSpeculatableImplTrait, HasParent<gpufuncop>, Terminator</p><p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-19>Operands:&nbsp;<a class=headline-hash href=#operands-19>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operands</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=gpusddmm_buffer_size-gpusddmmbuffersizeop><code>gpu.sddmm_buffer_size</code> (gpu::SDDMMBufferSizeOp)&nbsp;<a class=headline-hash href=#gpusddmm_buffer_size-gpusddmmbuffersizeop>¶</a></h3><p><em>Precompute buffersize for SDDMM operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.sddmm_buffer_size` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              $dnmatA (`{` $modeA^ `}`)? `,` $dnmatB (`{` $modeB^ `}`)? `,` $spmatC attr-dict `into` $computeType
</code></pre><p>The <code>gpu.sddmm_buffer_size</code> operation returns the buffer size required
to perform the SDDMM operation on the given sparse and dense matrices.
The operation expects handles returned by previous sparse operations
to construct an environment and the operands for SDDMM.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a !gpu.async.token in addition to the environment.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%buffersz</span><span class=p>,</span> <span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>sddmm_buffer_size async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span> <span class=nv>%dnmatA</span><span class=p>{</span>TRANSPOSE<span class=p>},</span> <span class=nv>%dnmatB</span><span class=p>{</span>TRANSPOSE<span class=p>},</span> <span class=nv>%spmatC</span> into <span class=k>f32</span>
</span></span></code></pre></div><p>The matrix arguments can also be associated with one of the following
operators: NON_TRANSPOSE, TRANSPOSE, CONJUGATE_TRANSPOSE. The default value
is NON_TRANSPOSE.</p><p>Interfaces: GPU_AsyncOpInterface</p><h4 id=attributes-14>Attributes:&nbsp;<a class=headline-hash href=#attributes-14>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>modeA</code></td><td>::mlir::gpu::TransposeModeAttr</td><td><details><summary>transpose mode of sparse matrix supported by sparse tensor ops</summary><p>Enum cases:</p><ul><li>NON_TRANSPOSE (<code>NON_TRANSPOSE</code>)</li><li>TRANSPOSE (<code>TRANSPOSE</code>)</li><li>CONJUGATE_TRANSPOSE (<code>CONJUGATE_TRANSPOSE</code>)</li></ul></details></td></tr><tr><td><code>modeB</code></td><td>::mlir::gpu::TransposeModeAttr</td><td><details><summary>transpose mode of sparse matrix supported by sparse tensor ops</summary><p>Enum cases:</p><ul><li>NON_TRANSPOSE (<code>NON_TRANSPOSE</code>)</li><li>TRANSPOSE (<code>TRANSPOSE</code>)</li><li>CONJUGATE_TRANSPOSE (<code>CONJUGATE_TRANSPOSE</code>)</li></ul></details></td></tr><tr><td><code>computeType</code></td><td>::mlir::TypeAttr</td><td>any type attribute</td></tr></table><h4 id=operands-20>Operands:&nbsp;<a class=headline-hash href=#operands-20>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>dnmatA</code></td><td>dense tensor handle type</td></tr><tr><td style=text-align:center><code>dnmatB</code></td><td>dense tensor handle type</td></tr><tr><td style=text-align:center><code>spmatC</code></td><td>sparse matrix handle type</td></tr></tbody></table><h4 id=results-25>Results:&nbsp;<a class=headline-hash href=#results-25>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>bufferSz</code></td><td>index</td></tr><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpusddmm-gpusddmmop><code>gpu.sddmm</code> (gpu::SDDMMOp)&nbsp;<a class=headline-hash href=#gpusddmm-gpusddmmop>¶</a></h3><p><em>SDDMM operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.sddmm` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              $dnmatA (`{` $modeA^ `}`)? `,` $dnmatB (`{` $modeB^ `}`)? `,` $spmatC `,` $buffer attr-dict `:` type($buffer) `into` $computeType
</code></pre><p>The <code>gpu.sddmm</code> operation performs the SDDMM operation on the given sparse and
dense matrices, and buffer. The operation expects handles returned by previous
sparse operations to construct an environment and the operands for SDDMM. The
buffer must have been allocated on the device.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a !gpu.async.token in addition to the environment.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>sddmm async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span> <span class=nv>%dnmatA</span><span class=p>{</span>TRANSPOSE<span class=p>},</span> <span class=nv>%dnmatB</span><span class=p>{</span>TRANSPOSE<span class=p>},</span> <span class=nv>%spmatC</span><span class=p>,</span> <span class=nv>%buffer</span> into <span class=k>f32</span>
</span></span></code></pre></div><p>The matrix arguments can also be associated with one of the following
operators: NON_TRANSPOSE, TRANSPOSE, CONJUGATE_TRANSPOSE. The default value
is NON_TRANSPOSE.</p><p>Interfaces: GPU_AsyncOpInterface</p><h4 id=attributes-15>Attributes:&nbsp;<a class=headline-hash href=#attributes-15>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>modeA</code></td><td>::mlir::gpu::TransposeModeAttr</td><td><details><summary>transpose mode of sparse matrix supported by sparse tensor ops</summary><p>Enum cases:</p><ul><li>NON_TRANSPOSE (<code>NON_TRANSPOSE</code>)</li><li>TRANSPOSE (<code>TRANSPOSE</code>)</li><li>CONJUGATE_TRANSPOSE (<code>CONJUGATE_TRANSPOSE</code>)</li></ul></details></td></tr><tr><td><code>modeB</code></td><td>::mlir::gpu::TransposeModeAttr</td><td><details><summary>transpose mode of sparse matrix supported by sparse tensor ops</summary><p>Enum cases:</p><ul><li>NON_TRANSPOSE (<code>NON_TRANSPOSE</code>)</li><li>TRANSPOSE (<code>TRANSPOSE</code>)</li><li>CONJUGATE_TRANSPOSE (<code>CONJUGATE_TRANSPOSE</code>)</li></ul></details></td></tr><tr><td><code>computeType</code></td><td>::mlir::TypeAttr</td><td>any type attribute</td></tr></table><h4 id=operands-21>Operands:&nbsp;<a class=headline-hash href=#operands-21>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>dnmatA</code></td><td>dense tensor handle type</td></tr><tr><td style=text-align:center><code>dnmatB</code></td><td>dense tensor handle type</td></tr><tr><td style=text-align:center><code>spmatC</code></td><td>sparse matrix handle type</td></tr><tr><td style=text-align:center><code>buffer</code></td><td>memref of any type values</td></tr></tbody></table><h4 id=results-26>Results:&nbsp;<a class=headline-hash href=#results-26>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpuset_csr_pointers-gpusetcsrpointersop><code>gpu.set_csr_pointers</code> (gpu::SetCsrPointersOp)&nbsp;<a class=headline-hash href=#gpuset_csr_pointers-gpusetcsrpointersop>¶</a></h3><p><em>SpGEMM get size operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.set_csr_pointers` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              $spmat `,` $positions `,` $coordinates `,` $values attr-dict
              `:` type($positions) `,` type($coordinates) `,` type($values)
</code></pre><p>The <code>gpu.set_csr_pointers</code> assigns the given positions, coordinates,
and values buffer that reside on the device directly to the given sparse
matrix descriptor in csr format.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a <code>!gpu.async.token</code> in addition to the environment.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>set_csr_pointers async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span> <span class=nv>%positions</span><span class=p>,</span> <span class=nv>%coordinates</span><span class=p>,</span> <span class=nv>%values</span>
</span></span><span class=line><span class=cl>      <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>index</span><span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>index</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: GPU_AsyncOpInterface</p><h4 id=operands-22>Operands:&nbsp;<a class=headline-hash href=#operands-22>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>spmat</code></td><td>sparse matrix handle type</td></tr><tr><td style=text-align:center><code>positions</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>coordinates</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>values</code></td><td>memref of any type values</td></tr></tbody></table><h4 id=results-27>Results:&nbsp;<a class=headline-hash href=#results-27>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpuset_default_device-gpusetdefaultdeviceop><code>gpu.set_default_device</code> (gpu::SetDefaultDeviceOp)&nbsp;<a class=headline-hash href=#gpuset_default_device-gpusetdefaultdeviceop>¶</a></h3><p><em>Set default GPU for operations after this by index</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.set_default_device` attr-dict $devIndex
</code></pre><p>Operation that sets the current default GPU, using a zero-based index
into the set of GPUs on the system. The default GPU setting may be
thread-local.</p><p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</p><h4 id=operands-23>Operands:&nbsp;<a class=headline-hash href=#operands-23>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>devIndex</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=gpushuffle-gpushuffleop><code>gpu.shuffle</code> (gpu::ShuffleOp)&nbsp;<a class=headline-hash href=#gpushuffle-gpushuffleop>¶</a></h3><p><em>Shuffles values within a subgroup.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.shuffle` $mode $value `,` $offset `,` $width attr-dict `:` type($value)
</code></pre><p>The &ldquo;shuffle&rdquo; op moves values to a different invocation within the same
subgroup.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%1</span><span class=p>,</span> <span class=nv>%2</span> <span class=p>=</span> gpu<span class=p>.</span>shuffle <span class=nv>%0</span><span class=p>,</span> <span class=nv>%offset</span><span class=p>,</span> <span class=nv>%width</span> xor <span class=p>:</span> <span class=k>f32</span>
</span></span></code></pre></div><p>For lane k returns the value from lane <code>k ^ offset</code> and <code>true</code> if that lane
is smaller than %width. Otherwise it returns an unspecified value and
<code>false</code>. A lane is the index of an invocation relative to its subgroup.</p><p>The width specifies the number of invocations that participate in the
shuffle. The width needs to be the same for all invocations that participate
in the shuffle. Exactly the first <code>width</code> invocations of a subgroup need to
execute this op in convergence.</p><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-16>Attributes:&nbsp;<a class=headline-hash href=#attributes-16>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>mode</code></td><td>::mlir::gpu::ShuffleModeAttr</td><td><details><summary>Indexing modes supported by gpu.shuffle.</summary><p>Enum cases:</p><ul><li>xor (<code>XOR</code>)</li><li>up (<code>UP</code>)</li><li>down (<code>DOWN</code>)</li><li>idx (<code>IDX</code>)</li></ul></details></td></tr></table><h4 id=operands-24>Operands:&nbsp;<a class=headline-hash href=#operands-24>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>i32, i64, f32 or f64</td></tr><tr><td style=text-align:center><code>offset</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>width</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-28>Results:&nbsp;<a class=headline-hash href=#results-28>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>shuffleResult</code></td><td>i32, i64, f32 or f64</td></tr><tr><td style=text-align:center><code>valid</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=gpuspgemm_copy-gpuspgemmcopyop><code>gpu.spgemm_copy</code> (gpu::SpGEMMCopyOp)&nbsp;<a class=headline-hash href=#gpuspgemm_copy-gpuspgemmcopyop>¶</a></h3><p><em>SpGEMM copy operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.spgemm_copy` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              $spmatA (`{` $modeA^ `}`)? `,` $spmatB (`{` $modeB^ `}`)? `,` $spmatC `,` $desc attr-dict `:` $computeType
</code></pre><p>The <code>gpu.spgemm_copy</code> operation copies the sparse matrix result of
a SpGEMM computation.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a <code>!gpu.async.token</code> in addition to the environment.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>gpu<span class=p>.</span>spgemm_copy <span class=nv>%spmatA</span><span class=p>,</span> <span class=nv>%spmatB</span><span class=p>,</span> <span class=nv>%spmatC</span><span class=p>,</span> <span class=nv>%spgemmDesc</span><span class=p>:</span> <span class=k>f32</span>
</span></span></code></pre></div><p>The matrix arguments can also be associated with one of the following
operators: NON_TRANSPOSE, TRANSPOSE, CONJUGATE_TRANSPOSE. The default value
is NON_TRANSPOSE.</p><p>Interfaces: GPU_AsyncOpInterface</p><h4 id=attributes-17>Attributes:&nbsp;<a class=headline-hash href=#attributes-17>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>modeA</code></td><td>::mlir::gpu::TransposeModeAttr</td><td><details><summary>transpose mode of sparse matrix supported by sparse tensor ops</summary><p>Enum cases:</p><ul><li>NON_TRANSPOSE (<code>NON_TRANSPOSE</code>)</li><li>TRANSPOSE (<code>TRANSPOSE</code>)</li><li>CONJUGATE_TRANSPOSE (<code>CONJUGATE_TRANSPOSE</code>)</li></ul></details></td></tr><tr><td><code>modeB</code></td><td>::mlir::gpu::TransposeModeAttr</td><td><details><summary>transpose mode of sparse matrix supported by sparse tensor ops</summary><p>Enum cases:</p><ul><li>NON_TRANSPOSE (<code>NON_TRANSPOSE</code>)</li><li>TRANSPOSE (<code>TRANSPOSE</code>)</li><li>CONJUGATE_TRANSPOSE (<code>CONJUGATE_TRANSPOSE</code>)</li></ul></details></td></tr><tr><td><code>computeType</code></td><td>::mlir::TypeAttr</td><td>any type attribute</td></tr></table><h4 id=operands-25>Operands:&nbsp;<a class=headline-hash href=#operands-25>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>desc</code></td><td>SpGEMM operation handle type</td></tr><tr><td style=text-align:center><code>spmatA</code></td><td>sparse matrix handle type</td></tr><tr><td style=text-align:center><code>spmatB</code></td><td>sparse matrix handle type</td></tr><tr><td style=text-align:center><code>spmatC</code></td><td>sparse matrix handle type</td></tr></tbody></table><h4 id=results-29>Results:&nbsp;<a class=headline-hash href=#results-29>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpuspgemm_create_descr-gpuspgemmcreatedescrop><code>gpu.spgemm_create_descr</code> (gpu::SpGEMMCreateDescrOp)&nbsp;<a class=headline-hash href=#gpuspgemm_create_descr-gpuspgemmcreatedescrop>¶</a></h3><p><em>SpGEMM Create Descr operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.spgemm_create_descr` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              attr-dict
</code></pre><p>The <code>gpu.spgemm_create_descr</code> creates a descriptor for the SpGEMM operation.
The descriptor describes the SpGEMM operation and stores the internal data
throughout the computation. It needs to be passed as an argument to
spgemm_* operations.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a <code>!gpu.async.token</code> in addition to the environment.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%desc</span><span class=p>,</span> <span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>spgemm_create_descr async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span>
</span></span></code></pre></div><p>Interfaces: GPU_AsyncOpInterface</p><h4 id=operands-26>Operands:&nbsp;<a class=headline-hash href=#operands-26>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr></tbody></table><h4 id=results-30>Results:&nbsp;<a class=headline-hash href=#results-30>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>desc</code></td><td>SpGEMM operation handle type</td></tr><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpuspgemm_destroy_descr-gpuspgemmdestroydescrop><code>gpu.spgemm_destroy_descr</code> (gpu::SpGEMMDestroyDescrOp)&nbsp;<a class=headline-hash href=#gpuspgemm_destroy_descr-gpuspgemmdestroydescrop>¶</a></h3><p><em>SpGEMM Destroy Descr operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.spgemm_destroy_descr` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              $desc attr-dict
</code></pre><p>The <code>gpu.spgemm_destroy_descr</code> destroys the SpGEMM operation descriptor.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a <code>!gpu.async.token</code> in addition to the environment.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>spgemm_destroy_descr async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span> <span class=nv>%desc</span>
</span></span></code></pre></div><p>Interfaces: GPU_AsyncOpInterface</p><h4 id=operands-27>Operands:&nbsp;<a class=headline-hash href=#operands-27>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>desc</code></td><td>SpGEMM operation handle type</td></tr></tbody></table><h4 id=results-31>Results:&nbsp;<a class=headline-hash href=#results-31>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpuspgemm_work_estimation_or_compute-gpuspgemmworkestimationorcomputeop><code>gpu.spgemm_work_estimation_or_compute</code> (gpu::SpGEMMWorkEstimationOrComputeOp)&nbsp;<a class=headline-hash href=#gpuspgemm_work_estimation_or_compute-gpuspgemmworkestimationorcomputeop>¶</a></h3><p><em>SpGEMM work estimation operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.spgemm_work_estimation_or_compute` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              `{` $kind `}` $spmatA (`{` $modeA^ `}`)? `,` $spmatB (`{` $modeB^ `}`)? `,` $spmatC `,` $desc `,` $bufferSz `,` $buffer  attr-dict `:` $computeType `into` type($buffer)
</code></pre><p>The <code>gpu.spgemm_work_estimation_or_compute</code> is used to call
cusparseSpGEMM_workEstimation or cusparseSpGEMM_compute. Both of them are
for both determining the buffer size and performing the actual computation.
The operation expects handles returned by previous sparse operations to
construct an environment and the operands for SpGEMM.
The buffer must have been allocated on the device.</p><p>C&rsquo; = alpha * op(A) * op(B) + beta * C</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a <code>!gpu.async.token</code> in addition to the environment.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%bufferSz</span><span class=p>,</span> <span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>spgemm_work_estimation_or_compute async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span> <span class=p>{</span>COMPUTE<span class=p>}</span>
</span></span><span class=line><span class=cl>                      <span class=nv>%desc</span><span class=p>,</span> <span class=nv>%spmatA</span><span class=p>{</span>NON_TRANSPOSE<span class=p>},</span> <span class=nv>%spmatB</span><span class=p>{</span>NON_TRANSPOSE<span class=p>},</span>
</span></span><span class=line><span class=cl>                      <span class=nv>%spmatC</span><span class=p>,</span> <span class=nv>%spgemmDesc</span><span class=p>,</span> <span class=nv>%c0</span><span class=p>,</span> <span class=nv>%alloc</span><span class=p>:</span> <span class=k>f32</span> into
</span></span><span class=line><span class=cl>                      <span class=kt>memref</span><span class=p>&lt;</span><span class=m>0</span>xi8<span class=p>&gt;</span>
</span></span></code></pre></div><p>The matrix arguments can also be associated with one of the following
operators: NON_TRANSPOSE, TRANSPOSE, CONJUGATE_TRANSPOSE. The default value
is NON_TRANSPOSE.</p><p>Interfaces: GPU_AsyncOpInterface</p><h4 id=attributes-18>Attributes:&nbsp;<a class=headline-hash href=#attributes-18>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>modeA</code></td><td>::mlir::gpu::TransposeModeAttr</td><td><details><summary>transpose mode of sparse matrix supported by sparse tensor ops</summary><p>Enum cases:</p><ul><li>NON_TRANSPOSE (<code>NON_TRANSPOSE</code>)</li><li>TRANSPOSE (<code>TRANSPOSE</code>)</li><li>CONJUGATE_TRANSPOSE (<code>CONJUGATE_TRANSPOSE</code>)</li></ul></details></td></tr><tr><td><code>modeB</code></td><td>::mlir::gpu::TransposeModeAttr</td><td><details><summary>transpose mode of sparse matrix supported by sparse tensor ops</summary><p>Enum cases:</p><ul><li>NON_TRANSPOSE (<code>NON_TRANSPOSE</code>)</li><li>TRANSPOSE (<code>TRANSPOSE</code>)</li><li>CONJUGATE_TRANSPOSE (<code>CONJUGATE_TRANSPOSE</code>)</li></ul></details></td></tr><tr><td><code>computeType</code></td><td>::mlir::TypeAttr</td><td>any type attribute</td></tr><tr><td><code>kind</code></td><td>::mlir::gpu::SpGEMMWorkEstimationOrComputeKindAttr</td><td><details><summary>choose whether spgemm_work_estimation_or_compute does work estimation or compute</summary><p>Enum cases:</p><ul><li>WORK_ESTIMATION (<code>WORK_ESTIMATION</code>)</li><li>COMPUTE (<code>COMPUTE</code>)</li></ul></details></td></tr></table><h4 id=operands-28>Operands:&nbsp;<a class=headline-hash href=#operands-28>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>desc</code></td><td>SpGEMM operation handle type</td></tr><tr><td style=text-align:center><code>spmatA</code></td><td>sparse matrix handle type</td></tr><tr><td style=text-align:center><code>spmatB</code></td><td>sparse matrix handle type</td></tr><tr><td style=text-align:center><code>spmatC</code></td><td>sparse matrix handle type</td></tr><tr><td style=text-align:center><code>bufferSz</code></td><td>index</td></tr><tr><td style=text-align:center><code>buffer</code></td><td>memref of any type values</td></tr></tbody></table><h4 id=results-32>Results:&nbsp;<a class=headline-hash href=#results-32>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>bufferSzNew</code></td><td>index</td></tr><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpuspmm_buffer_size-gpuspmmbuffersizeop><code>gpu.spmm_buffer_size</code> (gpu::SpMMBufferSizeOp)&nbsp;<a class=headline-hash href=#gpuspmm_buffer_size-gpuspmmbuffersizeop>¶</a></h3><p><em>Precompute buffersize for SpMM operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.spmm_buffer_size` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              $spmatA (`{` $modeA^ `}`)? `,` $dnmatB (`{` $modeB^ `}`)? `,` $dnmatC attr-dict `:` type($bufferSzs) `into` $computeType
</code></pre><p>The <code>gpu.spmm_buffer_size</code> operation returns the buffer size required
to perform the SpMM operation on the given sparse and dense matrix.
The operation expects handles returned by previous sparse operations
to construct an environment and the operands for SpMM.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a !gpu.async.token in addition to the environment.</p><p>The matrix arguments can also be associated with one of the following
operators: NON_TRANSPOSE, TRANSPOSE, CONJUGATE_TRANSPOSE. The default value
is NON_TRANSPOSE.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%bufferszs</span><span class=p>,</span> <span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>spmm_buffer_size async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span> <span class=nv>%spmatA</span><span class=p>{</span>TRANSPOSE<span class=p>},</span> <span class=nv>%dnmatB</span><span class=p>{</span>TRANSPOSE<span class=p>},</span> <span class=nv>%dnmatC</span> <span class=p>:</span> <span class=k>i64</span> into <span class=k>f32</span>
</span></span></code></pre></div><p>Traits: AttrSizedResultSegments</p><p>Interfaces: GPU_AsyncOpInterface</p><h4 id=attributes-19>Attributes:&nbsp;<a class=headline-hash href=#attributes-19>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>modeA</code></td><td>::mlir::gpu::TransposeModeAttr</td><td><details><summary>transpose mode of sparse matrix supported by sparse tensor ops</summary><p>Enum cases:</p><ul><li>NON_TRANSPOSE (<code>NON_TRANSPOSE</code>)</li><li>TRANSPOSE (<code>TRANSPOSE</code>)</li><li>CONJUGATE_TRANSPOSE (<code>CONJUGATE_TRANSPOSE</code>)</li></ul></details></td></tr><tr><td><code>modeB</code></td><td>::mlir::gpu::TransposeModeAttr</td><td><details><summary>transpose mode of sparse matrix supported by sparse tensor ops</summary><p>Enum cases:</p><ul><li>NON_TRANSPOSE (<code>NON_TRANSPOSE</code>)</li><li>TRANSPOSE (<code>TRANSPOSE</code>)</li><li>CONJUGATE_TRANSPOSE (<code>CONJUGATE_TRANSPOSE</code>)</li></ul></details></td></tr><tr><td><code>computeType</code></td><td>::mlir::TypeAttr</td><td>any type attribute</td></tr></table><h4 id=operands-29>Operands:&nbsp;<a class=headline-hash href=#operands-29>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>spmatA</code></td><td>sparse matrix handle type</td></tr><tr><td style=text-align:center><code>dnmatB</code></td><td>dense tensor handle type</td></tr><tr><td style=text-align:center><code>dnmatC</code></td><td>dense tensor handle type</td></tr></tbody></table><h4 id=results-33>Results:&nbsp;<a class=headline-hash href=#results-33>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>bufferSzs</code></td><td>variadic of index</td></tr><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpuspmm-gpuspmmop><code>gpu.spmm</code> (gpu::SpMMOp)&nbsp;<a class=headline-hash href=#gpuspmm-gpuspmmop>¶</a></h3><p><em>SpMM operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.spmm` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              $spmatA (`{` $modeA^ `}`)? `,` $dnmatB (`{` $modeB^ `}`)? `,` $dnmatC `,` $buffers attr-dict `:` type($buffers) `into` $computeType
</code></pre><p>The <code>gpu.spmm</code> operation performs the SpMM operation on the given sparse and
dense matrix, and buffer. The operation expects handles returned by previous
sparse operations to construct an environment and the operands for SpMM. The
buffer must have been allocated on the device.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a !gpu.async.token in addition to the environment.</p><p>The matrix arguments can also be associated with one of the following
operators: NON_TRANSPOSE, TRANSPOSE, CONJUGATE_TRANSPOSE. The default value
is NON_TRANSPOSE.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>spmm async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span> <span class=nv>%spmatA</span><span class=p>{</span>TRANSPOSE<span class=p>},</span> <span class=nv>%dnmatB</span><span class=p>{</span>TRANSPOSE<span class=p>},</span> <span class=nv>%dnmatC</span><span class=p>,</span> <span class=nv>%buffers</span> <span class=p>:</span> type<span class=p>(</span><span class=err>$</span>buffers<span class=p>)</span> into <span class=k>f32</span>
</span></span></code></pre></div><p>Traits: AttrSizedOperandSegments</p><p>Interfaces: GPU_AsyncOpInterface</p><h4 id=attributes-20>Attributes:&nbsp;<a class=headline-hash href=#attributes-20>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>modeA</code></td><td>::mlir::gpu::TransposeModeAttr</td><td><details><summary>transpose mode of sparse matrix supported by sparse tensor ops</summary><p>Enum cases:</p><ul><li>NON_TRANSPOSE (<code>NON_TRANSPOSE</code>)</li><li>TRANSPOSE (<code>TRANSPOSE</code>)</li><li>CONJUGATE_TRANSPOSE (<code>CONJUGATE_TRANSPOSE</code>)</li></ul></details></td></tr><tr><td><code>modeB</code></td><td>::mlir::gpu::TransposeModeAttr</td><td><details><summary>transpose mode of sparse matrix supported by sparse tensor ops</summary><p>Enum cases:</p><ul><li>NON_TRANSPOSE (<code>NON_TRANSPOSE</code>)</li><li>TRANSPOSE (<code>TRANSPOSE</code>)</li><li>CONJUGATE_TRANSPOSE (<code>CONJUGATE_TRANSPOSE</code>)</li></ul></details></td></tr><tr><td><code>computeType</code></td><td>::mlir::TypeAttr</td><td>any type attribute</td></tr></table><h4 id=operands-30>Operands:&nbsp;<a class=headline-hash href=#operands-30>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>spmatA</code></td><td>sparse matrix handle type</td></tr><tr><td style=text-align:center><code>dnmatB</code></td><td>dense tensor handle type</td></tr><tr><td style=text-align:center><code>dnmatC</code></td><td>dense tensor handle type</td></tr><tr><td style=text-align:center><code>buffers</code></td><td>variadic of memref of any type values</td></tr></tbody></table><h4 id=results-34>Results:&nbsp;<a class=headline-hash href=#results-34>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpuspmv_buffer_size-gpuspmvbuffersizeop><code>gpu.spmv_buffer_size</code> (gpu::SpMVBufferSizeOp)&nbsp;<a class=headline-hash href=#gpuspmv_buffer_size-gpuspmvbuffersizeop>¶</a></h3><p><em>Precompute buffersize for SpMV operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.spmv_buffer_size` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              $spmatA (`{` $modeA^ `}`)? `,` $dnX `,` $dnY attr-dict  `into` $computeType
</code></pre><p>The <code>gpu.spmv_buffer_size</code> operation returns the buffer size required
to perform the SpMV operation on the given sparse matrix and dense vectors.
The operation expects handles returned by previous sparse operations
to construct an environment and the operands for SpMV.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a !gpu.async.token in addition to the environment.</p><p>The matrix arguments can also be associated with one of the following
operators: NON_TRANSPOSE, TRANSPOSE, CONJUGATE_TRANSPOSE. The default value
is NON_TRANSPOSE.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%buffersz</span><span class=p>,</span> <span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>spmv_buffer_size async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span> <span class=nv>%spmatA</span><span class=p>{</span>TRANSPOSE<span class=p>},</span> <span class=nv>%dnX</span><span class=p>,</span> <span class=nv>%dnY</span> into <span class=k>f32</span>
</span></span></code></pre></div><p>Interfaces: GPU_AsyncOpInterface</p><h4 id=attributes-21>Attributes:&nbsp;<a class=headline-hash href=#attributes-21>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>modeA</code></td><td>::mlir::gpu::TransposeModeAttr</td><td><details><summary>transpose mode of sparse matrix supported by sparse tensor ops</summary><p>Enum cases:</p><ul><li>NON_TRANSPOSE (<code>NON_TRANSPOSE</code>)</li><li>TRANSPOSE (<code>TRANSPOSE</code>)</li><li>CONJUGATE_TRANSPOSE (<code>CONJUGATE_TRANSPOSE</code>)</li></ul></details></td></tr><tr><td><code>computeType</code></td><td>::mlir::TypeAttr</td><td>any type attribute</td></tr></table><h4 id=operands-31>Operands:&nbsp;<a class=headline-hash href=#operands-31>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>spmatA</code></td><td>sparse matrix handle type</td></tr><tr><td style=text-align:center><code>dnX</code></td><td>dense tensor handle type</td></tr><tr><td style=text-align:center><code>dnY</code></td><td>dense tensor handle type</td></tr></tbody></table><h4 id=results-35>Results:&nbsp;<a class=headline-hash href=#results-35>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>bufferSz</code></td><td>index</td></tr><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpuspmv-gpuspmvop><code>gpu.spmv</code> (gpu::SpMVOp)&nbsp;<a class=headline-hash href=#gpuspmv-gpuspmvop>¶</a></h3><p><em>SpMV operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.spmv` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              $spmatA (`{` $modeA^ `}`)? `,` $dnX `,` $dnY `,` $buffer attr-dict `:` type($buffer) `into` $computeType
</code></pre><p>The <code>gpu.spmv</code> operation performs the SpMV operation on the given sparse matrix,
dense vectors, and buffer. The operation expects handles returned by previous
sparse operations to construct an environment and the operands for SpMV. The
buffer must have been allocated on the device.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a !gpu.async.token in addition to the environment.</p><p>The matrix arguments can also be associated with one of the following
operators: NON_TRANSPOSE, TRANSPOSE, CONJUGATE_TRANSPOSE. The default value
is NON_TRANSPOSE.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>spmv async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span> <span class=nv>%spmatA</span><span class=p>{</span>TRANSPOSE<span class=p>},</span> <span class=nv>%dnX</span><span class=p>,</span> <span class=nv>%dnY</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f64</span><span class=p>&gt;</span> into <span class=k>bf16</span>
</span></span></code></pre></div><p>Interfaces: GPU_AsyncOpInterface</p><h4 id=attributes-22>Attributes:&nbsp;<a class=headline-hash href=#attributes-22>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>modeA</code></td><td>::mlir::gpu::TransposeModeAttr</td><td><details><summary>transpose mode of sparse matrix supported by sparse tensor ops</summary><p>Enum cases:</p><ul><li>NON_TRANSPOSE (<code>NON_TRANSPOSE</code>)</li><li>TRANSPOSE (<code>TRANSPOSE</code>)</li><li>CONJUGATE_TRANSPOSE (<code>CONJUGATE_TRANSPOSE</code>)</li></ul></details></td></tr><tr><td><code>computeType</code></td><td>::mlir::TypeAttr</td><td>any type attribute</td></tr></table><h4 id=operands-32>Operands:&nbsp;<a class=headline-hash href=#operands-32>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>spmatA</code></td><td>sparse matrix handle type</td></tr><tr><td style=text-align:center><code>dnX</code></td><td>dense tensor handle type</td></tr><tr><td style=text-align:center><code>dnY</code></td><td>dense tensor handle type</td></tr><tr><td style=text-align:center><code>buffer</code></td><td>memref of any type values</td></tr></tbody></table><h4 id=results-36>Results:&nbsp;<a class=headline-hash href=#results-36>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpuspmat_get_size-gpuspmatgetsizeop><code>gpu.spmat_get_size</code> (gpu::SpMatGetSizeOp)&nbsp;<a class=headline-hash href=#gpuspmat_get_size-gpuspmatgetsizeop>¶</a></h3><p><em>SpMat get size operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.spmat_get_size` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              $spmat attr-dict
</code></pre><p>The <code>gpu.spmat_get_size</code> operation retrieves the number of rows, number of
columns, and number of non-zero elements of a sparse matrix.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a <code>!gpu.async.token</code> in addition to the environment.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%rows</span><span class=p>,</span> <span class=nv>%cols</span><span class=p>,</span> <span class=nv>%nnz</span><span class=p>,</span> <span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>spmat_get_size async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span> <span class=nv>%spmatC</span>
</span></span></code></pre></div><p>Interfaces: GPU_AsyncOpInterface</p><h4 id=operands-33>Operands:&nbsp;<a class=headline-hash href=#operands-33>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>spmat</code></td><td>sparse matrix handle type</td></tr></tbody></table><h4 id=results-37>Results:&nbsp;<a class=headline-hash href=#results-37>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>rows</code></td><td>index</td></tr><tr><td style=text-align:center><code>cols</code></td><td>index</td></tr><tr><td style=text-align:center><code>nnz</code></td><td>index</td></tr><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpusubgroup_id-gpusubgroupidop><code>gpu.subgroup_id</code> (gpu::SubgroupIdOp)&nbsp;<a class=headline-hash href=#gpusubgroup_id-gpusubgroupidop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.subgroup_id` attr-dict `:` type($result)
</code></pre><p>Returns the subgroup id, i.e. the index of the current subgroup within the
workgroup.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%sgId</span> <span class=p>=</span> gpu<span class=p>.</span>subgroup_id <span class=p>:</span> <span class=k>index</span>
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, InferIntRangeInterface, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=results-38>Results:&nbsp;<a class=headline-hash href=#results-38>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>index</td></tr></tbody></table><h3 id=gpusubgroup_mma_compute-gpusubgroupmmacomputeop><code>gpu.subgroup_mma_compute</code> (gpu::SubgroupMmaComputeOp)&nbsp;<a class=headline-hash href=#gpusubgroup_mma_compute-gpusubgroupmmacomputeop>¶</a></h3><p><em>GPU warp synchronous matrix multiply accumulate</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.subgroup_mma_compute` $opA`,` $opB`,` $opC attr-dict `:` type($opA)`,` type($opB) `-&gt;` type($res)
</code></pre><p>The <code>gpu.subgroup_mma_compute</code> operation performs a matrix-multiply accumulate (mma)
operation using all the threads in a subgroup.</p><p>This operation takes three <code>!gpu.mma_matrix</code>s as arguments: these hold <code>A</code>,
<code>B</code> and <code>C</code>operands for the mma operation. The operation performed is represented
as <code>C += A * B</code>. The op returns a <code>!gpu.mma_matrix</code> which contains the result of
the operation held by all threads in a subgroup. <code>a_transpose</code> or
<code>b_transpose</code> if present, signify that the respective operand was loaded in a
transposed manner. The transpose operands are required to map to correct
underlying intrisics but they currently do not seem to affect correctness
even if they are absent given that the operands were loaded correctly using
the <code>transpose</code> attribute in <code>gpu.subgroup_mma_load_matrix</code> op.</p><p>For integer types, the <code>A</code> and <code>B</code> matrices carry their signedness with their
types. The accumulator type is expected to be signless and imply a signed integer
with a greater width than the other two operands.</p><p>This op is meant to be used along with <code>gpu.subgroup_mma_store_matrix</code> and
<code>gpu.subgroup_mma_load_matrix</code> ops.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%D</span> <span class=p>=</span> gpu<span class=p>.</span>subgroup_mma_compute_matrix <span class=nv>%A</span><span class=p>,</span> <span class=nv>%B</span><span class=p>,</span> <span class=nv>%C</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=p>!</span>gpu<span class=p>.</span>mma_matrix<span class=p>&lt;</span><span class=m>16x16x</span><span class=k>f16</span><span class=p>,</span> <span class=s>&#34;AOp&#34;</span><span class=p>&gt;,</span> <span class=p>!</span>gpu<span class=p>.</span>mma_matrix<span class=p>&lt;</span><span class=m>16x16x</span><span class=k>f16</span><span class=p>,</span> <span class=s>&#34;BOp&#34;</span><span class=p>&gt;&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>-&gt;</span> <span class=p>!</span>gpu<span class=p>.</span>mma_matrix<span class=p>&lt;</span><span class=m>16x16x</span><span class=k>f16</span><span class=p>,</span> <span class=s>&#34;COp&#34;</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-23>Attributes:&nbsp;<a class=headline-hash href=#attributes-23>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>a_transpose</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>b_transpose</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-34>Operands:&nbsp;<a class=headline-hash href=#operands-34>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>opA</code></td><td>gpu.mma_matrix of 8-bit signed integer or 8-bit unsigned integer or 16-bit float or 32-bit float values</td></tr><tr><td style=text-align:center><code>opB</code></td><td>gpu.mma_matrix of 8-bit signed integer or 8-bit unsigned integer or 16-bit float or 32-bit float values</td></tr><tr><td style=text-align:center><code>opC</code></td><td>gpu.mma_matrix of 32-bit signless integer or 16-bit float or 32-bit float values</td></tr></tbody></table><h4 id=results-39>Results:&nbsp;<a class=headline-hash href=#results-39>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>MMAMatrix type</td></tr></tbody></table><h3 id=gpusubgroup_mma_constant_matrix-gpusubgroupmmaconstantmatrixop><code>gpu.subgroup_mma_constant_matrix</code> (gpu::SubgroupMmaConstantMatrixOp)&nbsp;<a class=headline-hash href=#gpusubgroup_mma_constant_matrix-gpusubgroupmmaconstantmatrixop>¶</a></h3><p><em>GPU warp synchronous constant matrix</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.subgroup_mma_constant_matrix` $value attr-dict `:` type($res)
</code></pre><p>The <code>gpu.subgroup_mma_constant_matrix</code> creates a <code>!gpu.mma_matrix</code> with
constant elements.</p><p>The operation takes a scalar input and return a <code>!gpu.mma_matrix</code> where
each element of is equal to the operand constant. The destination
mma_matrix type must have elememt type equal to the constant type. Since
the layout of <code>!gpu.mma_matrix</code> is opaque this only support setting all the
elements to the same value.</p><p>This op is meant to be used along with <code>gpu.subgroup_mma_compute</code>.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl> <span class=nv>%0</span> <span class=p>=</span> gpu<span class=p>.</span>subgroup_mma_constant_matrix <span class=nv>%a</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>   <span class=p>!</span>gpu<span class=p>.</span>mma_matrix<span class=p>&lt;</span><span class=m>16x16x</span><span class=k>f16</span><span class=p>,</span> <span class=s>&#34;AOp&#34;</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl> <span class=nv>%1</span> <span class=p>=</span> gpu<span class=p>.</span>subgroup_mma_constant_matrix <span class=nv>%b</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>   <span class=p>!</span>gpu<span class=p>.</span>mma_matrix<span class=p>&lt;</span><span class=m>16x16x</span><span class=k>f32</span><span class=p>,</span> <span class=s>&#34;COp&#34;</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-35>Operands:&nbsp;<a class=headline-hash href=#operands-35>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>8-bit signed integer or 8-bit unsigned integer or 32-bit signless integer or 16-bit float or 32-bit float</td></tr></tbody></table><h4 id=results-40>Results:&nbsp;<a class=headline-hash href=#results-40>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>MMAMatrix type</td></tr></tbody></table><h3 id=gpusubgroup_mma_elementwise-gpusubgroupmmaelementwiseop><code>gpu.subgroup_mma_elementwise</code> (gpu::SubgroupMmaElementwiseOp)&nbsp;<a class=headline-hash href=#gpusubgroup_mma_elementwise-gpusubgroupmmaelementwiseop>¶</a></h3><p><em>GPU warp elementwise operation on a matrix</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.subgroup_mma_elementwise` $opType $args attr-dict `:` functional-type($args, $res)
</code></pre><p>The <code>gpu.subgroup_mma_elementwise</code> takes <code>!gpu.mma_matrix</code> inputs and
compute a new <code>!gpu.mma_matrix</code> by applying an elementwise operation to each
element.</p><p>Since the operation is elementwise and the matrix type must match, the
matrix elements are processed independently of the matrix layout.</p><p>This op is meant to be used along with <code>gpu.subgroup_mma_compute</code>.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl> <span class=nv>%0</span> <span class=p>=</span>  <span class=nv>%A</span><span class=p>,</span> <span class=nv>%B</span> <span class=p>{</span> <span class=nl>opType =</span> <span class=s>&#34;ADD&#34;</span> <span class=p>}</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=p>(!</span>gpu<span class=p>.</span>mma_matrix<span class=p>&lt;</span><span class=m>16x16x</span><span class=k>f16</span><span class=p>,</span> <span class=s>&#34;COp&#34;</span><span class=p>&gt;,</span> <span class=p>!</span>gpu<span class=p>.</span>mma_matrix<span class=p>&lt;</span><span class=m>16x16x</span><span class=k>f16</span><span class=p>,</span> <span class=s>&#34;COp&#34;</span><span class=p>&gt;)</span>
</span></span><span class=line><span class=cl>  <span class=p>-&gt;</span> <span class=p>!</span>gpu<span class=p>.</span>mma_matrix<span class=p>&lt;</span><span class=m>16x16x</span><span class=k>f16</span><span class=p>,</span> <span class=s>&#34;COp&#34;</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-24>Attributes:&nbsp;<a class=headline-hash href=#attributes-24>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>opType</code></td><td>::mlir::gpu::MMAElementwiseOpAttr</td><td><details><summary>elementwise operation to apply to mma matrix</summary><p>Enum cases:</p><ul><li>addf (<code>ADDF</code>)</li><li>mulf (<code>MULF</code>)</li><li>subf (<code>SUBF</code>)</li><li>maxf (<code>MAXF</code>)</li><li>minf (<code>MINF</code>)</li><li>divf (<code>DIVF</code>)</li><li>addi (<code>ADDI</code>)</li><li>muli (<code>MULI</code>)</li><li>subi (<code>SUBI</code>)</li><li>divs (<code>DIVS</code>)</li><li>divu (<code>DIVU</code>)</li><li>negatef (<code>NEGATEF</code>)</li><li>negates (<code>NEGATES</code>)</li><li>extf (<code>EXTF</code>)</li></ul></details></td></tr></table><h4 id=operands-36>Operands:&nbsp;<a class=headline-hash href=#operands-36>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of MMAMatrix type</td></tr></tbody></table><h4 id=results-41>Results:&nbsp;<a class=headline-hash href=#results-41>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>MMAMatrix type</td></tr></tbody></table><h3 id=gpusubgroup_mma_load_matrix-gpusubgroupmmaloadmatrixop><code>gpu.subgroup_mma_load_matrix</code> (gpu::SubgroupMmaLoadMatrixOp)&nbsp;<a class=headline-hash href=#gpusubgroup_mma_load_matrix-gpusubgroupmmaloadmatrixop>¶</a></h3><p><em>GPU warp synchronous matrix load</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.subgroup_mma_load_matrix` $srcMemref`[`$indices`]` attr-dict `:` type($srcMemref) `-&gt;` type($res)
</code></pre><p>The <code>gpu.subgroup_mma_load_matrix</code> operation loads a matrix collectively
using all the threads in a subgroup.</p><p>This operation takes a memref as its first operand: it is the source matrix
from which data is to be loaded. The op returns a <code>!gpu.mma_matrix</code>. The
source memref can be in global memory or shared memory. The load address is
determined using <code>indices</code>. The matrix being loaded into is the result. The
<code>leadDimension</code> attribute specifies the leading dimension size of the source
matrix which eventually allows the lowering to determine the size of each
row. If the <code>transpose</code> attribute is present then the op does a transposed load.</p><p>For integer types, the resulting <code>!gpu.mma_matrix</code> type needs to specify the
signedness of the data if the matrix type is an <code>A</code> or <code>B</code> operand for
<code>gpu.subgroup_mma_compute</code>.</p><p>This op is often meant to be used along with <code>gpu.subgroup_mma_store_matrix</code> and
<code>gpu.subgroup_mma_compute</code>.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl> <span class=nv>%0</span> <span class=p>=</span> gpu<span class=p>.</span>subgroup_mma_load_matrix src<span class=p>[</span><span class=nv>%i</span><span class=p>,</span><span class=nv>%j</span><span class=p>]</span> <span class=p>:</span> <span class=p>{</span><span class=nl>leadDimension =</span> <span class=m>32</span> <span class=p>:</span> <span class=k>i32</span><span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>32x32x</span><span class=k>f16</span><span class=p>,</span> <span class=m>3</span><span class=p>&gt;,</span> <span class=p>!</span>gpu<span class=p>.</span>mma_matrix<span class=p>&lt;</span><span class=m>16x16x</span><span class=k>f16</span><span class=p>,</span> <span class=s>&#34;AOp&#34;</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{MemoryEffects::Read on ::mlir::SideEffects::DefaultResource}</p><h4 id=attributes-25>Attributes:&nbsp;<a class=headline-hash href=#attributes-25>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>leadDimension</code></td><td>::mlir::IntegerAttr</td><td>index attribute</td></tr><tr><td><code>transpose</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-37>Operands:&nbsp;<a class=headline-hash href=#operands-37>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>srcMemref</code></td><td>memref of 8-bit signless integer or 32-bit signless integer or 16-bit float or 32-bit float or vector of 8-bit signless integer or 32-bit signless integer or 16-bit float or 32-bit float values of ranks 1 values</td></tr><tr><td style=text-align:center><code>indices</code></td><td>variadic of index</td></tr></tbody></table><h4 id=results-42>Results:&nbsp;<a class=headline-hash href=#results-42>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>MMAMatrix type</td></tr></tbody></table><h3 id=gpusubgroup_mma_store_matrix-gpusubgroupmmastorematrixop><code>gpu.subgroup_mma_store_matrix</code> (gpu::SubgroupMmaStoreMatrixOp)&nbsp;<a class=headline-hash href=#gpusubgroup_mma_store_matrix-gpusubgroupmmastorematrixop>¶</a></h3><p><em>GPU warp synchronous matrix store</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.subgroup_mma_store_matrix` $src`,` $dstMemref`[`$indices`]` attr-dict `:` type($src)`,` type($dstMemref)
</code></pre><p>The <code>gpu.subgroup_mma_store_matrix</code> operation stores a matrix collectively
using all the threads in a subgroup.</p><p>This operation takes a <code>!gpu.mma_matrix</code> and a memref as operands.
<code>!gpu.mma_matrix</code> is the source value containing the data to be stored into the
destination memref which can be in global or shared memory. The store address
is determined using the indices provided. The <code>leadDimension</code> attribute
specifies the leading dimension of the destination matrix. If the
<code>transpose</code> attribute is present then the op does a transposed store.</p><p>This op is often meant to be used along with <code>gpu.subgroup_mma_load_matrix</code> and
<code>gpu.subgroup_mma_compute</code>.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>gpu<span class=p>.</span>subgroup_mma_store_matrix <span class=nv>%D</span><span class=p>,</span> <span class=nv>%sg</span><span class=p>[</span><span class=nv>%i</span><span class=p>,</span><span class=nv>%j</span><span class=p>]</span> <span class=p>:</span> <span class=p>{</span> <span class=nl>leadDimension =</span> <span class=m>32</span> <span class=p>:</span> <span class=k>i32</span><span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=p>:</span> <span class=p>!</span>gpu<span class=p>.</span>mma_matrix<span class=p>&lt;</span><span class=m>16x16x</span><span class=k>f16</span><span class=p>,</span> <span class=s>&#34;COp&#34;</span><span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>32x32x</span><span class=k>f16</span><span class=p>,</span> <span class=m>3</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</p><h4 id=attributes-26>Attributes:&nbsp;<a class=headline-hash href=#attributes-26>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>leadDimension</code></td><td>::mlir::IntegerAttr</td><td>index attribute</td></tr><tr><td><code>transpose</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-38>Operands:&nbsp;<a class=headline-hash href=#operands-38>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>gpu.mma_matrix of 8-bit signed integer or 8-bit unsigned integer or 32-bit signless integer or 16-bit float or 32-bit float values</td></tr><tr><td style=text-align:center><code>dstMemref</code></td><td>memref of 8-bit signless integer or 32-bit signless integer or 16-bit float or 32-bit float or vector of 8-bit signless integer or 32-bit signless integer or 16-bit float or 32-bit float values of ranks 1 values</td></tr><tr><td style=text-align:center><code>indices</code></td><td>variadic of index</td></tr></tbody></table><h3 id=gpusubgroup_reduce-gpusubgroupreduceop><code>gpu.subgroup_reduce</code> (gpu::SubgroupReduceOp)&nbsp;<a class=headline-hash href=#gpusubgroup_reduce-gpusubgroupreduceop>¶</a></h3><p><em>Reduce values among subgroup.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.subgroup_reduce` custom&lt;AllReduceOperation&gt;($op) $value
              (`uniform` $uniform^)? attr-dict
              `:` functional-type(operands, results)
</code></pre><p>The <code>subgroup_reduce</code> op reduces the value of every work item across a
subgroup. The result is equal for all work items of a subgroup.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> gpu<span class=p>.</span>subgroup_reduce add <span class=nv>%0</span> <span class=p>:</span> <span class=p>(</span><span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>f32</span><span class=p>)</span>
</span></span></code></pre></div><p>If <code>uniform</code> flag is set either none or all work items of a subgroup
need to execute this op in convergence. The reduction operation must be one
of:</p><ul><li>Integer types: <code>add</code>, <code>mul</code>, <code>minui</code>, <code>minsi</code>, <code>maxui</code>, <code>maxsi</code>, <code>and</code>,
<code>or</code>, <code>xor</code></li><li>Floating point types: <code>add</code>, <code>mul</code>, <code>minf</code>, <code>maxf</code>, <code>minimumf</code>,
<code>maximumf</code></li></ul><p>Traits: SameOperandsAndResultType</p><p>Interfaces: InferTypeOpInterface</p><h4 id=attributes-27>Attributes:&nbsp;<a class=headline-hash href=#attributes-27>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>op</code></td><td>::mlir::gpu::AllReduceOperationAttr</td><td><details><summary>built-in reduction operations supported by gpu.allreduce.</summary><p>Enum cases:</p><ul><li>add (<code>ADD</code>)</li><li>mul (<code>MUL</code>)</li><li>minui (<code>MINUI</code>)</li><li>minsi (<code>MINSI</code>)</li><li>minf (<code>MINF</code>)</li><li>maxui (<code>MAXUI</code>)</li><li>maxsi (<code>MAXSI</code>)</li><li>maxf (<code>MAXF</code>)</li><li>and (<code>AND</code>)</li><li>or (<code>OR</code>)</li><li>xor (<code>XOR</code>)</li><li>minimumf (<code>MINIMUMF</code>)</li><li>maximumf (<code>MAXIMUMF</code>)</li></ul></details></td></tr><tr><td><code>uniform</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-39>Operands:&nbsp;<a class=headline-hash href=#operands-39>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>Integer or Float</td></tr></tbody></table><h4 id=results-43>Results:&nbsp;<a class=headline-hash href=#results-43>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>Integer or Float</td></tr></tbody></table><h3 id=gpusubgroup_size-gpusubgroupsizeop><code>gpu.subgroup_size</code> (gpu::SubgroupSizeOp)&nbsp;<a class=headline-hash href=#gpusubgroup_size-gpusubgroupsizeop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.subgroup_size` attr-dict `:` type($result)
</code></pre><p>Returns the number of threads within a subgroup.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%sgSz</span> <span class=p>=</span> gpu<span class=p>.</span>subgroup_size <span class=p>:</span> <span class=k>index</span>
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, InferIntRangeInterface, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=results-44>Results:&nbsp;<a class=headline-hash href=#results-44>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>index</td></tr></tbody></table><h3 id=gputerminator-gputerminatorop><code>gpu.terminator</code> (gpu::TerminatorOp)&nbsp;<a class=headline-hash href=#gputerminator-gputerminatorop>¶</a></h3><p><em>Terminator for GPU launch regions.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.terminator` attr-dict
</code></pre><p>A terminator operation for regions that appear in the body of <code>gpu.launch</code>
operation. These regions are not expected to return any value so the
terminator takes no operands.</p><p>Traits: AlwaysSpeculatableImplTrait, HasParent<launchop>, Terminator</p><p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h3 id=gputhread_id-gputhreadidop><code>gpu.thread_id</code> (gpu::ThreadIdOp)&nbsp;<a class=headline-hash href=#gputhread_id-gputhreadidop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.thread_id` $dimension attr-dict
</code></pre><p>Returns the thread id, i.e. the index of the current thread within the block
along the x, y, or z <code>dimension</code>.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%tIdX</span> <span class=p>=</span> gpu<span class=p>.</span>thread_id <span class=p>x</span>
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, InferIntRangeInterface, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-28>Attributes:&nbsp;<a class=headline-hash href=#attributes-28>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dimension</code></td><td>::mlir::gpu::DimensionAttr</td><td><details><summary>a dimension, either 'x', 'y', or 'z'</summary><p>Enum cases:</p><ul><li>x (<code>x</code>)</li><li>y (<code>y</code>)</li><li>z (<code>z</code>)</li></ul></details></td></tr></table><h4 id=results-45>Results:&nbsp;<a class=headline-hash href=#results-45>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>index</td></tr></tbody></table><h3 id=gpuwait-gpuwaitop><code>gpu.wait</code> (gpu::WaitOp)&nbsp;<a class=headline-hash href=#gpuwait-gpuwaitop>¶</a></h3><p><em>Wait for async gpu ops to complete.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.wait` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies) attr-dict
</code></pre><p>This op synchronizes the host or the device with a list of dependent ops.</p><p>If the op contains the <code>async</code> keyword, it returns a new async token which
is synchronized with the op arguments. This new token is merely a shortcut
to the argument list, and one could replace the uses of the result with the
arguments for the same effect. The async version of this op is primarily
used to make each async token have a single use during lowering and
thereby make forks in async execution explicit. Example usage:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%t0</span> <span class=p>=</span> gpu<span class=p>.</span>foo async <span class=p>:</span> <span class=p>!</span>gpu<span class=p>.</span>async<span class=p>.</span>token
</span></span><span class=line><span class=cl><span class=nv>%t1</span> <span class=p>=</span> gpu<span class=p>.</span>bar async <span class=p>:</span> <span class=p>!</span>gpu<span class=p>.</span>async<span class=p>.</span>token
</span></span><span class=line><span class=cl><span class=nv>%t2</span> <span class=p>=</span> gpu<span class=p>.</span>wait async <span class=p>[</span><span class=nv>%t0</span><span class=p>,</span> <span class=nv>%t1</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=c>// gpu.baz doesn&#39;t run until gpu.foo and gpu.bar have both completed, just
</span></span></span><span class=line><span class=cl><span class=c>// as if the async dependencies were [%t0, %t1].
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%t3</span> <span class=p>=</span> gpu<span class=p>.</span>baz async <span class=p>[</span><span class=nv>%t2</span><span class=p>]</span>
</span></span></code></pre></div><p>If the op does not contain the <code>async</code> keyword, it does not return a new
async token but blocks until all ops producing the async dependency tokens
finished execution. All dependent memory operations are visible to the host
once this op completes. Example usage:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%t0</span> <span class=p>=</span> gpu<span class=p>.</span>foo async <span class=p>:</span> <span class=p>!</span>gpu<span class=p>.</span>async<span class=p>.</span>token
</span></span><span class=line><span class=cl><span class=nv>%t1</span> <span class=p>=</span> gpu<span class=p>.</span>bar async <span class=p>:</span> <span class=p>!</span>gpu<span class=p>.</span>async<span class=p>.</span>token
</span></span><span class=line><span class=cl><span class=c>// The gpu.wait op blocks until gpu.foo and gpu.bar have completed.
</span></span></span><span class=line><span class=cl><span class=c></span>gpu<span class=p>.</span>wait <span class=p>[</span><span class=nv>%t0</span><span class=p>,</span> <span class=nv>%t1</span><span class=p>]</span>
</span></span></code></pre></div><p>Interfaces: GPU_AsyncOpInterface</p><h4 id=operands-40>Operands:&nbsp;<a class=headline-hash href=#operands-40>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr></tbody></table><h4 id=results-46>Results:&nbsp;<a class=headline-hash href=#results-46>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpuyield-gpuyieldop><code>gpu.yield</code> (gpu::YieldOp)&nbsp;<a class=headline-hash href=#gpuyield-gpuyieldop>¶</a></h3><p><em>GPU yield operation</em></p><p>gpu.yield` is a special terminator operation for blocks inside regions
in gpu ops. It returns values to the immediately enclosing gpu op.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>gpu<span class=p>.</span>yield <span class=nv>%f0</span><span class=p>,</span> <span class=nv>%f1</span> <span class=p>:</span> <span class=k>f32</span><span class=p>,</span> <span class=k>f32</span>
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait, Terminator</p><p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-41>Operands:&nbsp;<a class=headline-hash href=#operands-41>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>values</code></td><td>variadic of any type</td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://mlir.llvm.org/docs/Dialects/Func/ title="'func' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - 'func' Dialect</a>
<a class="nav nav-next" href=https://mlir.llvm.org/docs/Dialects/IndexOps/ title="'index' Dialect">Next - 'index' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=https://mlir.llvm.org/users/>Users of MLIR</a></li><li><a href=https://mlir.llvm.org/pubs/>MLIR Related Publications</a></li><li><a href=https://mlir.llvm.org/talks/>Talks</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/deprecation/>Deprecations & Current Refactoring<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/deprecation/TestingGuide/>Testing Guide haha</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/getting_started/ReportingIssues/>Reporting Issues</a></li><li><a href=https://mlir.llvm.org/getting_started/Debugging/>Debugging Tips</a></li><li><a href=https://mlir.llvm.org/getting_started/Faq/>FAQ</a></li><li><a href=https://mlir.llvm.org/getting_started/Contributing/>How to Contribute</a></li><li><a href=https://mlir.llvm.org/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=https://mlir.llvm.org/getting_started/openprojects/>Open Projects</a></li><li><a href=https://mlir.llvm.org/getting_started/Glossary/>Glossary</a></li><li><a href=https://mlir.llvm.org/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-reduce/>MLIR Reduce</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/ActionTracing/>Action: Tracing and Debugging MLIR-based Compilers</a></li><li><a href=https://mlir.llvm.org/docs/BufferDeallocationInternals/>Buffer Deallocation - Internals</a></li><li><a href=https://mlir.llvm.org/docs/Bufferization/>Bufferization</a></li><li><a href=https://mlir.llvm.org/docs/DataLayout/>Data Layout Modeling</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/DefiningDialects/>Defining Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/DefiningDialects/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Operations/>Operation Definition Specification (ODS)</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/DialectConversion/>Dialect Conversion</a></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMDGPU/>'amdgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArithOps/>'arith' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSME/>'ArmSME' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Func/>'func' Dialect</a></li><li class=active><a href=https://mlir.llvm.org/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IndexOps/>'index' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IRDL/>'irdl' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Mesh/>'mesh' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/>'omp' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/UBOps/>'ub' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MatchOpInterfaces/>OpInterface definitions</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Interfaces/>Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=https://mlir.llvm.org/docs/BytecodeFormat/>MLIR Bytecode Format</a></li><li><a href=https://mlir.llvm.org/docs/CAPI/>MLIR C API</a></li><li><a href=https://mlir.llvm.org/docs/LangRef/>MLIR Language Reference</a></li><li><a href=https://mlir.llvm.org/docs/ReleaseNotes/>MLIR Release Notes</a></li><li><a href=https://mlir.llvm.org/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=https://mlir.llvm.org/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/Passes/>Passes</a></li><li><a href=https://mlir.llvm.org/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=https://mlir.llvm.org/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=https://mlir.llvm.org/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/SideEffectsAndSpeculation/>Side Effects & Speculation</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/ShapeInference/>Shape Inference</a></li><li><a href=https://mlir.llvm.org/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=https://mlir.llvm.org/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=https://mlir.llvm.org/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Traits/>Traits<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Traits/Broadcastable/>The `Broadcastable` Trait</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/transform/>Transform Dialect Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch0/>Chapter 0: A Primer on “Structured” Linalg Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch1/>Chapter 1: Combining Existing Transformations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch2/>Chapter 2: Adding a Simple New Transformation Operation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch3/>Chapter 3: More than Simple Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/ChH/>Chapter H: Reproducing Halide Schedule</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>